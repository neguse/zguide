---
weight: 999
---

# ポストフェイス

## Tales from Out There {#postface}

この本の寄稿者の何人かに、ZeroMQで何をしているのか話してくれるように頼みました。以下、彼らのストーリーを紹介しよう。

### Rob Gagnonの話 {#Rob-Gagnon-s-Story}

"私たちはZeroMQを使用して、通信サーバーのグローバルネットワークで毎分発生する何千ものイベントを集約し、注意を要する状況を正確に報告・監視できるよう支援しています。ZeroMQは、システムの開発を容易にするだけでなく、開発期間を短縮し、当初の設計で予定していたよりも堅牢で耐障害性の高いものにしました。

"メッセージを失うことなく、ネットワークからクライアントを簡単に追加・削除することができるようになりました。システムのサーバー部分を強化する必要がある場合、最初にすべてのクライアントを停止することを心配することなく、サーバーも停止して再起動することができます。ZeroMQの内蔵バッファリングが、これを可能にしているのです。

### トム・ヴァン・リューウェンのストーリー {#Tom-van-Leeuwen-s-Story}

"私は、あらゆる種類のサービスを結びつける、ある種のサービスバスを作ることを検討していました。ブローカーを実装した製品はすでにいくつかありましたが、私が必要としている機能はありませんでした。偶然、ZeroMQに出会いましたが、これは素晴らしいです。非常に軽量で無駄がなく、シンプルで、ガイドが非常に充実していて読みやすいので、簡単に従うことができます。私は実際にTitanicパターンとMajordomoブローカーを実装し、いくつかの追加（クライアント/ワーカーの認証、ワーカーが何を提供し、どのように対処すべきかを説明するカタログを送信する）を行いました。

"ZeroMQの美しいところは、それがライブラリであり、アプリケーションではないという事実です。キューイング、再接続、TCPソケットなどの退屈なことをバックグラウンドに置くだけで、自分にとって重要なことに集中できるようにすることができます。Rubyでワーカーやクライアント、ブローカーを実装しました。Rubyは私たちが開発に使っているメイン言語だからです。このサービスバスをクラウドサービスに利用し、あらゆるプラットフォームデバイスをサービスバスに接続し、自動化のための機能を公開しています。

"ZeroMQは非常に理解しやすく、ガイドを1日読めば、その仕組みについて十分な知識を得ることができるだろう。私はネットワークエンジニアであり、ソフトウェア開発者ではありませんが、自動化のニーズに対して非常に優れたソリューションを作成することができました！ZeroMQ：ありがとうございました！"

### マイケル・ジャクルのストーリー {#Michael-Jakl-s-Story}

"私たちは、分散処理パイプラインで1日あたり何百万ものドキュメントを配布するためにZeroMQを使用しています。当初は大きなメッセージキューイングブローカーを使用していましたが、それぞれに問題や課題がありました。アーキテクチャを単純化するために、配線にZeroMQを選びました。これまでのところ、アーキテクチャの拡張性やコンポーネントの変更・移動のしやすさに大きな影響を及ぼしています。言語バインディングが豊富なため、システムの相互運用性を犠牲にすることなく、仕事に適したツールを選択することができます。私たちはソケットをあまり使いませんが（アプリケーション全体で10個未満）、巨大なモノリシック・アプリケーションを小さな独立したパーツに分割するために必要なのはそれだけです。

「全体として、ZeroMQのおかげで私は正気を保つことができ、顧客は予算内に収まるようになりました」。

### ヴァディム・シャルツの体験談 {#Vadim-Shalts-s-Story}

「私は、金融市場向けのソフトウェアを開発するActForex社でチームリーダーを務めています。私たちの領域の性質上、大量の価格を迅速に処理する必要があります。また、注文や価格を処理する際の待ち時間を最小限に抑えることが非常に重要です。高いスループットを実現するだけでは十分ではありません。すべてをソフトリアルタイムで、価格ごとの予測可能な超低遅延で処理する必要があります。システムは、メッセージをやり取りする複数のコンポーネントで構成されています。各価格には多くの処理段階があり、それぞれが総レイテンシーを増加させます。そのため、コンポーネント間のメッセージングのレイテンシーを低く予測できることが、我々のアーキテクチャの重要な要素となっています。

「私たちのニーズに合ったものを見つけるために、さまざまなソリューションを検討しました。さまざまなメッセージブローカー（RabbitMQ、ActiveMQ Apollo、Kafka）を試しましたが、いずれも低く予測可能なレイテンシーに到達することができませんでした。最終的には、ZooKeeperと組み合わせてサービス・ディスカバリーに使用するZeroMQを選びました。ZeroMQを使った複雑な調整は、マルチスレッドの自然な複雑さの結果、比較的大きな努力と十分な理解を必要とします。ZooKeeperのような外部エージェントは、サービスの発見と調整に適しており、ZeroMQは主に単純なメッセージングに使用できることがわかりました。ZeroMQは、私たちのアーキテクチャに完璧にフィットしました。ZeroMQのおかげで、最小限の努力で望ましいレイテンシーを達成することができました。メッセージ処理のボトルネックから解放され、処理時間が非常に安定し、予測しやすくなりました。

「低レイテンシーが重要なソリューションには、ZeroMQを断固としてお勧めします。

## この本はどのように起こったのか？ {#How-This-Book-Happened}

私がZeroMQの本を書こうと思ったとき、ZeroMQコミュニティではフォークやプルリクエストの是非についてまだ議論している最中でした。2012年初めに<tt>libzmq</tt>で採用した「リベラル」ポリシーは、一人の主要な作者への依存を解消し、何十人もの新しい貢献者にフロアを開放しました。より深いところでは、旧来の強制的な行進モデルとはまったく異なる、緩やかで有機的な進化モデルへと移行することができました。

これがうまくいくと確信したのは、『ガイド』の制作が1年以上にわたって、その道を示してきたからです。確かに、この文章は私自身の作品であり、それは当然のことかもしれません。書くことは、プログラミングではありません。書くということは、物語を語るということであり、異なる声でひとつの物語を語るというのは、違和感があります。

この本の長期的な価値は、24の言語で書かれた約65,000行のコードという実例集にあると思います。これは、ZeroMQをより多くの人が利用できるようにするためでもあるんです。ZeroMQの学習方法を他の人に教えたいとき、人々はすでにPythonとPHPのサンプルリポジトリ（最も充実した2つのリポジトリ）を参照しています。しかし、それはプログラミング言語を学ぶことでもあるのです。

ここにTclで書かれたコードのループがあります：

```Tcl
while {1} {
    # Process all parts of the message
    zmq message message
    frontend recv_msg message
    set more [frontend getsockopt RCVMORE]
    backend send_msg message [expr {$more?"SNDMORE":""}]
    message close
    if {!$more} {
        break ; # Last message part
    }
}
```

そして、同じループをLuaで書くとこうなります：

```Lua
while true do
    --  Process all parts of the message
    local msg = frontend:recv()
    if (frontend:getopt(zmq.RCVMORE) == 1) then
        backend:send(msg, zmq.SNDMORE)
    else
        backend:send(msg, 0)
        break;      --  Last message part
    end
end
```

この特定の例 (<tt>rrbroker</tt>) は、C#、C++、CL、Clojure、Erlang、F#、Go、Haskell、Haxe、Java、Julia、Lua、Node.js、Perl、PHP、Python、Ruby、Scala、Tcl、そしてもちろん C で存在します。このコードベースはすべて MIT/X11 ライセンスでオープンソース提供されていて、他の本やプロジェクトの土台となることもあります。

しかし、この翻訳集が最も深く語っているのは、「選択する言語は細部であり、邪魔でさえある」ということです。ZeroMQのパワーは、ZeroMQがあなたに与え、あなたに構築させるパターンにあり、これらは言語の往来を超越している。ソフトウェアとソーシャル・アーキテクトとしての私の目標は、何世代にもわたって使い続けられる構造を構築することです。たかが数十年を目指すことに意味はないように思います。

## 摩擦をなくす {#Removing-Friction}

私たちが使った技術的なツールチェーンについて、取り除いた摩擦の観点から説明します。この本では、私たちは物語を語っています。目標は、できるだけ多くの人に、できるだけ安く、スムーズに届けることです。

核となるアイデアは、テキストとサンプルをGitHubでホストし、誰もが簡単に貢献できるようにすることでした。しかし、それよりも複雑なことが判明しました。

まず、分業から始めましょう。私は文章を書くのが得意で、無限にあるまともな文章を素早く作成することができます。しかし、私にとって不可能だったのは、他の言語での例を提供することでした。ZeroMQのコアAPIはC言語なので、オリジナルの例文をC言語で書くのは理にかなっていると思ったし、C言語はニュートラルな選択で、強い感情を生まない唯一の言語かもしれない。

例題を翻訳してもらうためにはどうすればいいのでしょうか。いくつかのアプローチを試しましたが、最終的に最も効果的だったのは、本文中のすべての例文に「言語を選択してください」というリンクを設け、そのリンクをクリックすると、翻訳や貢献の方法を説明するページに移動するようにしたことです。この方法は、人々が自分の好きな言語でZeroMQを学ぶと、翻訳や既存言語の修正に貢献してくれるという仕組みです。

同時に、私は、非常に断固として、すべての例を翻訳している数人の人々に気づきました。これは主にバインディングの作者で、例文が自分のバインディングを使うことを奨励する素晴らしい方法であることに気づいていました。彼らの努力に報いるため、私はスクリプトを拡張し、言語固有のバージョンの本を作成しました。C言語のコードを掲載する代わりに、PythonやPHPのコードを掲載するようにしたのです。LuaやHaxeも専用のバージョンを作成した。

誰が何を担当するのかがわかれば、仕事の進め方も見えてきます。例を書いてテストするために、作業したいのは*ソースコード*であることは明らかです。だから、本を作るときにこのソースコードをインポートして、言語別バージョンを作るわけです。

私はプレーンテキスト形式で書くのが好きです。速くて、gitのようなソース管理システムとも相性がいいからです。私たちのウェブサイトのメインプラットフォームはウィキドットなので、ウィキドットの非常に読みやすいマークアップ形式を使って書いています。

少なくとも最初の章では、ピア間のメッセージの流れを説明するために、絵を描くことが重要でした。手作業で図を作るのは大変ですし、最終的に異なるフォーマットで出力したいときは、画像変換が面倒になります。私は、テキスト図をPNGにするDitaaから始め、その後、SVGファイルを生成するasciitosvgに切り替えましたが、これはむしろ良い方です。図がテキスト図であり、文章に埋め込まれているため、驚くほど簡単に作業できます。

もうお分かりだと思いますが、私たちが使っているツールチェーンは、多くの外部ツールを使いながら、高度にカスタマイズされています。すべてUbuntuで利用可能であり、これは慈悲であり、カスタムツールチェーン全体はzguideリポジトリのbinサブディレクトリにある。

それでは、編集と公開のプロセスを説明しましょう。ここでは、オンライン版を作成する方法を説明します：

```
bin/buildguide
```

これは次のような仕組みになっています：

* 原文は一連のテキストファイル（1章につき1つ）に格納されています。
* サンプルは、言語ごとに分類された examples サブディレクトリに格納されています。
* テキストを受け取り、Perlのカスタムスクリプトであるmkwikidotを使って、Wikidotに対応したファイル群に加工する。
* 私たちは、独自のバージョンを取得する各言語のためにこれを行う。
* グラフィックを抽出し、asciitosvgを呼び出し、画像ファイルを生成するためにそれぞれをラスタライズし、imagesサブディレクトリに保存します。
* インラインリスト(翻訳されていない)を抽出し、listingsサブディレクトリに格納します。
* それぞれの例とリストに対してpygmentizeを使い、Wikidotフォーマットでマークアップされたページを作成します。
* 変更されたすべてのファイルを、Wikidot APIを使用してオンラインWikiにアップロードします。

これを一からやるとなると、時間がかかります。そこで、すべての画像、リスト、例文、テキストファイルのSHA1署名を保存し、変更だけを処理してアップロードすることで、人々が新しい貢献をしたときに新しいバージョンのテキストを簡単に公開することができるようにしました。

PDFとEpubのフォーマットを作成するために、私たちは以下のことを行っています：

```
bin/buildpdfs
```

これは次のように動作します：

* 入力ファイルに対してカスタムmkdocbook Perlプログラムを使用し、DocBook出力を生成します。
* DocBookのフォーマットをdocbook2psとps2pdfでプッシュし、各言語のクリーンなPDFを作成します。
* DocBookのフォーマットをdb2epubでプッシュし、各言語のEpubブックを作成します。
* Wikidot APIを使って、PDFを公開Wikiにアップロードします。

コミュニティ・プロジェクトを作る場合、「変更待ち時間」を短くすることが重要です。これは、人々が自分の作品をライブで見るまでにかかる時間、少なくとも、あなたが彼らのプル・リクエストを受け入れたことを確認するまでにかかる時間です。もしそれが1～2日以上かかるようであれば、貢献者の興味を失ってしまうことが多いでしょう。

## ライセンス {#Licensing}

私は、このテキストを自分の仕事に再利用してもらいたいと考えています：プレゼンテーション、記事、そして他の本にも。しかし、もし彼らが私の作品をリミックスするならば、他の人も彼らの作品をリミックスできるという契約になっています。私は信用を得たいし、他の人がリミックスでお金を稼ぐことに異論はない。したがって、このテキストはcc-by-saでライセンスされています。

例題については、最初はGPLで始めたのですが、これは実行不可能であることが急速に明らかになりました。例のポイントは、人々がZeroMQをより広く使えるように、再利用可能なコード断片を与えることですが、これがGPLであれば、そうはいきません。私たちはMIT/X11に切り替えたのですが、より大規模で複雑な例では、LGPLとして動作する可能性がありました。

しかし、（Majordomoのように）サンプルをスタンドアロンのプロジェクトにするようになったとき、わたしたちはLGPLを使いました。繰り返しますが、リミックス可能性は普及に優先します。ライセンスは道具です。イデオロギーではなく、意図を持って使いましょう。

