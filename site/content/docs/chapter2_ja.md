---
weight: 2
title: '2.ソケットとパターン'
---

# 第2章 ソケットとパターン {#sockets-and-patterns}

[第1章 - 基本](chapter1#basics)では、ZeroMQをドライブし、主なZeroMQパターンであるリクエスト-リプライ、パブ-サブ、パイプラインの基本例をいくつか挙げました。この章では、実際に手を動かして、これらのツールを実際のプログラムで使用する方法を学び始めます。

本章では、これらのツールの実際のプログラムでの使用方法について、実際に手を動かして学んでいきます：

* ZeroMQ ソケットの作成方法と操作方法。
* ソケットでメッセージを送信および受信する方法。
* ZeroMQの非同期I/Oモデルを中心にアプリを構築する方法。
* 1つのスレッドで複数のソケットを処理する方法。
* 致命的なエラーと非致命的なエラーを適切に処理する方法。
* Ctrl-Cのような割り込み信号の扱い方。
* ZeroMQアプリケーションをクリーンにシャットダウンする方法。
* ZeroMQ アプリケーションのメモリリークを確認する方法。
* マルチパートメッセージの送受信方法。
* ネットワーク上でメッセージを転送する方法。
* シンプルなメッセージキューイングブローカーを構築する方法。
* ZeroMQでマルチスレッドアプリケーションを作成する方法。
* ZeroMQを使用してスレッド間でシグナルを送信する方法。
* ZeroMQを使用して、ノードのネットワークを調整する方法。
* Pub-Sub用のメッセージエンベロープの作成方法と使用方法。
* メモリオーバーフローから保護するためのHWM（ハイウォーターマーク）の使用方法。

## ソケットAPI {#The-Socket-API}

正直に言うと、ZeroMQはあなたに一種のスイッチ＆ベイトを行います。これはあなたのためであり、あなたが傷つくよりも私たちが傷つくのです。ZeroMQは使い慣れたソケットベースのAPIを提供するため、メッセージ処理エンジンの束を隠すのに大変な労力を必要とします。しかし、その結果、分散ソフトウェアの設計と記述方法に関するあなたの世界観が徐々に修正されていくでしょう。

ソケットは、ネットワークプログラミングの事実上の標準APIであり、目が頬に落ちるのを止めるのに役立つものでもあります。ZeroMQが開発者にとって特に魅力的なのは、他の任意の概念の集合ではなく、ソケットとメッセージを使用している点です。これを実現したMartin Sustrikに感謝します。メッセージ指向ミドルウェア」という、会場全体が緊張状態に陥るようなフレーズを、「エキストラ・スパイシー・ソケット！」と言い換え、私たちはピザが食べたくなり、もっと知りたくなるのです。

好物の料理のように、ZeroMQのソケットは消化しやすいのです。ソケットは、BSDのソケットと同じように、4つのパートで一命を取り留めます：

* ソケットの作成と破棄は、一緒になってソケットの生命のカルマの輪を形成します (<tt>[zmq_socket()](http://api.zeromq.org/master:zmq_socket)</tt>, <tt>[zmq_close()](http://api.zeromq.org/master:zmq_close)</tt> 参照)。

* ソケットのオプションを設定し、必要に応じてチェックすることでソケットを設定します (<tt>[zmq_setsockopt()](http://api.zeromq.org/master:zmq_setsockopt)</tt>, <tt>[zmq_getsockopt()](http://api.zeromq.org/master:zmq_getsockopt)</tt> 参照)。

* ソケットとの間で ZeroMQ 接続を作成することで、ソケットをネットワークトポロジーに組み込むことができます (<tt>[zmq_bind()](http://api.zeromq.org/master:zmq_bind)</tt>, <tt>[zmq_connect()](http://api.zeromq.org/master:zmq_connect)</tt> を参照).

* ソケットにメッセージを書き込んだり受信したりすることで、データを運ぶためにソケットを使用します (<tt>[zmq_msg_send()](http://api.zeromq.org/master:zmq_msg_send)</tt>, <tt>[zmq_msg_recv()](http://api.zeromq.org/master:zmq_msg_recv)</tt> を参照).

ソケットは常にボイドポインタであり、メッセージは構造体であることに注意してください（これについてはすぐに説明します）。ですから、C言語ではソケットはそのまま渡しますが、<tt>[zmq_msg_send()](http://api.zeromq.org/master:zmq_msg_send)</tt>や<tt>[zmq_msg_recv()](http://api.zeromq.org/master:zmq_msg_recv)</tt>といったメッセージを扱うすべての関数でメッセージのアドレスは渡すのです。ニーモニックとして、「ZeroMQでは、ソケットはすべて私たちのもの」ですが、メッセージはコード内で実際に所有するものであることを認識してください。

ソケットの作成、破棄、および設定は、どのオブジェクトでも期待通りに動作します。しかし、ZeroMQは非同期で伸縮性のあるファブリックであることを忘れないでください。これは、ソケットをネットワークトポロジーに接続する方法と、その後のソケットの使用方法に影響を与えます。

### ソケットをトポロジーに差し込む {#Plugging-Sockets-into-the-Topology}

2つのノード間で接続を作成するには、一方のノードで <tt>[zmq_bind()](http://api.zeromq.org/master:zmq_bind)</tt> を、もう一方のノードで <tt>[zmq_connect()](http://api.zeromq.org/master:zmq_connect)</tt> を使用します。 一般的な経験則として、<tt>[zmq_bind()](http://api.zeromq.org/master:zmq_bind)</tt>を行うノードは「サーバ」で、よく知られたネットワークアドレスに座っており、<tt>[zmq_connect()](http://api.zeromq.org/master:zmq_connect)</tt>を行うノードは「クライアント」で未知または任意のネットワークアドレスにあります。したがって、「ソケットをエンドポイントにバインドする」「ソケットをエンドポイントに接続する」と言い、エンドポイントはそのよく知られたネットワークアドレスです。

ZeroMQの接続は、従来のTCP接続とは多少異なります。主な違いは以下の通りです：

* 任意のトランスポート（<tt>inproc</tt>, <tt>ipc</tt>, <tt>tcp</tt>, <tt>pgm</tt>, または <tt>epgm</tt>） を経由します。<tt>[zmq_inproc()](http://api.zeromq.org/master:zmq_inproc)</tt>, <tt>[zmq_ipc()](http://api.zeromq.org/master:zmq_ipc)</tt>, <tt>[zmq_tcp()](http://api.zeromq.org/master:zmq_tcp)</tt>, <tt>[zmq_pgm()](http://api.zeromq.org/master:zmq_pgm)</tt> および <tt>[zmq_epgm()](http://api.zeromq.org/master:zmq_epgm)</tt> を参照して下さい。

* 1つのソケットに多数の送信コネクションと多数の受信コネクションを持つことができます。

<tt>zmq_accept</tt>() メソッドは存在しません。ソケットがエンドポイントにバインドされると、自動的に接続の受け付けを開始します。

* ネットワーク接続自体はバックグラウンドで行われ、ZeroMQはネットワーク接続が切断された場合（例えば、ピアが消えて戻ってきた場合）、自動的に再接続します。

* アプリケーションコードはこれらの接続を直接操作することはできません。

多くのアーキテクチャは、ある種のクライアント/サーバーモデルに従っており、サーバーは最も静的なコンポーネントであり、クライアントは最も動的なコンポーネント、つまり、最も頻繁に出入りするコンポーネントです。サーバーはクライアントから見えるが、必ずしもその逆ではない、というアドレスの問題もあります。つまり、たいていの場合、どのノードが <tt>[zmq_bind()](http://api.zeromq.org/master:zmq_bind)</tt> (サーバー)を行い、どのノードが <tt>[zmq_connect()](http://api.zeromq.org/master:zmq_connect)</tt> (クライアント)を行うべきかは明白です。また、使用しているソケットの種類にもよりますが、珍しいネットワークアーキテクチャの場合は例外もあります。ソケットの種類については後ほど説明します。

さて、サーバを起動する前にクライアントを起動することを想像してみてください。従来のネットワークでは、大きな赤い失敗フラグが立ってしまいます。しかし、ZeroMQでは、任意にピースを開始したり停止したりすることができます。クライアントノードが<tt>[zmq_connect()](http://api.zeromq.org/master:zmq_connect)</tt>を実行するとすぐに、接続が存在し、そのノードはソケットにメッセージを書き始めることができます。ある段階で(願わくば、メッセージがキューに入りすぎて破棄されたり、クライアントがブロックされたりする前に)、サーバーが生き返り、<tt>[zmq_bind()](http://api.zeromq.org/master:zmq_bind)</tt>を行い、ZeroMQはメッセージの配信を始めます。

サーバーノードは多くのエンドポイント（つまり、プロトコルとアドレスの組み合わせ）にバインドすることができ、1つのソケットを使ってこれを行うことができます。つまり、異なるトランスポートを介した接続を受け入れることができるのです：

{{< fragment name="binding" >}}
zmq_bind (socket, "tcp://*:5555");
zmq_bind (socket, "tcp://*:9999");
zmq_bind (socket, "inproc://somename");
{{< /fragment >}}

ほとんどのトランスポートでは、UDP などとは異なり、同じエンドポイントに 2 回バインドすることはできません。しかし、<tt>ipc</tt> トランスポートでは、あるプロセスが最初のプロセスによってすでに使われているエンドポイントにバインドすることができます。これは、プロセスがクラッシュした後に回復することを可能にするためのものです。

ZeroMQ は、どちらの側がバインドし、どちらの側が接続するかについて中立的であろうとしますが、相違点があります。これについては、後で詳しく説明します。要するに、トポロジーの静的な部分である「サーバー」は多かれ少なかれ固定されたエンドポイントにバインドし、「クライアント」はこれらのエンドポイントに出入りして接続する動的な部分として考えるのが一般的です。そして、このモデルを中心にアプリケーションを設計してください。そうすれば、「うまくいく」可能性はぐっと高まります。

ソケットには型があります。ソケットのタイプは、ソケットのセマンティクス、メッセージを内外にルーティングするためのポリシー、キューイングなどを定義します。例えば、パブリッシャーソケットとサブスクライバーソケットのように、特定のタイプのソケットを一緒に接続することができます。ソケットは「メッセージングパターン」で連携して動作します。これについては、後で詳しく見ていきます。

このようにさまざまな方法でソケットを接続できることが、ZeroMQにメッセージキューイングシステムとしての基本的な力を与えているのです。この上にプロキシなどのレイヤーがありますが、これについては後ほど説明します。しかし、基本的には、ZeroMQでは、子供の組み立ておもちゃのように部品を組み合わせて、ネットワークアーキテクチャを定義します。

### メッセージの送信と受信 {#Sending-and-Receiving-Messages}

メッセージを送受信するには、<tt>[zmq_msg_send()](http://api.zeromq.org/master:zmq_msg_send)</tt> と <tt>[zmq_msg_recv()](http://api.zeromq.org/master:zmq_msg_recv)</tt> というメソッドを使います。名前はありきたりですが、ZeroMQのI/Oモデルは古典的なTCPモデルとは十分に異なるので、それを理解するのに時間が必要です。

{{< textdiagram name="fig9.png" figno="9" title="TCP sockets are 1 to 1" >}}
#------------#
|    Node    |
+------------+
|   Socket   |
'------------'
      ^
      |
      | 1 to 1
      |
      v
.------------.
|   Socket   |
+------------+
|    Node    |
#------------#
{{< /textdiagram >}}

データを扱うことに関して、TCPソケットとZeroMQソケットの主な相違点を見てみましょう：

* ZeroMQソケットは、TCPのようなバイトのストリームではなく、UDPのようにメッセージを伝送します。ZeroMQのメッセージは、長さ指定のバイナリデータです。メッセージの設計はパフォーマンスに最適化されているため、少しトリッキーです。

* ZeroMQソケットは、バックグラウンドスレッドでI/Oを行います。つまり、メッセージがローカルの入力キューに到着し、ローカルの出力キューから送信されるのは、アプリケーションが何をしていても同じです。

* ZeroMQソケットには、ソケットタイプに応じた1対Nのルーティング動作が組み込まれています。

<tt>[zmq_send()](http://api.zeromq.org/master:zmq_send)</tt> メソッドは、実際にメッセージをソケット接続に送信するわけではありません。I/Oスレッドが非同期にメッセージを送信できるように、メッセージをキューに入れるのです。一部の例外的なケースを除き、ブロックすることはありません。したがって、<tt>[zmq_send()](http://api.zeromq.org/master:zmq_send)</tt>がアプリケーションに戻ったときにメッセージが送信されているとは限りません。

### ユニキャストトランスポート {#Unicast-Transports}

ZeroMQはユニキャストトランスポート(<tt>inproc</tt>, <tt>ipc</tt>, <tt>tcp</tt>) とマルチキャストトランスポート (epgm, pgm) のセットを用意しています。マルチキャストは、後で説明する高度な技術です。ファンアウト比が1対Nのユニキャストを不可能にすることが分かっていない限り、使い始めないでください。

ほとんどの一般的なケースでは、**<tt>tcp</tt>**を使用します。これは、*disconnected TCP*トランスポートであります。これは、ほとんどの場合において、伸縮性があり、ポータブルで、十分に高速です。ZeroMQの<tt>tcp</tt>トランスポートは、接続する前にエンドポイントが存在することを必要としないため、これを切断型と呼んでいます。クライアントとサーバーはいつでも接続とバインドが可能で、行ったり戻ったりすることができ、アプリケーションに対して透過的なままです。

プロセス間 <tt>ipc</tt> トランスポートは、<tt>tcp</tt> のように切断されたものです。これには1つの制限があります: Windowsではまだ動作しないのです。他のファイル名と衝突する可能性を避けるため、慣習としてエンドポイント名に ".ipc" という拡張子をつけています。UNIX システムでは、<tt>ipc</tt> エンドポイントを使用する場合、適切なパーミッションでこれらを作成する必要があり、そうしないと、異なるユーザー ID で実行中のプロセス間で共有できない場合があります。また、同じ作業ディレクトリで実行するなどして、すべてのプロセスがファイルにアクセスできるようにする必要があります。

スレッド間トランスポートである **<tt>inproc</tt>** は、接続されたシグナリングトランスポートである。<tt>tcp</tt>や<tt>ipc</tt>よりはるかに高速です。このトランスポートは、<tt>tcp</tt>や<tt>ipc</tt>と比較して、特定の制限を有しています： **クライアントが接続を発行する前に、サーバーがバインドを発行しなければなりません**。これはZeroMQ v4.0およびそれ以降のバージョンで修正されました。

### ZeroMQ は中立的なキャリアではありません {#ZeroMQ-is-Not-a-Neutral-Carrier}

ZeroMQの初心者がよくする質問（私自身もしたことがあります）に、"ZeroMQでXYZサーバーを書くにはどうしたらいいのですか？"というものがあります。例えば、"ZeroMQでHTTPサーバーを書くにはどうしたらいいですか？"というものです。その意味するところは、HTTPのリクエストとレスポンスを運ぶのに普通のソケットを使うなら、ZeroMQのソケットを使って同じことができるはずで、ただもっと速く、もっと良くできるはずだということです。

以前は「そうはいかない」という答えが返ってきていました。ZeroMQは中立的なキャリアではありません：使用するトランスポートプロトコルにフレームワークを課しています。このフレームワークは、独自のフレームワークを使用する傾向がある既存のプロトコルと互換性がありません。例えば、TCP/IP上のHTTPリクエストとZeroMQのリクエストを比較してみましょう。

{{< textdiagram name="fig10.png" figno="10" title="HTTP on the Wire" >}}
#----------------+----+----+----+----#
| GET /index.html| 13 | 10 | 13 | 10 |
#----------------+----+----+----+----#
{{< /textdiagram >}}

HTTPリクエストはCR-LFを最も単純な枠の区切りとして使っていますが、ZeroMQは長さを指定した枠を使っています。したがって、ZeroMQを使用して、例えばリクエストとリプライのソケットパターンを使用したHTTPライクなプロトコルを記述することができます。しかし、それはHTTPではないでしょう。

{{< textdiagram name="fig11.png" figno="11" title="ZeroMQ on the Wire" >}}
#---+---+---+---+---+---#
| 5 | H | E | L | L | O |
#---+---+---+---+---+---#
{{< /textdiagram >}}

しかし、v3.3以降、ZeroMQには<tt>ZMQ_ROUTER_RAW</tt>というソケットオプションがあり、ZeroMQのフレームを使わずにデータの読み書きができるようになっています。これを使えば、適切なHTTPリクエストとレスポンスの読み書きができるようになります。Hardeep Singhは、ZeroMQアプリケーションからTelnetサーバーに接続できるようにするために、この変更に貢献しました。この記事を書いている時点では、これはまだやや実験的なものですが、ZeroMQが新しい問題を解決するために進化を続けていることを表しています。もしかしたら、次のパッチはあなたのものになるかもしれません。

### I/Oスレッド {#I-O-Threads}

ZeroMQはバックグラウンドスレッドでI/Oを行うと述べました。最も極端なアプリケーションを除いては、1つのI/Oスレッド（全ソケット用）で十分です。新しいコンテキストを作成すると、1つのI/Oスレッドで開始されます。一般的な経験則では、1秒間に出入りするデータのギガバイトあたり1つのI/Oスレッドを許可します。I/Oスレッドの数を増やすには、<tt>[zmq_ctx_set()](http://api.zeromq.org/master:zmq_ctx_set)</tt>コールを、ソケットを作成する前に*使用します：

{{< fragment name="iothreads" >}}
int io_threads = 4;
void *context = zmq_ctx_new ();
zmq_ctx_set (context, ZMQ_IO_THREADS, io_threads);
assert (zmq_ctx_get (context, ZMQ_IO_THREADS) == io_threads);
{{< /fragment >}}

1つのソケットで数十、数千の接続を同時に処理できることを見てきました。このことは、アプリケーションの書き方に根本的な影響を及ぼします。従来のネットワークアプリケーションでは、リモート接続ごとに1つのプロセスまたは1つのスレッドがあり、そのプロセスまたはスレッドは1つのソケットを処理します。ZeroMQでは、この構造全体を1つのプロセスにまとめ、必要に応じて分割してスケーリングすることができます。

ZeroMQをスレッド間通信のみに使用している場合（つまり、外部ソケットI/Oを行わないマルチスレッドアプリケーション）、I/Oスレッドをゼロに設定することができます。しかし、これは重要な最適化ではなく、むしろ好奇心を刺激するものです。

## メッセージングパターン {#Messaging-Patterns}

ZeroMQのソケットAPIは茶色い紙で包まれていますが、その下にはメッセージングパターンの世界があります。もしあなたがエンタープライズメッセージングのバックグラウンドを持っていたり、UDPをよく知っていたりするならば、これらは何となく馴染みがあるでしょう。しかし、ほとんどのZeroMQ初心者にとって、これらは驚きです。私たちは、ソケットが他のノードに1対1でマッピングされるTCPパラダイムに慣れきっているからです。

ZeroMQが何をしてくれるのか、簡単にまとめてみましょう。ZeroMQは、データの塊（メッセージ）をノードに迅速かつ効率的に配信します。ノードをスレッド、プロセス、またはノードにマッピングすることができます。ZeroMQは、実際のトランスポート（プロセス内、プロセス間、TCP、マルチキャストなど）に関係なく、アプリケーションに単一のソケットAPIを提供し、動作させます。ピアの出入りに応じて、自動的にピアに再接続します。必要に応じて、送信側と受信側の両方でメッセージをキューに入れます。これらのキューを制限して、プロセスがメモリ不足にならないようにします。ソケットエラーを処理します。バックグラウンドのスレッドですべてのI/Oを実行します。ノード間の会話にはロックフリー技術を使用しているため、ロック、ウェイト、セマフォ、デッドロックが発生することはありません。

しかし、その一方で、パターン*と呼ばれる正確なレシピに従って、メッセージのルーティングとキューイングを行います。ZeroMQのインテリジェンスを提供するのは、このパターンです。パターンには、データや作業を分散させる最良の方法について、私たちが苦労して得た経験が凝縮されています。ZeroMQのパターンはハードコーディングされていますが、将来のバージョンではユーザーが定義可能なパターンを使用できるようになるかもしれません。

ZeroMQのパターンは、タイプが一致するソケットのペアによって実装されています。言い換えれば、ZeroMQのパターンを理解するには、ソケットの種類とそれらがどのように連携するかを理解する必要があります。ほとんどの場合、これは勉強が必要なだけで、このレベルで明白なことはほとんどありません。

内蔵のコアZeroMQパターンは以下の通りです：

一連のクライアントと一連のサービスを接続する * **Request-reply** です。これは、リモートプロシージャコールとタスク分配のパターンです。

* パブリッシャーのセットをサブスクライバーのセットに接続する **Pub-sub** 。これは、データ配布パターンです。

* 複数のステップとループを持つことができるファンアウト/ファンインパターンでノードを接続するパイプライン**。これは、並列タスクの分配と収集のパターンである。

* 2つのソケットを排他的に接続する「排他ペア」。これは、プロセス内の2つのスレッドを接続するためのパターンであり、ソケットの「通常の」ペアと混同しないようにします。

第1章 基礎編](chapter1#basics)で最初の3つを見てきましたが、この章の後半で排他的ペアパターンを見ることになります。<tt>[zmq_socket()](http://api.zeromq.org/master:zmq_socket)</tt> man ページには、このパターンについてかなり明確に書かれています -- 理解できるようになるまで何度か読む価値があります。これらは、コネクトとバインドのペアで有効なソケットの組み合わせです (どちらか一方がバインドできます)：

* PUBとSUB
* REQとREP
* REQとROUTER（REQは余分なヌルフレームを挿入するので注意すること）。
* DEALERとREP（REPはヌルフレームを想定しているので注意）。
* DEALERおよびROUTER
* DEALERとDEALER
* ROUTERとROUTER
* PUSHとPULL
* PAIRとPAIR

XPUBとXSUBソケットへの言及も見られますが、これは後で説明します（これらはPUBとSUBの生のバージョンのようなものです）。これ以外の組み合わせは、文書化されていない信頼性の低い結果を生み、ZeroMQの将来のバージョンでは、それらを試すとおそらくエラーを返します。もちろん、コードによって他のソケットタイプをブリッジすることもできますし、そうすることもできます。

### 高レベルのメッセージングパターン {#High-Level-Messaging-Patterns}

これら4つのコアパターンは、ZeroMQに調理されています。これらはZeroMQ APIの一部であり、コアC++ライブラリに実装され、すべての高級小売店で入手できることが保証されています。

これらの上に、私たちは*ハイレベル・メッセージング・パターン*を追加します。これらの高レベルのパターンをZeroMQの上に構築し、アプリケーションに使用するどのような言語でも実装します。これらはコアライブラリの一部ではなく、ZeroMQパッケージにも付属しておらず、ZeroMQコミュニティの一部として独自の空間に存在しています。例えば、[第4章 信頼性の高いリクエスト-リプライパターン](chapter4#reliable-request-reply)で紹介したMajordomoパターンは、ZeroMQの組織の中でGitHub Majordomoプロジェクトに置かれています。

本書で皆さんに提供することを目指すものの1つは、小さなもの（メッセージを正当に扱う方法）から大きなもの（信頼できるPub-Subアーキテクチャを作る方法）まで、こうした高レベルのパターンセットです。

### メッセージの扱い方 {#Working-with-Messages}

<tt>libzmq</tt>コアライブラリは、実はメッセージを送受信するための2つのAPIを持っています。すでに見てきた <tt>[zmq_send()](http://api.zeromq.org/master:zmq_send)</tt> と <tt>[zmq_recv()](http://api.zeromq.org/master:zmq_recv)</tt> のメソッドは、単純なワンライナーです。しかし、<tt>[zmq_recv()](http://api.zeromq.org/master:zmq_recv)</tt>は任意のメッセージサイズに対応するのが苦手です。そこで、zmq_msg_t 構造体を扱う第二の API が用意され、より豊富で、より難しい API が用意されています：

* メッセージを初期化します： <tt>[zmq_msg_init()](http://api.zeromq.org/master:zmq_msg_init)</tt>, <tt>[zmq_msg_init_size()](http://api.zeromq.org/master:zmq_msg_init_size)</tt>, <tt>[zmq_msg_init_data()](http://api.zeromq.org/master:zmq_msg_init_data)</tt>.
* メッセージの送信と受信 <tt>[zmq_msg_send()](http://api.zeromq.org/master:zmq_msg_send)</tt>, <tt>[zmq_msg_recv()](http://api.zeromq.org/master:zmq_msg_recv)</tt>.
* メッセージをリリースします： <tt>[zmq_msg_close()](http://api.zeromq.org/master:zmq_msg_close)</tt>.
* メッセージの内容にアクセスします： <tt>[zmq_msg_data()](http://api.zeromq.org/master:zmq_msg_data)</tt>, <tt>[zmq_msg_size()](http://api.zeromq.org/master:zmq_msg_size)</tt>, <tt>[zmq_msg_more()](http://api.zeromq.org/master:zmq_msg_more)</tt>.
* メッセージのプロパティを扱うことができます： <tt>[zmq_msg_get()](http://api.zeromq.org/master:zmq_msg_get)</tt>, <tt>[zmq_msg_set()](http://api.zeromq.org/master:zmq_msg_set)</tt>.
* メッセージの操作 <tt>[zmq_msg_copy()](http://api.zeromq.org/master:zmq_msg_copy)</tt>, <tt>[zmq_msg_move()](http://api.zeromq.org/master:zmq_msg_move)</tt> です。

ワイヤ上では、ZeroMQメッセージは、メモリに収まる0から上の任意のサイズのブロブです。プロトコルバッファ、msgpack、JSON、その他アプリケーションが話す必要のあるものを使って、自分でシリアライズします。ポータブルなデータ表現を選択するのが賢明ですが、トレードオフについて自分で判断することもできます。

メモリ上では、ZeroMQメッセージは<tt>zmq_msg_t</tt>構造体（または言語によってはクラス）です。C言語でZeroMQメッセージを使用するための基本的な基本ルールは以下の通りです：

* データブロックではなく、<tt>zmq_msg_t</tt>オブジェクトを作成し、それを渡します。

* メッセージを読むには、<tt>[zmq_msg_init()](http://api.zeromq.org/master:zmq_msg_init)</tt>を使って空のメッセージを作成し、それを<tt>[zmq_msg_recv()](http://api.zeromq.org/master:zmq_msg_recv)</tt>に渡します。

* 新しいデータからメッセージを書くには、<tt>[zmq_msg_init_size()](http://api.zeromq.org/master:zmq_msg_init_size)</tt>を使ってメッセージを作成し、同時にある程度の大きさのデータブロックを割り当てます。そして、<tt>memcpy</tt>を使ってデータを埋め、<tt>[zmq_msg_send()](http://api.zeromq.org/master:zmq_msg_send)</tt>にそのメッセージを渡します。

* メッセージを解放する (破棄しない) には、<tt>[zmq_msg_close()](http://api.zeromq.org/master:zmq_msg_close)</tt>を呼びます。これは参照を削除し、最終的にZeroMQはメッセージを破棄します。

* メッセージの内容にアクセスするには、<tt>[zmq_msg_data()](http://api.zeromq.org/master:zmq_msg_data)</tt>を使用します。メッセージに含まれるデータの量を知るには、<tt>[zmq_msg_size()](http://api.zeromq.org/master:zmq_msg_size)</tt>を使います。

<tt>[zmq_msg_move()](http://api.zeromq.org/master:zmq_msg_move)</tt>, <tt>[zmq_msg_copy()](http://api.zeromq.org/master:zmq_msg_copy)</tt>, <tt>[zmq_msg_init_data()](http://api.zeromq.org/master:zmq_msg_init_data)</tt> はマニュアルページを読んでなぜこれらが必要なのかを正確に理解していない場合は使わないでください。

<tt>[zmq_msg_send()](http://api.zeromq.org/master:zmq_msg_send)</tt> にメッセージを渡した後、ØMQ はメッセージをクリアします。同じメッセージを2回送信することはできませんし、送信後にメッセージデータにアクセスすることはできません。

<tt>[zmq_send()](http://api.zeromq.org/master:zmq_send)</tt> と <tt>[zmq_recv()](http://api.zeromq.org/master:zmq_recv)</tt> では、メッセージ構造体ではなくバイト配列が渡されるため、これらのルールは適用されません。

同じメッセージを複数回送りたい場合で、かつサイズが大きい場合は、2番目のメッセージを作成し、<tt>[zmq_msg_init()](http://api.zeromq.org/master:zmq_msg_init)</tt>で初期化し、<tt>[zmq_msg_copy()](http://api.zeromq.org/master:zmq_msg_copy)</tt>で最初のメッセージの写しを作成する。これはデータをコピーするのではなく、参照をコピーするのです。その後、メッセージを2回送信することができ（コピーをさらに作成する場合はそれ以上）、メッセージは最後のコピーが送信されるか閉じられたときにのみ、最終的に破棄されます。

ZeroMQは*multipart*メッセージもサポートしており、フレームのリストを1つのオンザワイヤーメッセージとして送受信することができます。これは実際のアプリケーションで広く使われており、この章の後半と[第3章 - 高度なリクエスト-リプライパターン](chapter3#advanced-request-reply)で見ていきます。

フレーム（ZeroMQリファレンスマニュアルのページでは「メッセージパート」とも呼ばれる）は、ZeroMQメッセージの基本的なワイヤフォーマットです。フレームは、長さが指定されたデータブロックです。長さはゼロから上にすることができます。TCPプログラミングをしたことがあれば、フレームが "このネットワークソケットから今どれだけのデータを読み取ればいいのか？"という質問に対する有用な答えであることが理解できるでしょう。

ZeroMQがTCP接続でフレームを読み書きする方法を定義する、ワイヤーレベルの[ZMTPというプロトコル](http://rfc.zeromq.org/spec:15)が存在します。この仕組みに興味がある方は、この仕様書がかなり短いので、ぜひご覧ください。

元々、ZeroMQメッセージはUDPのように1つのフレームでした。これは、単に「more」ビットが1に設定されたフレームと、そのビットが0に設定されたフレームが連続するメッセージです。ZeroMQ APIでは、"more "フラグを持つメッセージを書き、メッセージを読むときに "more "があるかどうかを確認することができます。

低レベルのZeroMQ APIとリファレンスマニュアルでは、メッセージとフレームについて不明確な点があります。そこで、便利な辞書を紹介します：

* メッセージは、1つまたは複数のパーツになります。
メッセージは1つ以上のパーツから構成される * これらのパーツは "フレーム "とも呼ばれる。
* 各パートは<tt>zmq_msg_t</tt>オブジェクトです。
* 低レベルのAPIでは、それぞれのパートを個別に送受信します。
* 上位のAPIでは、マルチパートメッセージ全体を送信するためのラッパーが提供されています。

その他、メッセージについて知っておくとよいことがいくつかあります：

* 例えば、あるスレッドから別のスレッドにシグナルを送信するために、長さゼロのメッセージを送信することができます。

* ZeroMQは、メッセージのすべてのパート（1つまたは複数）、またはそれらのいずれかを配信することを保証します。

* ZeroMQは、メッセージ（シングルまたはマルチパート）をすぐに送信するのではなく、不確定な後日、送信します。したがって、マルチパート・メッセージはメモリに収まる必要があります。

* メッセージ（シングルまたはマルチパート）は、メモリに収まる必要があります。任意の大きさのファイルを送りたい場合は、ファイルを分割し、それぞれを別々のシングルパート・メッセージとして送信する必要があります。*マルチパートデータを使用しても、メモリ消費量を減らすことはできません。

* スコープクローズ時にオブジェクトを自動的に破棄しない言語では、受信したメッセー ジを終了する際に <tt>[zmq_msg_close()](http://api.zeromq.org/master:zmq_msg_close)</tt> を呼ぶ必要があります。メッセージを送信した後にこのメソッドを呼び出すことはありません。

また、繰り返しになりますが、<tt>[zmq_msg_init_data()](http://api.zeromq.org/master:zmq_msg_init_data)</tt>はまだ使用しないでください。これはゼロコピーのメソッドであり、あなたにトラブルが発生することが保証されています。マイクロ秒を削ることを気にし始める前に、ZeroMQについて学ぶべきはるかに重要なことがあります。

この豊富なAPIは、作業するのに疲れることがあります。メソッドはパフォーマンスのために最適化されており、シンプルではありません。これらを使い始めると、マニュアルページをある程度注意深く読むまで、ほぼ間違いなく間違うことになります。そこで、優れた言語バインディングの主な仕事の1つは、このAPIをより使いやすいクラスで包むことです。

### 複数のソケットを扱う {#Handling-Multiple-Sockets}

これまでのすべての例で、ほとんどの例のメインループは次のようになっています：

1. ソケットのメッセージを待つ。
1. メッセージを処理する。
1. を繰り返す。

複数のエンドポイントから同時に読み取りたい場合はどうすればよいでしょうか？最もシンプルな方法は、1つのソケットをすべてのエンドポイントに接続し、ZeroMQにファンインをやってもらうことです。これは、リモートエンドポイントが同じパターンであれば合法ですが、PULLソケットをPUBエンドポイントに接続するのは間違いです。

実際に複数のソケットから一度に読み込むには、<tt>[zmq_poll()](http://api.zeromq.org/master:zmq_poll)</tt>を使用します。さらに良い方法は、<tt>[zmq_poll()](http://api.zeromq.org/master:zmq_poll)</tt>をイベント駆動型*リアクタ*に変えるフレームワークで包むことかもしれませんが、それはここで取り上げたいよりもかなり大変なことです。

まず、汚いハックから始めましょう。それは、正しくできないことを楽しむためでもありますが、主にノンブロッキングのソケットリードの方法を紹介するためです。以下は、ノンブロッキングリードを使用して2つのソケットから読み取る簡単な例です。このやや混乱したプログラムは、天気予報の更新の購読者としても、並列タスクのワーカーとしても動作します：

{{< examples name="msreader" title="マルチソケットリーダー" >}}。

このアプローチの代償として、最初のメッセージの待ち時間が追加されます（処理待ちのメッセージがないときに、ループの最後でスリープします）。これは、サブミリ秒のレイテンシが重要なアプリケーションでは問題になるでしょう。また、nanosleep()や使用する関数のドキュメントをチェックして、それがビジーループしないことを確認する必要があります。

この例で行ったように優先順位をつけるのではなく、まず1つから読み、次に2つから読むことで、ソケットを公平に扱うことができます。

では、<tt>[zmq_poll()](http://api.zeromq.org/master:zmq_poll)</tt>を使って、同じように無意味な小さなアプリケーションを正しく実行して見ましょう：

{{< examples name="mspoller" title="Multiple socket poller" >}}

The items structure has these four members:

```C
typedef struct {
    void *socket;       //  ZeroMQ socket to poll on
    int fd;             //  OR, native file handle to poll on
    short events;       //  Events to poll on
    short revents;      //  Events returned after poll
} zmq_pollitem_t;
```

### マルチパートメッセージ {#Multipart-Messages}

ZeroMQでは、複数のフレームからメッセージを構成することができ、"マルチパートメッセージ "を得ることができます。現実的なアプリケーションでは、メッセージをアドレス情報でラッピングしたり、単純なシリアライズのために、マルチパートメッセージを多用します。返信用封筒については後ほど説明します。

今学ぶのは、メッセージを検査せずに転送する必要のあるアプリケーション（プロキシなど）において、マルチパートメッセージを盲目的かつ安全に読み書きする方法です。

マルチパートメッセージを扱う場合、各部分は <tt>zmq_msg</tt> アイテムになります。例えば、5つのパートを持つメッセージを送信する場合、5つの<tt>zmq_msg</tt>アイテムを構築し、送信し、破棄しなければなりません。これを事前に行うこともできますし（<tt>zmq_msg</tt>アイテムを配列などの構造体に格納しておく）、1つ1つ送信しながら行うこともできます。

以下は、マルチパートメッセージでフレームを送信する方法です（各フレームをメッセージオブジェクトに受信します）：

{{< fragment name="sendmore" >}}
zmq_msg_send (&message, socket, ZMQ_SNDMORE);
...
zmq_msg_send (&message, socket, ZMQ_SNDMORE);
...
zmq_msg_send (&message, socket, 0);
{{< /fragment >}}

以下は、シングルパートでもマルチパートでも、メッセージ内のすべてのパートを受信して処理する方法です：

{{< fragment name="recvmore" >}}
while (1) {
    zmq_msg_t message;
    zmq_msg_init (&message);
    zmq_msg_recv (&message, socket, 0);
    //  Process the message frame
    ...
    zmq_msg_close (&message);
    if (!zmq_msg_more (&message))
        break;      //  Last message frame
}
{{< /fragment >}}

マルチパートメッセージについて知っておくべきことがいくつかあります：

マルチパートメッセージについて知っておくべきこと： * マルチパートメッセージを送信する場合、最初の部分(とそれに続くすべての部分)は、最後の部分を送信するときにのみ実際にワイヤ上に送信されます。
<tt>[zmq_poll()](http://api.zeromq.org/master:zmq_poll)</tt> を使っている場合、メッセージの最初の部分を受信すると、残りの部分 もすべて受信しています。
* メッセージのすべての部分を受信することも、まったく受信しないこともできます。
* メッセージの各部分はそれぞれ別の <tt>zmq_msg</tt> アイテムです。
* moreプロパティをチェックしてもしなくても、メッセージのすべての部分を受け取ることができます。
* 送信時に、ZeroMQは最後のメッセージを受信するまでメモリ内のメッセージ・フレームをキューに入れ、その後、それらをすべて送信します。
* 部分的に送信されたメッセージをキャンセルする方法は、ソケットをクローズする以外にはありません。

### 仲介者とプロキシ {#Intermediaries-and-Proxies}

ZeroMQは分散型のインテリジェンスを目指していますが、だからといってネットワークが中途半端な空白地帯になるわけではありません。ネットワークはメッセージを認識するインフラで満たされており、多くの場合、そのインフラをZeroMQで構築しています。ZeroMQの配管は、小さなパイプから本格的なサービス指向のブローカーまで、さまざまなものがあります。メッセージング業界ではこれを*仲介*と呼び、中間にあるものがどちらかの側と取引することを意味します。ZeroMQでは、文脈に応じて、これらをプロキシ、キュー、フォワーダー、デバイス、ブローカーと呼んでいます。

このパターンは現実世界では非常に一般的で、そのため私たちの社会や経済は、より大きなネットワークの複雑さとスケーリングコストを軽減すること以外に本当の機能を持たない仲介者で満たされています。現実世界の仲介者は、通常、卸売業者、流通業者、管理者などと呼ばれる。

### 動的発見の問題 {#The-Dynamic-Discovery-Problem}

大規模な分散アーキテクチャを設計する際に直面する問題の1つに、ディスカバリーがあります。つまり、断片が互いのことをどのように知るか、ということです。この問題を「動的発見問題」と呼びます。

ダイナミックディスカバリーには、いくつかの解決策があります。最も簡単なのは、ネットワーク・アーキテクチャをハードコーディング（設定）して、ディスカバリーを手作業で行うようにすることで、完全に回避する方法です。つまり、新しい部品を追加したら、その部品について知るためにネットワークを再設定するのです。

{{< textdiagram name="fig12.png" figno="12" title="Small-Scale Pub-Sub Network" >}}
                 #-----------#
                 | Publisher |
                 +-----------+
                 |    PUB    |
                 '-----------'
                     bind
           tcp://192.168.55.210:5556
                       |
                       |
      .----------------+----------------.
      |                |                |
      |                |                |
   connect           connect          connect
.------------.   .------------.   .------------.
|    SUB     |   |    SUB     |   |    SUB     |
+------------+   +------------+   +------------+
| Subscriber |   | Subscriber |   | Subscriber |
#------------#   #------------#   #------------#
{{< /textdiagram >}}

実際には、これはますます壊れやすく扱いにくいアーキテクチャをもたらすことになります。例えば、1人のパブリッシャーと100人のサブスクライバーがいるとしましょう。各サブスクライバーにパブリッシャーエンドポイントを設定し、各サブスクライバーをパブリッシャーに接続します。それは簡単です。サブスクライバーは動的で、パブリッシャーは静的です。では、さらにパブリッシャーを増やすとしましょう。突然、そう簡単にはいかなくなります。各サブスクライバーを各パブリッシャーに接続し続けると、ダイナミックディスカバリーを避けるためのコストはどんどん高くなります。

{{< textdiagram name="fig13.png" figno="13" title="Pub-Sub Network with a Proxy" >}}
#------------#   #------------#   #------------#
| Publisher  |   | Publisher  |   | Publisher  |
+------------+   +------------+   +------------+
|    PUB     |   |    PUB     |   |    PUB     |
'------------'   '------------'   '------------'
   connect          connect          connect
      |                |                |
      '----------------+----------------'
                       |
                      bind
                 .------------.
                 |    XSUB    |
                 +------------+
                 |   Proxy    |
                 +------------+
                 |    XPUB    |
                 '------------'
                      bind
                       |
      .----------------+----------------.
      |                |                |
   connect           connect          connect
.------------.   .------------.   .------------.
|    SUB     |   |    SUB     |   |    SUB     |
+------------+   +------------+   +------------+
| Subscriber |   | Subscriber |   | Subscriber |
#------------#   #------------#   #------------#
{{< /textdiagram >}}

これには非常に多くの答えがありますが、最もシンプルな答えは、仲介者を追加することです。つまり、他のすべてのノードが接続する、ネットワーク内の静的なポイントです。古典的なメッセージングでは、これはメッセージブローカーの仕事です。ZeroMQにはメッセージブローカーは付属していませんが、非常に簡単に仲介を構築することができます。

すべてのネットワークが最終的に仲介者を必要とするほど大きくなるのであれば、すべてのアプリケーションにメッセージブローカーを設置すればいいのではないか、と思うかもしれません。初心者の方にとっては、これは公平な妥協点です。常にスター型トポロジーを使用し、パフォーマンスのことは忘れて、物事はたいていうまくいきます。しかし、メッセージ・ブローカーは欲張りなもので、中央の仲介者としての役割を果たすうちに、複雑になりすぎ、ステートフルになりすぎ、ついには問題になってしまう。

仲介者は、単純なステートレスメッセージスイッチと考えたほうがよいでしょう。良い例えは、HTTPプロキシです。それはそこにありますが、特別な役割は持っていません。Pub-Subプロキシを追加することで、この例の動的検出の問題を解決することができます。プロキシをネットワークの「真ん中」に設置する。プロキシはXSUBソケットとXPUBソケットを開き、それぞれをよく知られたIPアドレスとポートにバインドする。そして、他のすべてのプロセスは、互いに接続するのではなく、プロキシに接続する。サブスクライバーやパブリッシャーを増やすのは簡単なことです。

{{< textdiagram name="fig14.png" figno="14" title="Extended Pub-Sub" >}}
#---------#   #---------#   #---------#
|   PUB   |   |   PUB   |   |   PUB   |
'----+----'   '----+----'   '----+----'
     |             |             |
     '-------------+-------------'
                   |
             .-----+-----.
             |   XSUB    |
             +-----------+
             |   code    |
             +-----------+
             |   XPUB    |
             '-----+-----'
                   |
     .-------------+-------------.
     |             |             |
.----+----.   .----+----.   .----+----.
|   SUB   |   |   SUB   |   |   SUB   |
#---------#   #---------#   #---------#
{{< /textdiagram >}}

ZeroMQがサブスクライバーからパブリッシャーへのサブスクリプション転送を行うため、XPUBとXSUBのソケットが必要です。XSUB と XPUB は SUB と PUB と全く同じですが、サブスクリプションを特別なメッセージとして公開します。プロキシは、XPUBソケットからサブスクリプションメッセージを読み、XSUBソケットに書き込むことによって、サブスクライバー側からパブリッシャー側へこれらのサブスクリプションメッセージを転送する必要があります。これがXSUBとXPUBの主なユースケースである。

### 共有キュー(DEALERとROUTERソケット) {#Shared-Queue-DEALER-and-ROUTER-sockets}

Hello Worldのクライアント/サーバーアプリケーションでは、1つのクライアントが1つのサービスと会話しています。しかし、実際のケースでは、複数のクライアントだけでなく、複数のサービスを許可する必要があるのが普通です。これにより、サービスのパワーをスケールアップすることができます（1つだけでなく、多くのスレッドやプロセス、ノード）。唯一の制約は、サービスがステートレスでなければならないことで、すべての状態はリクエストの中か、データベースなどの共有ストレージの中にある。

{{< textdiagram name="fig15.png" figno="15" title="Request Distribution" >}}
             #-----------#
             |  Client   |
             +-----------+
             |    REQ    |
             '-----+-----'
                   |
            R1, R2,| R3, R4
                   |
     .-------------+-------------.
     |             |             |
 R1, | R4          | R2          | R3
     |             |             |
     v             v             v
.---------.   .---------.   .---------.
|   REP   |   |   REP   |   |   REP   |
+---------+   +---------+   +---------+
| Service |   | Service |   | Service |
|    A    |   |    B    |   |    C    |
#---------#   #---------#   #---------#
{{< /textdiagram >}}

複数のクライアントと複数のサーバーを接続するには、2つの方法があります。総当たり的な方法は、各クライアントソケットを複数のサービスエンドポイントに接続する方法です。1つのクライアントソケットを複数のサービスソケットに接続し、REQソケットがこれらのサービス間でリクエストを分散させることができます。例えば、あるクライアントソケットをA、B、Cの3つのサービスエンドポイントに接続するとします。クライアントはR1、R2、R3、R4というリクエストを行います。R1とR4はサービスAへ、R2はBへ、R3はサービスCへ送られます。

この設計では、クライアントを安価に増やすことができます。また、サービスも増やせます。各クライアントはリクエストを各サービスに分散させます。しかし、各クライアントはサービスのトポロジーを知っておく必要があります。100台のクライアントがあり、さらに3つのサービスを追加することになった場合、クライアントが3つの新しいサービスを知るために、100台のクライアントを再設定して再起動する必要があります。

これは、スーパーコンピューティングクラスターのリソースが枯渇し、新しいサービスノードを数百台追加する必要がある午前3時に行うべきことではありません。知識は分散しているので、静的な部分が多ければ多いほど、トポロジーを変更するのに苦労することになります。そこで、クライアントとサービスの間に位置し、トポロジーに関するすべての知識を一元化するものが必要です。理想は、トポロジーの他の部分に触れることなく、いつでもサービスやクライアントを追加したり削除したりできることです。

そこで、このような柔軟性を持たせるために、小さなメッセージキューイングブローカーを作成することにします。ブローカーは、クライアント用のフロントエンドとサービス用のバックエンドの2つのエンドポイントにバインドします。そして、<tt>[zmq_poll()](http://api.zeromq.org/master:zmq_poll)</tt>を使って、この2つのソケットの活動を監視し、活動があれば、2つのソケット間でメッセージをシャトル化します。実際に明示的にキューを管理することはなく、ZeroMQが各ソケットで自動的に行います。

REPと話すためにREQを使用すると、厳密に同期的なリクエストとリプライのダイアログが表示されます。クライアントはリクエストを送信します。サービスはリクエストを読み、返信を送信します。その後、クライアントは応答を読みます。クライアントとサービスのどちらかがそれ以外のことをしようとすると（例えば、応答を待たずに2つのリクエストを連続して送信する）、エラーが発生することになります。

しかし、私たちのブローカーはノンブロッキングでなければなりません。もちろん、<tt>[zmq_poll()](http://api.zeromq.org/master:zmq_poll)</tt>を使って、どちらのソケットでも活動を待つことはできますが、REPとREQを使うことはできません。

{{< textdiagram name="fig16.png" figno="16" title="Extended Request-Reply" >}}
#---------#   #---------#   #---------#
|   REQ   |   |   REQ   |   |   REQ   |
'----+----'   '----+----'   '----+----'
     |             |             |
     '-------------+-------------'
                   |
             .-----+-----.
             |  ROUTER   |
             +-----------+
             |   code    |
             +-----------+
             |  DEALER   |
             '-----+-----'
                   |
     .-------------+-------------.
     |             |             |
     v             v             v
.---------.   .---------.   .---------.
|   REP   |   |   REP   |   |   REP   |
#---------#   #---------#   #---------#
{{< /textdiagram >}}

幸運なことに、DEALERとROUTERという2つのソケットがあり、ノンブロッキングのリクエスト・レスポンスができるようになっています。DEALERとROUTERのソケットを使えば、非同期のリクエスト・レスポンスフローを構築できることは、[第3章 高度なリクエスト・レスポンスパターン](chapter3#advanced-request-reply)で説明しています。今のところ、DEALERとROUTERによって、仲介者（つまり、小さなブローカー）にまたがってREQ-REPを拡張する方法を見るだけにしておきます。

この単純な拡張リクエスト-リプライパターンでは、REQがROUTERと話し、DEALERがREPと話す。DEALERとROUTERの間には、一方のソケットからメッセージを取り出し、他方のソケットに押し出すコード（ブローカー）が必要です。

リクエストリプライブローカーは2つのエンドポイントにバインドします。1つはクライアントが接続するためのもの（フロントエンドソケット）、もう1つはワーカーが接続するためのもの（バックエンド）です。このブローカーをテストするために、ワーカーをバックエンドソケットに接続するように変更する必要があります。以下に、私が言いたいことを示すクライアントを示します：

{{< examples name="rrclient" title="Request-reply client" >}}

こちらはワーカーです：

{{< examples name="rrworker" title="Request-reply worker" >}}

そして、これがマルチパートメッセージを適切に処理するブローカーです：

{{< examples name="rrbroker" title="Request-reply broker" >}}

{{< textdiagram name="fig17.png" figno="17" title="Request-Reply Broker" >}}
#---------#   #---------#   #---------#
| Client  |   | Client  |   | Client  |
+---------+   +---------+   +---------+
|   REQ   |   |   REQ   |   |   REQ   |
'----+----'   '----+----'   '----+----'
     |             |             |
     '-------------+-------------'
                   |
                   v
             .-----------.
             |  ROUTER   |
             +-----------+
             |  Broker   |
             +-----------+
             |  DEALER   |
             '-----+-----'
                   |
     .-------------+-------------.
     |             |             |
     v             v             v
.---------.   .---------.   .---------.
|   REP   |   |   REP   |   |   REP   |
+---------+   +---------+   +---------+
| Service |   | Service |   | Service |
|    A    |   |    B    |   |    C    |
#---------#   #---------#   #---------#
{{< /textdiagram >}}

リクエストリプライブローカーを使用すると、クライアント/サーバーアーキテクチャの拡張が容易になります。なぜなら、クライアントはワーカーを見ず、ワーカーはクライアントを見ません。唯一の静的なノードは、真ん中のブローカーです。

### ZeroMQの組み込みプロキシ機能 {#ZeroMQ-s-Built-In-Proxy-Function}

前のセクションの<tt>rrbroker</tt>のコアループは非常に便利で、再利用可能であることが判明しました。これによって、Pub-Subフォワーダーや共有キュー、その他の小さな仲介を、ほとんど労力をかけずに構築することができます。ZeroMQはこれを<tt>[zmq_proxy()](http://api.zeromq.org/master:zmq_proxy)</tt>という1つのメソッドにまとめています：

{{< fragment name="proxy" >}}
zmq_proxy (frontend, backend, capture);
{{< /fragment >}}

2つのソケット(データをキャプチャしたい場合は3つのソケット)は、適切に接続、結合、設定されていなければなりません。<tt>zmq_proxy</tt>メソッドを呼び出すと、まさに<tt>rrbroker</tt>のメインループを開始するようなものです。<tt>zmq_proxy</tt>を呼び出すように要求-応答ブローカーを書き直し、これを高価な響きを持つ「メッセージ キュー」として再バッジ付けしてみましょう (これ以下のコードに家を請求する人がいます)：

{{< examples name="msgqueue" title="Message queue broker" >}}

もしあなたが他のZeroMQユーザーと同じなら、この段階であなたの心は、"ランダムなソケットタイプをプロキシに差し込んだら、どんな悪いことができるのだろう？"と考え始めていることでしょう。 短い答えは、「試してみて、何が起きているのか調べてみる」です。実際には、ROUTER/DEALER、XSUB/XPUB、PULL/PUSHにこだわるのが普通でしょう。

### トランスポートブリッジング {#Transport-Bridging}

ZeroMQユーザーからの頻繁なリクエストは、「ZeroMQネットワークをテクノロジーXと接続するにはどうすればよいですか」（Xは他のネットワーキングまたはメッセージングテクノロジー）です。

{{< textdiagram name="fig18.png" figno="18" title="Pub-Sub Forwarder Proxy" >}}
               #-----------#
               | Publisher |
               +-----------+
               |    PUB    |
               '-----------'
                   bind
        tcp://192.168.55.210:5556
                    |
     .--------------+--------------.
     |              |              |
     v              v              v
.----------.   .----------.   .----------.
|   SUB    |   |   SUB    |   |   XSUB   |
+----------+   +----------+   +----------+
|Subscriber|   |Subscriber|   |  Proxy   |
#----------#   #----------#   +----------+
                              |   XPUB   |
                              '-----+----'
 Internal network                   |
====================================+=============
 External network                  bind
                           tcp://10.1.1.0:8100
                                    |
                            .-------+-------.
                            |               |
                            v               v
                       .----------.   .----------.
                       |   SUB    |   |   SUB    |
                       +----------+   +----------+
                       |Subscriber|   |Subscriber|
                       #----------#   #----------#
{{< /textdiagram >}}

簡単な答えは、*ブリッジ*を構築することです。ブリッジとは、あるソケットで1つのプロトコルを話し、別のソケットで2つ目のプロトコルとの間で変換する小さなアプリケーションのことです。プロトコルインタプリタのようなものです。ZeroMQでよくあるブリッジの問題は、2つのトランスポートやネットワークをブリッジすることです。

例として、パブリッシャーとサブスクライバーの間に位置し、2つのネットワークを橋渡しする小さなプロキシを書くことにします。フロントエンドのソケット (SUB) は天気予報サーバーがある内部ネットワークに面しており、バックエンド (PUB) は外部ネットワークにいる購読者に面しています。フロントエンドソケットで気象サービスを購読し、バックエンドソケットでそのデータをリパブリッシュする。

{{< examples name="wuproxy" title="天気予報アップデートプロキシ" >}}。

先ほどのプロキシの例と非常に似ていますが、重要なのは、フロントエンドとバックエンドのソケットが2つの異なるネットワーク上にあることです。このモデルは、例えばマルチキャストネットワーク (<tt>pgm</tt> トランスポート) と <tt>tcp</tt> パブリッシャーを接続するために使うことができます。

## エラー処理とETERM {#Handling-Errors-and-ETERM}

ZeroMQのエラー処理哲学は、フェイルファストとレジリエンスをミックスしたものです。プロセスは、内部エラーに対してはできるだけ脆弱であるべきであり、外部からの攻撃やエラーに対してはできるだけ堅牢であるべきであると私たちは考えています。例えるなら、生きた細胞は内部エラーを1つでも検出すれば自己破壊するが、外部からの攻撃にはあらゆる手段で対抗する。

ZeroMQのコードに散りばめられたアサーションは、堅牢なコードには絶対に欠かせないものです。そして、そのような壁があるべきです。もし、あるフォルトが内部なのか外部なのかが不明確であれば、それは修正すべき設計上の欠陥である。C/C++では、アサーションはエラーですぐにアプリケーションを停止させます。他の言語では、例外や停止が発生することもあります。

ZeroMQが外部障害を検出した場合、呼び出し元のコードにエラーを返します。まれに、エラーから回復するための明白な戦略がない場合、メッセージを静かに削除することもあります。

これまで見てきたほとんどのC言語の例では、エラー処理は行われていませんでした。**実際のコードでは、ZeroMQの呼び出しごとにエラー処理を行う必要があります**。C以外の言語バインディングを使用している場合、バインディングがエラーを処理することがあります。C言語では、これを自分で行う必要があります。POSIXの規約を始めとして、いくつかの簡単なルールがあります：

* オブジェクトを生成するメソッドは、失敗するとNULLを返します。
* データを処理するメソッドは、処理したバイト数を返すか、エラーや失敗の場合は-1を返す。
* その他のメソッドは，成功すると0を，エラーや失敗すると-1を返します．
* エラーコードは <tt>errno</tt> または <tt>[zmq_errno()](http://api.zeromq.org/master:zmq_errno)</tt> で示されます。
* ロギング用の説明的なエラーテキストは、<tt>[zmq_strerror()](http://api.zeromq.org/master:zmq_strerror)</tt>によって提供されます。

例えば

{{< fragment name="errorhandling" >}}
void *context = zmq_ctx_new ();
assert (context);
void *socket = zmq_socket (context, ZMQ_REP);
assert (socket);
int rc = zmq_bind (socket, "tcp://*:5555");
if (rc == -1) {
    printf ("E: bind failed: %s\n", strerror (errno));
    return -1;
}
{{< /fragment >}}

致命的でないものとして扱うべき例外条件は、主に2つあります：

<tt>ZMQ_DONTWAIT</tt> オプションを指定してメッセージを受信し、待機中のデータがない場合、ZeroMQは -1 を返し、<tt>errno</tt>に <tt>EAGAIN</tt> をセットします。

* あるスレッドが <tt>[zmq_ctx_destroy()](http://api.zeromq.org/master:zmq_ctx_destroy)</tt> を呼び出し、他のスレッドがまだブロック作業をしている場合、<tt>[zmq_ctx_destroy()](http://api.zeromq.org/master:zmq_ctx_destroy)</tt> コールはコンテキストを閉じ、すべてのブロック呼び出しは -1 で終了し、 <tt>errno</tt> を <tt>ETERM</tt> に設定しています。

C/C++ では、最適化されたコードではアサートは完全に削除することができます。見た目はきれいですが、最適化によってすべてのアサートと作りたい呼び出しが削除され、アプリケーションは印象的な方法で壊れてしまいます。

{{< textdiagram name="fig19.png" figno="19" title="Parallel Pipeline with Kill Signaling" >}}
             #-------------#
             |  Ventilator |
             +-------------+
             |    PUSH     |
             '------+------'
                    |
                    | tasks
                    |
    .---------------+---------------.
    |               |               |
    |     .=========+=====+=========+=====+======.
    |     :         |     :         |     :      :
    v     v         v     v         v     v      :
.------+-----.  .------+-----.  .------+-----.   :
| PULL | SUB |  | PULL | SUB |  | PULL | SUB |   :
+------+-----+  +------+-----+  +------+-----+   :
|   Worker   |  |   Worker   |  |   Worker   |   :
+------------+  +------------+  +------------+   :
|    PUSH    |  |    PUSH    |  |    PUSH    |   :
'-----+------'  '-----+------'  '-----+------'   :
      |               |               |          :
      '---------------+---------------'          :
                      |                          :
                      | results                  :
                      |                          :
                      v                          :
               .-------------.                   :
               |    PULL     |                   :
               +-------------+                   :
               |    Sink     |                   :
               +-------------+                   :
               |     PUB     +==== KILL signal==='
               '-------------'
{{< /textdiagram >}}

それでは、プロセスをきれいにシャットダウンする方法を紹介します。前節の並列パイプラインの例で説明します。バックグラウンドでたくさんのワーカーを起動した場合、バッチが終了した時点でワーカーを終了させたいと思います。そのためには、ワーカーにkillメッセージを送ります。これを行うにはシンクが最適です。シンクはバッチが終了したことを本当に知っているからです。

シンクをワーカーに接続するにはどうすればいいでしょうか？PUSH/PULLソケットは片方向のみです。他のソケットタイプに変更するか、複数のソケットフローを混在させることができます。後者の場合、PUB-SUBモデルを使ってワーカーにkillメッセージを送ることにしましょう：

* シンクは新しいエンドポイントに PUB ソケットを作成します。
* ワーカーは入力ソケットをこのエンドポイントに接続します。
* シンクがバッチの終了を検出すると、そのPUBソケットにkillを送信する。
* ワーカーはこのkillメッセージを検出すると、終了する。

シンクの新しいコードはあまり必要ありません：

{{< fragment name="killsignal" >}}
void *controller = zmq_socket (context, ZMQ_PUB);
zmq_bind (controller, "tcp://*:5559");
...
//  Send kill signal to workers
s_send (controller, "KILL");
{{< /fragment >}}

2つのソケット(タスクを取得するPULLソケットと、制御コマンドを取得するSUBソケット)を管理するワーカープロセスを、先ほど見た <tt>[zmq_poll()](http://api.zeromq.org/master:zmq_poll)</tt> の手法を使って紹介します：

{{< examples name="taskwork2" title="Parallel task worker with kill signaling" >}}。

これが、修正したシンクアプリケーションです。結果を収集し終わると、すべてのワーカーにkillメッセージをブロードキャストしています：

{{< examples name="tasksink2" title="Parallel task sink with kill signaling" >}}。

## 割り込み信号の処理 {#Handling-Interrupt-Signals}

現実的なアプリケーションでは、Ctrl-C や <tt>SIGTERM</tt> などのシグナルで中断されたときに、きれいにシャットダウンする必要があります。デフォルトでは、これらのシグナルは単にプロセスを終了させるだけなので、メッセージはフラッシュされず、ファイルはきれいに閉じられないといったことになります。

以下は、様々な言語でのシグナルの扱い方です：

{{< examples name="interrupt" title="Handling Ctrl-C cleanly" >}}

このプログラムは<tt>s_catch_signals()</tt>を提供しており、Ctrl-C（<tt>SIGINT</tt>）と<tt>SIGTERM</tt>をトラップしています。これらのシグナルのいずれかが到着すると、<tt>s_catch_signals()</tt>ハンドラはグローバル変数 <tt>s_interrupted</tt> を設定します。シグナルハンドラのおかげで、アプリケーションは自動的に終了することはありません。その代わりに、クリーンアップして優雅に終了するチャンスがあるのです。ここで、割り込みを明示的にチェックし、適切に処理する必要があります。メインコードの先頭で <tt>s_catch_signals()</tt> (<tt>interrupt.c</tt> からコピー) を呼び出すことで行います。これにより、シグナル処理が設定されます。割り込みはZeroMQの呼び出しに以下のように影響します：

* コードがブロッキング呼び出し(メッセージの送信、メッセージの受信、ポーリング)でブロックされている場合、シグナルが到着すると、呼び出しは <tt>EINTR</tt> で返されます。
* <tt>s_recv()</tt> のようなラッパーは、中断されると NULL を返します。

ですから、<tt>EINTR</tt>のリターンコード、NULLリターン、<tt>s_interrupted</tt>をチェックしてください。

以下は典型的なコードの一部です：

```
s_catch_signals ();
client = zmq_socket (...);
while (!s_interrupted) {
    char *message = s_recv (client);
    if (!message)
        break;          //  Ctrl-C used
}
zmq_close (client);
```

<tt>s_catch_signals()</tt> を呼び出し、割り込みのテストを行わない場合、アプリケーションは Ctrl-C や <tt>SIGTERM</tt> に対して免疫ができてしまい、これは便利かもしれませんが、通常はそうではありません。

## メモリリークの検出 {#Detecting-Memory-Leaks}

さもないと、最終的に利用可能なメモリを使い切ってクラッシュしてしまいます。もし、あなたがこの処理を自動的に行ってくれる言語を使っているなら、おめでとうございます。CやC++など、メモリ管理を担当する言語でプログラムしている場合、ここではvalgrindを使うための短いチュートリアルを紹介します。

* 例えば、UbuntuやDebianでは、以下のコマンドを実行してください：

```
sudo apt-get install valgrind
```

* デフォルトでは、ZeroMQはvalgrindに多くの警告を出させます。これらの警告を取り除くには、<tt>vg.supp</tt>というファイルを作成し、以下の内容を記述します：

```
{
   <socketcall_sendto>
   Memcheck:Param
   socketcall.sendto(msg)
   fun:send
   ...
}
{
   <socketcall_sendto>
   Memcheck:Param
   socketcall.send(msg)
   fun:send
   ...
}
```

* Ctrl-Cの後にアプリケーションがきれいに終了するように修正します。それ自体で終了するようなアプリケーションでは必要ありませんが、 長時間動作するアプリケーションでは、これは必須です。

* デフォルトの設定でない場合は、<tt>-DDEBUG</tt>でアプリケーションをビルドしてください。そうすることで、valgrind はメモリが漏れている場所を正確に伝えることができます。

* 最後に、このように valgrind を実行します：

```
valgrind --tool=memcheck --leak-check=full --suppressions=vg.supp someprog
```

そして、報告されたエラーを修正した後、楽しいメッセージが表示されるはずです：

```
==30536== ERROR SUMMARY: 0 errors from 0 contexts...
```

## ZeroMQ によるマルチスレッド {#Multithreading-with-ZeroMQ}

ZeroMQはおそらく、マルチスレッド（MT）アプリケーションを書くための最も良い方法です。ZeroMQのソケットは、従来のソケットに慣れていると多少の調整が必要ですが、ZeroMQのマルチスレッドは、MTアプリケーションの書き方について知っていることをすべて庭の山に投げ入れ、ガソリンをかけて燃え上がらせてくれます。燃やすに値する本は稀ですが、並行プログラミングに関するほとんどの本がそうです。

まったく完璧なMTプログラムを作るには（文字通りの意味で）、**ミューテックスもロックも、ZeroMQソケットで送られるメッセージ以外のいかなる形態のスレッド間通信も必要ない**。

完璧なMTプログラム」とは、書きやすく理解しやすいコード、どんなプログラミング言語でも、どんなオペレーティングシステムでも同じ設計アプローチで動作するコード、待機状態や収穫減のポイントがなく、CPUの数に関係なくスケールするコードを意味します。

もしあなたが、ロックやセマフォ、クリティカルセクションなどを使って、MTコードを高速に動作させるためのトリックを何年もかけて学んだとしたら、それがすべて無駄だったと気づいたとき、うんざりすることでしょう。30年以上にわたる並行プログラミングから学んだ教訓があるとすれば、それは以下の通りです： *状態を共有しないこと」です。これは、2人の酔っぱらいがビールを分け合おうとしているようなものです。仲良しであろうと関係ない。遅かれ早かれ、喧嘩になる。そして、テーブルに酔っぱらいが増えれば増えるほど、ビールを巡って喧嘩になる。MTのアプリケーションの悲劇的な大部分は、酔っ払ったバーの喧嘩のように見えるのです。

古典的な共有状態のMTコードを書くときに戦わなければならない奇妙な問題のリストは、それがストレスやリスクに直結しないのであれば、笑い話にしかなりません。バグだらけのコードで世界一の経験を持つある大企業が、「あなたのマルチスレッドコードで起こりうる11の問題」のリストを発表した。そこには、同期を忘れた、粒度が正しくない、読み書きの引き裂き、ロックフリーの並び替え、ロックコンボイ、2ステップダンス、優先順位逆転が取り上げられている。

そう、私たちは11の問題ではなく、7つの問題を数えたのです。しかし、それは重要なことではありません。重要なのは、電力網や株式市場を動かすコードが、忙しい木曜日の午後3時に2ステップのロックコンボイを受け始めることを本当に望むかどうかということだ。その用語が実際に何を意味するかなんて、誰が気にするでしょうか。これは、私たちをプログラミングに向かわせ、これまで以上に複雑な副作用と戦うために、これまで以上に複雑なハッキングを行うようにしたのではありません。

広く使われているモデルの中には、産業全体の基礎となっているにもかかわらず、根本的に壊れているものがあり、共有状態同時実行はその1つです。無制限に拡張したいコードは、インターネットのようにメッセージを送り、壊れたプログラミング・モデルに対する共通の軽蔑以外は何も共有しないのです。

ZeroMQで幸せなマルチスレッドコードを書くためには、いくつかのルールに従う必要があります：

* データをそのスレッド内で私的に分離し、複数のスレッドでデータを共有することはありません。データをスレッド内で私的に分離し、複数のスレッドでデータを共有することはありません。これに対する唯一の例外はZeroMQコンテキストで、これはスレッドセーフです。

* ミューテックス、クリティカルセクション、セマフォなどの古典的な並行性メカニズムには手を出さないことです。これらは、ZeroMQアプリケーションではアンチパターンです。

* プロセスの開始時に1つのZeroMQコンテキストを作成し、<tt>inproc</tt>ソケットを介して接続したいすべてのスレッドにそれを渡します。

* アプリケーション内の構造を作成するために*付属*スレッドを使用し、<tt>inproc</tt>上でPAIRソケットを使用してこれらの親スレッドに接続します。パターンは、親ソケットをバインドし、そのソケットを接続する子スレッドを作成することです。

* 独立したタスクをシミュレートするために、独自のコンテキストを持つ *detached* スレッドを使用します。これらを<tt>tcp</tt>で接続します。後で、コードを大きく変えることなく、これらを独立したプロセスに移動させることができます。

* スレッド間のすべてのやり取りはZeroMQメッセージとして行われ、多かれ少なかれ正式に定義することができます。

* スレッド間でZeroMQソケットを共有しないでください。ZeroMQソケットはスレッドセーフではありません。技術的には、あるスレッドから別のスレッドにソケットを移行することは可能ですが、それにはスキルが必要です。スレッド間でソケットを共有することがリモートで正気である唯一の場所は、ソケット上でガベージコレクションのようなマジックを行う必要がある言語バインディングの場合です。

例えば、あるアプリケーションで複数のプロキシを起動する必要がある場合、それぞれを独自のスレッドで実行することになります。プロキシのフロントエンドとバックエンドのソケットを一つのスレッドで 作成し、そのソケットを別のスレッドでプロキシに渡すというミスを犯しがちです。これは、最初はうまくいくように見えるかもしれませんが、実際の使用ではランダムに失敗します。覚えておいてください： *ソケットを作成したスレッド以外では、ソケットを使用したり閉じたりしないでください。

これらのルールに従えば、非常に簡単にエレガントなマルチスレッド・アプリケーションを構築でき、必要に応じてスレッドを別プロセスに分割することもできます。このルールに従えば、非常に簡単にエレガントなマルチスレッド・アプリケーションを構築でき、必要に応じてスレッドを別のプロセスに分割することも可能です。

ZeroMQは、仮想の「グリーン」スレッドではなく、OSのネイティブスレッドを使用します。この利点は、新しいスレッドAPIを学ぶ必要がなく、ZeroMQのスレッドがオペレーティングシステムにきれいにマッピングされることです。IntelのThreadCheckerのような標準的なツールを使用して、アプリケーションが何をしているかを確認することができます。デメリットは、ネイティブのスレッドAPIが必ずしもポータブルではないことと、膨大な数のスレッド（数千個）がある場合、一部のオペレーティングシステムがストレスを受けることです。

では、実際にどのように動作するか見てみましょう。古いHello Worldサーバーをもっと高性能なものに変えてみます。元のサーバーはシングルスレッドで動作していました。リクエストあたりの作業量が少なければ、それでいいのです。1つのØMQスレッドがCPUコアでフル回転し、待ち時間もなく、非常に多くの仕事をこなすことができます。しかし、現実的なサーバーは、リクエストごとに自明でない仕事をしなければならない。10,000のクライアントが一斉にサーバーにアクセスすると、1つのコアでは十分でないかもしれません。そこで現実的なサーバーは、複数のワーカースレッドを起動します。そして、できるだけ早くリクエストを受け付け、それをワーカースレッドに振り分けます。ワーカースレッドは仕事をこなし、最終的に返事を送り返す。

もちろん、プロキシブローカーや外部のワーカープロセスを使っても良いのですが、16個のプロセスでそれぞれ1コアを消費するよりも、16個のコアを消費する1つのプロセスを起動する方が簡単な場合が多いです。さらに、ワーカーをスレッドとして実行することで、ネットワークホップ、レイテンシ、ネットワークトラフィックをカットすることができます。

MT版のHello Worldサービスは、基本的にブローカーとワーカーを1つのプロセスに集約しています：

{{< examples name="mtserver" title="Multithreaded service" >}}

{{< textdiagram name="fig20.png" figno="20" title="Multithreaded Server" >}}
               #------------#
               |   Client   |
               +------------+
               |    REQ     |
               '---+--------'
                   |    ^
                   |    |
           "Hello" |    | "World"
.----------------= | -= | =----------------.
|                  v    |                  :
|              .--------+---.              |
|              |   ROUTER   |              |
|              +------------+              |
|              |   Server   |              |
|              +------------+              |
|              |   Queue    |              |
|              |   proxy    |              |
|              +------------+              |
|              |   DEALER   |              |
|              '------------'              |
|                    ^                     |
|                    |                     |
|        .-----------+-----------.         |
|        |           |           |         |
|        v           v           v         |
|    .--------.  .--------.  .--------.    |
|    |  REP   |  |  REP   |  |  REP   |    |
|    +--------+  +--------+  +--------+    |
|    | Worker |  | Worker |  | Worker |    |
|    #--------#  #--------#  #--------#    |
'------------------------------------------'
{{< /textdiagram >}}

すべてのコードは、もうあなたにとって認識できるはずです。どのように動作するのか：

* サーバーはワーカースレッドのセットを開始します。各ワーカースレッドは REP ソケットを作成し、このソケットでリクエストを処理します。ワーカースレッドはシングルスレッドサーバと同じです。唯一の違いは、トランスポート(<tt>tcp</tt>の代わりに<tt>inproc</tt>)と、バインドコネクションの方向です。

* サーバはクライアントと話すためにROUTERソケットを作成し、これを(<tt>tcp</tt>上の)外部インターフェイスにバインドします。

* サーバーはワーカーと話すためにDEALERソケットを作成し、これを内部インターフェース（<tt>inproc</tt>上）にバインドします。

* サーバーは2つのソケットを接続するプロキシを開始します。プロキシはすべてのクライアントから公平にリクエストを受け取り、それをワーカーに分配します。また、返信を元のソケットに戻すようにルーティングします。

スレッドの作成は、ほとんどのプログラミング言語では移植不可能であることに注意してください。POSIXのライブラリはpthreadsですが、Windowsでは別のAPIを使う必要があります。この例では、<tt>pthread_create</tt>呼び出しが、定義した<tt>worker_routine</tt>関数を実行する新しいスレッドを立ち上げます。これをポータブルなAPIにまとめる方法は、[第3章 高度なリクエスト・リプライのパターン](chapter3#advanced-request-reply)で見ていきます。

ここでは「作業」は1秒間の休止に過ぎません。他のノードと話すことも含めて、ワーカーで何でもできる。MTサーバーは、ØMQソケットとノードで構成されているようです。リクエストとリプライのチェーンが<tt>REQ-ROUTER-queue-DEALER-REP</tt>であることに注目してください。

## スレッド間のシグナリング（PAIRソケット）{#Signaling-Between-Threads-PAIR-Sockets}

ZeroMQでマルチスレッドアプリケーションを作り始めると、スレッドをどのように調整するかという問題に遭遇することになります。sleep "ステートメントを挿入したり、セマフォやミューテックスなどのマルチスレッド技術を使いたくなるかもしれませんが、**使うべき唯一のメカニズムはZeroMQメッセージ**なのです。酔っぱらいとビール瓶」の話を思い出してください。

準備ができたときに互いにシグナルを送る3つのスレッドを作ってみましょう。この例では、<tt>inproc</tt>トランスポート上でPAIRソケットを使用します：

{{< examples name="mtrelay" title="Multithreaded relay" >}}

{{< textdiagram name="fig21.png" figno="21" title="The Relay Race" >}}
#------------#
|   Step 1   |
+------------+
|    PAIR    |
'-----+------'
      |
      | Ready!
      |
      v
.------------.
|    PAIR    |
+------------+
|   Step 2   |
+------------+
|    PAIR    |
'-----+------'
      |
      | Ready!
      |
      v
.------------.
|    PAIR    |
+------------+
|   Step 3   |
#------------#
{{< /textdiagram >}}


ZeroMQでマルチスレッド化する場合の定番パターンです：

1. 2つのスレッドが<tt>inproc</tt>で、共有コンテキストを使用して通信します。
1. 親スレッドは1つのソケットを作成し、それを<tt>inproc:@<*>@</tt>エンドポイントにバインドし、*then//子スレッドを起動しコンテキストを渡します。
1. 子スレッドは2つ目のソケットを作成し、<tt>inproc:@<*>@</tt>エンドポイントに接続し、*then//親スレッドに準備ができたことを通知します。

このパターンを使用するマルチスレッド コードは、プロセスまでスケーラブルではないことに注意してください。<tt>inproc</tt> とソケット ペアを使用する場合、緊密に結合したアプリケーション、つまりスレッドが構造的に相互依存しているアプリケーションを構築していることになります。低レイテンシーが本当に重要である場合に、この方法を使用します。もう 1 つのデザイン パターンは、スレッドが独自のコンテキストを持ち、<tt>ipc</tt> または <tt>tcp</tt> で通信する、疎結合アプリケーションです。疎結合のスレッドは、簡単に別のプロセスに分割することができます。

今回は、PAIRソケットを使った例を紹介します。なぜPAIRを使うのか？他のソケットの組み合わせもうまくいくように見えるかもしれませんが、それらはすべて、シグナリングを妨害する可能性のある副作用を有しています：

* 送信側にはPUSH、受信側にはPULLを使用することができます。これは単純でうまくいくように見えますが、PUSHは利用可能なすべてのレシーバーにメッセージを配布することを忘れないでください。もしあなたが誤って2つの受信機を起動した場合(例えば、すでに1つの受信機を起動していて、2つ目を起動した場合)、あなたの信号の半分を「失う」ことになります。PAIRは、複数の接続を拒否する利点があります；ペアは*排他的*です。

* 送信側にはDEALER、受信側にはROUTERを使用することができます。しかし、ROUTERはメッセージを「エンベロープ」で包むので、ゼロサイズの信号がマルチパートのメッセージに変わってしまいます。データを気にせず、何でも有効な信号として扱い、ソケットから複数回読み込まないのであれば、それは問題ではありません。しかし、もし本当のデータを送ろうと思ったら、突然ROUTERが「間違った」メッセージを提供していることに気づくでしょう。DEALERもまた、PUSHと同じリスクを与えながら、送信メッセージを配信します。

* 送信者にPUB、受信者にSUBを使用することができます。PUBはPUSHやDEALERのように配信されることはありません。しかし、サブスクライバーに空のサブスクリプションを設定する必要があり、これは煩わしい。

これらの理由から、PAIRはスレッドのペア間のコーディネーションに最適な選択となります。

## ノードコーディネート {#Node-Coordination}

ネットワーク上のノードの集合を調整したい場合、PAIRソケットはもううまくいきません。これは、スレッドとノードの戦略が異なる数少ない分野の1つです。スレッドが静的であるのに対して、ノードは行ったり来たりするのが一般的です。PAIRソケットは、リモートノードが消えて戻ってきても、自動的に再接続するわけではありません。

{{< textdiagram name="fig22.png" figno="22" title="Pub-Sub Synchronization" >}}
#------------#
| Publisher  |
+-----+------+
| PUB | REP  |
'--+--+----+-'
   |    ^  |
(3)| (1)|  |(2)
   |    |  |
   v    |  v
.-----+-+----.
| SUB | REQ  |
+-----+------+
| Subscriber |
#------------#
{{< /textdiagram >}}

スレッドとノードの2つ目の大きな違いは、一般的にスレッドの数は決まっているが、ノードの数はより可変であるということです。先ほどのシナリオの1つ（天気予報サーバーとクライアント）を例に、ノード調整を使用して、サブスクライバーが起動時にデータを失わないようにしましょう。

このアプリケーションはこのように動作します：

* パブリッシャーは、予想される購読者数をあらかじめ知っている。パブリッシャーは事前に期待する購読者数を知っている。これはどこからか得たマジックナンバーだ。

* パブリッシャーが起動し、すべてのサブスクライバーが接続するのを待ちます。これはノードの調整部分である。各サブスクライバーはサブスクライブを行い、別のソケットを介してパブリッシャーに 準備が整ったことを伝える。

* パブリッシャーが全てのサブスクライバーを接続すると、データの公開を開始します。

この場合、REQ-REPのソケットフローを使って、サブスクライバーとパブリッシャーを同期させることになります。以下がパブリッシャーです：

{{< examples name="syncpub" title="Synchronized publisher" >}}

そして、こちらがサブスクライバーです：

{{< examples name="syncsub" title="Synchronized subscriber" >}}

このBashシェルスクリプトは10人のサブスクライバーを起動し、次にパブリッシャーを起動します：

```
echo "Starting subscribers..."
for ((a=0; a<10; a++)); do
    syncsub &
done
echo "Starting publisher..."
syncpub
```

このように、満足のいく出力が得られます：

```
Starting subscribers...
Starting publisher...
Received 1000000 updates
Received 1000000 updates
...
Received 1000000 updates
Received 1000000 updates
```

REQ/REPダイアログが完了するまでにSUBコネクトが終了していることを想定することはできません。<tt>inproc</tt>以外のトランスポートを使用している場合、アウトバウンド接続がいかなる順序でも終了する保証はありません。そのため、この例では、サブスクライブしてから REQ/REP 同期を送信するまでの間に 1 秒のブルートフォース スリープを実行します。

より堅牢なモデルは次のとおりです：

* PublisherはPUBソケットを開き、「Hello」メッセージ（データではない）の送信を開始します。
* サブスクライバーはSUBソケットに接続し、Helloメッセージを受信すると、REQ/REPソケットペアを介してパブリッシャーに通知します。
* パブリッシャーが必要な確認を全て行った後、実際のデータを送信し始めます。

## ゼロコピー {#Zero-Copy}

ZeroMQのメッセージAPIでは、データをコピーすることなく、アプリケーションのバッファから直接メッセージを送受信することができます。これを*ゼロコピー*と呼び、一部のアプリケーションでパフォーマンスを向上させることができます。

ゼロコピーの使用は、大きなメモリブロック（数千バイト）を高い頻度で送信するような特定のケースで考える必要があります。短いメッセージや低いメッセージレートでは、ゼロコピーの使用はコードをより複雑にし、測定可能な利益をもたらさないでしょう。他の最適化と同様に、役に立つと分かっている場合に使用し、その前後で*測定*してください。

ゼロコピーを行うには、<tt>[zmq_msg_init_data()](http://api.zeromq.org/master:zmq_msg_init_data)</tt>を使って、<tt>malloc()</tt>やその他のアロケータですでに割り当てられたデータブロックを参照するメッセージを作成し、<tt>[zmq_msg_send()](http://api.zeromq.org/master:zmq_msg_send)</tt>にそれを渡します。メッセージを作成するときに、ZeroMQがメッセージの送信を終了したときにデータブロックを解放するために呼び出す関数も渡します。<tt>buffer</tt>がヒープ上に割り当てられた1,000バイトのブロックであると仮定した場合の、最も単純な例です：

{{< fragment name="zerocopy" >}}
void my_free (void *data, void *hint) {
    free (data);
}
//  Send message from buffer, which we allocate and ZeroMQ will free for us
zmq_msg_t message;
zmq_msg_init_data (&message, buffer, 1000, my_free, NULL);
zmq_msg_send (&message, socket, 0);
{{< /fragment >}}

メッセージを送信した後に <tt>[zmq_msg_close()](http://api.zeromq.org/master:zmq_msg_close)</tt> を呼び出さないことに注意してください--<tt>libzmq</tt> は実際にメッセージを送信し終わったときに自動的にこれを実行します。

受信時にゼロコピーを行う方法はありません： ZeroMQは、希望する限り保存できるバッファを提供しますが、アプリケーションバッファに直接データを書き込むことはありません。

書き込みでは、ZeroMQのマルチパートメッセージがゼロコピーとうまく連携して動作します。従来のメッセージングでは、異なるバッファを送信可能な1つのバッファにまとめてマーシャルする必要があります。つまり、データをコピーすることになります。ZeroMQでは、異なるソースから来た複数のバッファを個別のメッセージフレームとして送信することができます。各フィールドを長さで区切ったフレームとして送信します。アプリケーションからは、一連の送信と受信の呼び出しのように見えます。しかし、内部的には、複数の部分がネットワークに書き込まれ、単一のシステムコールで読み返されるため、非常に効率的です。

## パブサブメッセージエンベロープ {#Pub-Sub-Message-Envelopes}

Pub-Subパターンでは、キーを別のメッセージフレームに分割して、*envelope*と呼ぶことができます。pub-sub エンベロープを使いたい場合は、自分で作ってください。これはオプションであり、以前のpub-subの例ではこのようなことはしませんでした。pub-sub envelopeを使うと、単純なケースでは少し手間がかかりますが、特にキーとデータが当然別物であるような実際のケースでは、その方がすっきりします。

{{< textdiagram name="fig23.png" figno="23" title="Pub-Sub Envelope with Separate Key" >}}
          #--------#
Frame 1   | Key    |   Message envelope
          +--------+
Frame 2   | Data   |   Actual message body
          #--------#
{{< /textdiagram >}}

サブスクリプションは、プレフィックスマッチを行います。つまり、「XYZで始まるすべてのメッセージ」を探します。プレフィックスマッチが誤ってデータと一致しないように、データからキーをどのように区切るか、というのが明白な問題です。最良の答えは、エンベロープを使うことです。なぜなら、マッチングがフレーム境界を越えないからです。以下は、pub-subエンベロープがコード上でどのように見えるかの最小限の例です。このパブリッシャーは2種類のメッセージ、A と B を送信します。

エンベロープはメッセージのタイプを保持します：

{{< examples name="psenvpub" title="Pub-Sub envelope publisher" >}}

加入者はタイプBのメッセージだけを望んでいます：

{{< examples name="psenvsub" title="Pub-Sub envelope subscriber" >}}

2つのプログラムを実行すると、サブスクライバーはこのように表示されるはずです：

```
[B] We would like to see this
[B] We would like to see this
[B] We would like to see this
...
```

この例は、サブスクリプションフィルタがマルチパートメッセージ全体(キーとデータ)を拒否または受け入れることを示します。あなたはマルチパートメッセージの一部を受け取ることはありません。もしあなたが複数のパブリッシャーを購読していて、そのアドレスを知っていて、別のソケットでデータを送りたい場合(これが典型的な使用例です)、3パートメッセージを作成します。

{{< textdiagram name="fig24.png" figno="24" title="Pub-Sub Envelope with Sender Address" >}}
          #---------#
Frame 1   | Key     |   Subscription key
          +---------+
Frame 2   | Address |   Address of publisher
          +---------+
Frame 3   | Data    |   Actual message body
          #---------#
{{< /textdiagram >}}

## ハイウォーターマーク {#High-Water-Marks}

プロセスからプロセスへメッセージを高速に送信できるようになると、メモリが貴重な資源であり、些細なことで埋まってしまうことにすぐに気がつく。プロセスのどこかで数秒の遅れが生じると、問題を理解して予防策を講じない限り、サーバーを爆発させるほどのバックログになりかねません。

例えば、AというプロセスがBというプロセスに高頻度でメッセージを送り、Bがそれを処理しているとします。突然Bが非常に忙しくなり（ガベージコレクション、CPUオーバーロードなど）、短時間の間メッセージを処理できなくなる。ガベージコレクションが激しい場合は数秒、もっと深刻な問題がある場合はもっと長くなる可能性があります。プロセスAが必死に送信しようとしているメッセージはどうなるのでしょうか？あるものはBのネットワークバッファに置かれるでしょう。あるものは、イーサネットワイヤー自体に置かれる。あるものは、Aのネットワーク・バッファに置かれる。そして残りは、Aの背後にあるアプリケーションが送信するのと同じくらい急速に、Aのメモリに蓄積されます。もしあなたが何らかの予防策を講じなければ、Aは簡単にメモリ不足に陥ってクラッシュしてしまう。

メッセージブローカーの一貫した、古典的な問題である。さらに痛いのは、表面的にはBのせいであり、Bは通常、Aがコントロールできないユーザーが書いたアプリケーションであることです。

どうすればいいのでしょうか？ひとつは、問題を上流に渡すことです。Aはどこか別のところからメッセージを受け取っているのです。だから、そのプロセスに "やめろ！"と言ってください。といった具合に。これを*フロー制御*と呼びます。もっともらしく聞こえるが、ツイッターを発信している場合はどうだろう。Bが行動を起こすまでの間、全世界にツイートを停止するように言うのでしょうか？

フロー制御はある場合には有効ですが、そうでない場合もあります。トランスポート層は、地下鉄が大企業に「あと30分、従業員を働かせてください」と言うのと同じように、アプリケーション層に「止めろ」と言うことはできない。私は忙しいのです」。メッセージングの答えは、バッファのサイズに制限を設けること、そして、その制限に達したときに、何らかの賢明な行動をとることです。場合によっては（地下鉄のシステムではありませんが）、メッセージを捨てることが答えになります。また、「待つ」ことが最善の策である場合もあります。

ZeroMQでは、HWM（high-water mark）という概念を使用して、内部パイプの容量を定義しています。ソケットから出る、またはソケットに入る各接続は、独自のパイプを持ち、ソケットの種類に応じて送信、または受信のためのHWMを持ちます。一部のソケット(PUB, PUSH)は、送信バッファのみを持つ。いくつかのソケット(SUB, PULL, REQ, REP)は、受信バッファのみを持つものもある。一部のソケット（DEALER、ROUTER、PAIR）は、送信バッファと受信バッファの両方を備えています。

ZeroMQ v2.xでは、HWMはデフォルトで無限大でした。これは簡単ですが、大量のパブリッシャーにとっては致命的な問題でもありました。ZeroMQ v3.xでは、デフォルトで1,000に設定されており、より賢明になっています。ZeroMQ v2.xをまだ使用している場合は、ソケットに常にHWMを設定する必要があります。ZeroMQ v3.xと同じ1,000か、メッセージサイズと予想されるサブスクライバーのパフォーマンスを考慮した別の数値にする必要があります。

ソケットがHWMに達すると、ソケットタイプに応じて、ブロックするかデータをドロップします。PUBとROUTERソケットはHWMに達するとデータをドロップし、他のソケットタイプはブロックします。<tt>inproc</tt> トランスポートでは、送信者と受信者が同じバッファを共有するため、実際の HWM は双方で設定された HWM の合計となります。

最後に、HWM は正確ではありません。デフォルトでは 1,000 メッセージまで取得できますが、 <tt>libzmq</tt> がキューを実装する方法によって、実際のバッファサイズはもっと小さい (半分程度) かもしれません。

## Missing Message Problem Solver {#Missing-Message-Problem-Solver}

ZeroMQでアプリケーションを構築していると、この問題に何度も遭遇することになります。この問題の最も一般的な原因を説明する図をまとめました。

{{< textdiagram name="fig25.png" figno="25" title="Missing Message Problem Solver" >}}
.---------------.        .---------------.        .----------------.
| So you're not |        | Do you set a  |        | On SUB sockets |
| getting every |    .-->| subscription  +------->| you have to    |
| message?      |    |   | for messages? | No     | subscribe to   |
'--------+------'    |   '-------+-------'        | get messages   |
         | Yes       |           | Yes            '----------------'
         v           |           v
.----------------.   |   .----------------.        .---------------.
| Are you losing |   |   | Do you start   |        | Start all SUB |
| messages in a  +---'   | the SUB socket +------->| sockets first |
| SUB socket?    | Yes   | after the PUB? | Yes    | then the PUB  |
'--------+-------'       '--------+-------'        '---------------'
         | No                     | No
         v                        v             .------------------.
.---------------.       .-----------------.     | Send and recv in |
| Are you using | Yes   | See explanation |     | a loop and check |
| REQ and REP?  +---.   | of slow joiners |  .->| return codes.    |
'--------+------'   |   | in the text     |  |  | With REP, recv   |
         | No       |   '-----------------'  |  | and send         |
         v          '------------------------'  '------------------'
.-----------------.      .----------------.
|  Are you using  +--.   | First PULL can |       .---------------.
|  PUSH sockets?  |  '-->| grab many msgs |       | Use the load  |
'--------+--------' Yes  | while others   +--.    | balancing     |
         | No            | are still busy |  '--->| pattern and   |
         v               | connecting     |       | ROUTER/DEALER |
.-----------------.      '----------------'       | sockets       |
|  Do you check   | No                            '---------------'
| return codes on +---.   .----------------.
|  all methods?   |   |   | Check each 0MQ |   .------------------.
'--------+--------'   '-->| method call    |   | Use sockets only |
         | Yes            '----------------'   | in their owning  |
         v                                     | threads unless   |
.-----------------.      .---.      .--------->| you know about   |
| Are you using a |      |   |      |          | memory barriers  |
| socket in more  +------'   |      |          '------------------'
| than 1 thread?  | Yes      '------'
'--------+--------'                               .---------------.
         | No             .----------------.      | To use inproc |
         v                | Do you call    |      | your sockets  |
.---------------.   .---->| zmq_ctx_new    +----->| must be in    |
| Are you using |   |     | twice or more? | Yes  | the same 0MQ  |
| the inproc:// +---'     '--------+-------'      | context       |
| transport?    | Yes              | No           '---------------'
'--------+------'                  v
         | No             .-----------------.
         v                | Check that you  |
.-----------------.       | bind before you |
|  Are you using  | Yes   | connect         |
| ROUTER sockets? +---.   '-----------------'
'--------+--------'   |
         | No         |   .----------------.     .------------.
         v            |   | Check that the |     | If you use |
.----------------.    |   | reply address  |     | identities |
| Make a minimal |    '-->| is valid. 0MQ  +---->| set them   |
| test case, ask |        | drops messages |     | before you |
| on IRC channel |        | it can't route |     | connect    |
'----------------'        '----------------'     '------------'
{{< /textdiagram >}}

以下は、このグラフィックに書かれていることを要約したものです：

* SUBソケットでは、<tt>[zmq_setsockopt()](http://api.zeromq.org/master:zmq_setsockopt)</tt>と <tt>ZMQ_SUBSCRIBE</tt> を使って購読を設定しないと、メッセージを受け取れないでしょう。メッセージはプレフィックスで購読するため、"" (空の購読) を購読すると、すべてを取得することができます。

* PUB ソケットがデータを送信し始めた後に SUB ソケットを起動（PUB ソケットに接続）すると、接続前に発行されたものが失われます。もしこれが問題なら、SUBソケットが最初に起動し、その後PUBソケットがパブリッシングを開始するようにアーキテクチャを設定してください。

* SUBとPUBのソケットを同期させても、メッセージが失われることがあります。これは、接続が実際に作成されるまで内部キューが作成されないことに起因しています。SUBソケットがバインドし、PUBソケットが接続するように、バインド/コネクトの方向 を切り替えることができれば、より期待通りに動作するようになるかもしれません。

* REPとREQソケットを使用していて、同期送信/RECV/送信/RECVの順序に固執していない場合、ZeroMQはエラーを報告しますが、無視することができます。そうすると、メッセージを失っているように見えるでしょう。REQまたはREPを使用する場合は、送信/再送の順序を守り、実際のコードでは常に、ZeroMQの呼び出しでエラーがないかどうかをチェックします。

* PUSHソケットを使用している場合、最初に接続するPULLソケットがメッセージの不公平なシェアを獲得することがわかります。メッセージの正確な回転は、すべてのPULLソケットが正常に接続されたときにのみ発生し、それには数ミリ秒かかることがあります。PUSH/PULLの代わりに、低いデータレートでは、ROUTER/DEALERとロードバランシングパターンを使用することを検討してください。

* スレッド間でソケットを共有する場合は、しないでください。スレッド間でソケットを共有する場合、それはランダムな奇妙さとクラッシュにつながるでしょう。

<tt>inproc</tt> を使用している場合、両方のソケットが同じコンテキストにあることを確認します。そうでないと、接続側が実際に失敗します。また、最初にバインドしてから接続するようにしてください。<tt>inproc</tt> は <tt>tcp</tt> のような切断されたトランスポートではありません。

* ROUTER ソケットを使用している場合、不正な ID フレームを送信する (または ID フレームを送信するのを忘れる) ことで、誤ってメッセージを失うことは非常に簡単です。一般的に ROUTER ソケットの <tt>ZMQ_ROUTER_MANDATORY</tt> オプションを設定するのは良い考えですが、すべての送信コールでリターンコードをチェックするようにしてください。

* 最後に、何が間違っているのかどうしてもわからない場合は、問題を再現する*最小限の*テストケースを作成し、ZeroMQコミュニティから助けを求めてください。

