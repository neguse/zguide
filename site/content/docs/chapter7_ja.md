---
weight: 7
title: '7. ZeroMQを使った高度なアーキテクチャ'
---

# 第7章 ZeroMQを使った高度なアーキテクチャ {#advanced-architecture}

ZeroMQを大規模に使用することの効果の1つは、分散アーキテクチャを以前よりもはるかに速く構築できるため、ソフトウェアエンジニアリングのプロセスの限界がより目に見えるようになることです。スローモーションでのミスは、しばしば見えにくくなる（というより、合理的に片付けられやすくなる）。

エンジニアのグループにZeroMQを教えるときの私の経験では、ZeroMQの仕組みを説明するだけで、彼らが成功する製品を作り始めることを期待するだけでは、ほとんど十分ではありません。摩擦をなくす技術と同様に、ZeroMQは大きな失敗への扉を開くことになります。ZeroMQが分散ソフトウェア開発のACMEロケット推進靴だとしたら、私たちの多くはWile E. Coyoteのように、ことわざの砂漠の崖に全速力でぶつかっているようなものです。

[第6章 ZeroMQコミュニティ](chapter6#the-community)で、ZeroMQ自身が変更のための正式なプロセスを使っていることを確認しました。何年もかけてこのプロセスを構築した理由の1つは、ライブラリ自体で起こる繰り返しの崖崩れを止めるためでした。

これは、スピードを落とすためでもあり、また、速く動くときに、読者の皆さんにとって重要なことですが、正しい方向へ進むことを保証するためでもあります。ソフトウェアシステムで最も希少な特性は何か、正しく理解するのが最も困難なことは何か、その欠如がプロジェクトの大半を遅かれ早かれ死に至らしめる原因は何か、これは私の定番インタビュー謎かけです。その答えは、コードの品質でも、資金調達でも、パフォーマンスでも、あるいは（近い答えではありますが）人気でもありません。答えは「正確さ」です。

精度は課題の半分であり、どんなエンジニアリング作業にも当てはまります。残りの半分は、分散コンピューティングそのものであり、アーキテクチャを作るなら解決しなければならない問題が山積しています。データのエンコードとデコード、クライアントとサーバーを接続するプロトコルの定義、攻撃者に対するプロトコルの安全性、そして堅牢なスタックの作成が必要です。非同期メッセージングを正しく理解するのは難しいことです。

本章では、これらの課題に取り組み、ソフトウェアの設計・構築方法の基本的な見直しから始まり、大規模なファイル配布のための分散アプリケーションの完全な形成例で終わります。

本章では、以下のような重要なトピックを取り上げます：

* アイデアからプロトタイプを安全に作成する方法（MOPEDパターン）。
* ZeroMQメッセージとしてデータをシリアライズするさまざまな方法
* バイナリー・シリアライゼーション・コーデックのコードジェネレート方法
* GSLツールを使用してカスタムコードジェネレータを構築する方法
* プロトコル仕様の書き方とライセンス取得方法
* ZeroMQで高速な再起動可能なファイル転送を構築する方法
* 非ブロック転送にクレジットベースのフロー制御を使用する方法
* プロトコルのサーバとクライアントをステートマシンとして構築する方法
* ZeroMQ 上で安全なプロトコルを作成する方法
* 大規模ファイル公開システム(FileMQ)

## エラスティックデザインのためのメッセージ指向パターン {#Message-Oriented-Pattern-for-Elastic-Design}

ZeroMQアーキテクチャのソフトウェア工学パターンである「Message-Oriented Pattern for Elastic Design（MOPED）」を紹介します。「MOPED」か「BIKE」、Backronym-Induced Kinetic Effectのどちらかでしたね。これは「BICICLE」の略で、「Backronym-Inflated See if I Care Less Effect」のことです。人生において、人は最も恥ずかしくない選択肢を選ぶことを学びます。

本書を熟読された方は、すでにMOPEDの動きをご覧になられていることでしょう。[第4章 信頼できるリクエスト・リプライパターン](chapter4#reliable-request-reply)のMajordomoの開発は、ほぼ完璧なケースです。しかし、かわいい名前は百聞は一見にしかずです。

MOPEDの目標は、新しい分散アプリケーションの大まかなユースケースを、1週間以内に「Hello World」からあらゆる言語で完全に動作するプロトタイプにするためのプロセスを定義することです。

MOPEDを使えば、失敗のリスクを最小限に抑えながら、ZeroMQのアーキテクチャを一から作り上げるというよりも、育てていくことができます。実装ではなく契約に焦点を当てることで、早すぎる最適化のリスクを回避します。超短期間のテストベースのサイクルで設計プロセスを推進することで、追加する前に、今あるものが機能することをより確実に確認することができます。

これを5つのステップに分けることができます：

* ステップ1：ZeroMQのセマンティクスを内部化する。
* ステップ2: 大まかなアーキテクチャを描く。
* ステップ3：コントラクトを決定する。
* ステップ4：最小限のエンドツーエンド・ソリューションを作る。
* ステップ5：1つの問題を解決し、それを繰り返す。

### ステップ1：セマンティクスの内面化 {#Step-Internalize-the-Semantics}

ZeroMQの「言語」、つまりソケットパターンとその動作方法を学び、消化する必要があります。言語を学ぶ唯一の方法は、それを使うことです。この投資を避ける方法はありません。寝ている間に再生できるテープや、魔法のように賢くなるチップを差し込むこともできません。この本を最初から読み、好きな言語でコード例を読み、何が起こっているのかを理解し、（最も重要なのは）自分でいくつかの例を書き、そしてそれを捨てることです。

ある時点で、脳内でカチカチと音がするのを感じるはずです。もしかしたら、ZeroMQの小さなタスクがあなたを生きたまま食べようと走り回る、チリに誘発された奇妙な夢を見るかもしれません。そして、"ああ、そういうことだったのか！"と思うことでしょう。私たちがきちんと仕事をしたなら、2～3日かかるはずです。どんなに時間がかかっても、ZeroMQのソケットとパターンの観点から考え始めるまでは、ステップ2の準備はできていないのです。

### ステップ2：大まかなアーキテクチャを描く {#Step-Draw-a-Rough-Architecture}

私の経験上、アーキテクチャの核となる部分を描けるようにすることは必須です。自分の考えていることを他の人が理解しやすくなりますし、自分でも考えやすくなります。良いアーキテクチャを設計するためには、ホワイトボードを使って、同僚に自分のアイデアを説明すること以上に良い方法はありません。

正しく作る必要はありませんし、完成させる必要もありません。必要なのは、アーキテクチャを意味のある断片に分割することです。ソフトウェアアーキテクチャの良いところは（橋の建設と比較して）、レイヤーを分離しておけば、レイヤー全体を安価に交換できることです。

まず、解決しようとする核となる問題を選ぶことから始めましょう。その問題にとって不可欠でないものは無視する。問題は、峡谷を渡るロープのように、エンドツーエンドの問題であるべきです。

例えば、あるクライアントから「ZeroMQでスーパーコンピューティングクラスターを作ってほしい」という依頼があった。クライアントは仕事の束を作り、それをブローカーに送り、ブローカーはそれをワーカー（高速グラフィックプロセッサ上で動作）に分配し、結果を回収してクライアントに返します。

峡谷を渡るロープは、1人のクライアントが1人のブローカーと話し、1人のワーカーと話すものです。クライアント、ブローカー、ワーカーの3つのボックスを描きます。ボックスからボックスへ、リクエストが一方通行で流れ、レスポンスが戻ってくることを示す矢印を描きます。これは、以前の章で見た多くの図と同じです。

ミニマリストであれ。あなたのゴールは、*本物の*アーキテクチャを定義することではなく、あなたのプロセスを起動させるために峡谷にロープを投げ入れることです。例えば、複数のワーカーを追加する、クライアントとワーカーのAPIを追加する、失敗を処理するなど、時間をかけてアーキテクチャをより完全で現実的なものにしていくのです。

### ステップ3：契約を決める{#Step-Decide-on-the-Contracts}

良いソフトウェア・アーキテクチャは契約に依存し、それがより明確であればあるほど、物事はより良くスケールします。あなたは、物事がどのように起こるかを気にするのではなく、結果だけを気にするのです。もし私が電子メールを送るなら、契約が尊重される限り、それがどのように目的地に到着するかは気にしません。電子メールの契約は、数分以内に届くこと、誰も変更しないこと、そして紛失しないことです。

そして、うまく機能する大規模なシステムを構築するためには、実装の前に契約に焦点を当てる必要があります。当たり前のように聞こえるかもしれませんが、あまりにも多くの場合、人々はこのことを忘れたり無視したり、あるいは恥ずかしがって自分を押し付けないだけなのです。ZeroMQがこのことをきちんと行っていたと言えるならいいのですが、私たちのパブリックコントラクトは、何年もの間、顔に出るような主要な作品ではなく、二流の後付の作品でした。

では、分散システムにおけるコントラクトとは何でしょうか？私の経験では、契約には2つのタイプがあります：

* クライアントアプリケーションへのAPI。心理的要素を思い出してください。APIは、可能な限り絶対的に*シンプル*、*一貫性*、*なじみのある*ものである必要があります。そう、コードからAPIドキュメントを生成することは可能ですが、まずはそれを設計しなければなりませんし、APIを設計することはしばしば困難です。

* APIを設計するのは難しいことです。ロケットサイエンスのように聞こえますが、実は簡単なトリックで、ZeroMQが特に簡単にしているものなのです。実際、プロトコルはとてもシンプルに書くことができ、官僚主義も必要ないので、私はこれを "unprotocols "と呼んでいます。

あなたは、ほとんどが単なるプレースマーカーである最小限の契約を書きます。ほとんどのメッセージとほとんどのAPIメソッドは、欠落しているか、空になっているはずです。また、スループット、レイテンシー、信頼性などの観点から、既知の技術的要件を書き留めておくとよい。これらは、特定の作品を受け入れるか否かの基準となるものです。

### ステップ4：最小限のエンド・ツー・エンドのソリューションを書く {#Step-Write-a-Minimal-End-to-End-Solution}

目標は、全体的なアーキテクチャをできるだけ早くテストすることです。APIを呼び出すスケルトン・アプリケーションと、すべてのプロトコルの両側を実装するスケルトン・スタックを作成します。エンドツーエンドで動作する "Hello World "をできるだけ早く手に入れたいのです。コードを書きながらテストできるようにすることで、思い込みの破綻や避けられないエラーを排除できるようにしたいものです。テストスイートを書くのに6カ月もかけてはいけません！その代わりに、まだ仮説に過ぎないAPIを使う最小限のベアボーン・アプリケーションを作りましょう。

APIを実装する人の立場になって設計すれば、パフォーマンスや機能、オプションなどを考え始めるでしょう。そうすると、必要以上に複雑で、不規則で、驚くようなAPIになってしまいます。しかし、これがコツです（安直なもので、日本では大流行しました）。実際にAPIを使うアプリを書かなければならない人の帽子をかぶってAPIを設計すれば、その怠惰と恐怖をすべて利用することができます。

プロトコルをWikiや共有ドキュメントに書き出し、あまり詳しくなくてもすべてのコマンドを明確に説明できるようにする。実際の機能はすべて削ぎ落とす。なぜなら、それは慣性を生み、物を動かすのを難しくするだけだからだ。重さはいつでも増やせます。正式なメッセージ構造の定義に労力を費やさないでください。ZeroMQのマルチパートフレームワークを使用して、可能な限りシンプルな方法で最小限のものを渡します。

私たちの目標は、回避可能な機能を持たず、最もシンプルなテストケースを動作させることです。やるべきことのリストから削れるものはすべて削るのです。同僚や上司のうめき声は無視すること。もう一度言いますが、機能を追加するのは比較的簡単なので、いつでもできます。しかし、全体の重量を最小限に抑えることを目指します。

### ステップ5：1つの問題を解決し、繰り返す {#Step-Solve-One-Problem-and-Repeat}

あなたは今、課題駆動型開発の幸せなサイクルの中にいて、機能を追加する代わりに、具体的な問題を解決し始めることができます。課題を書いて、それぞれ明確な問題を述べ、解決策を提案する。APIを設計する際には、名前、一貫性、動作に関する標準を心に留めておくこと。これらを散文的に書き出すことで、正気を保つことができることが多い。

ここから、アーキテクチャとコードに加えるすべての変更は、テストケースを実行し、それが機能しないのを見て、変更を加え、それが機能するのを見て、証明することができます。

テストケースの拡張、APIの修正、プロトコルの更新、コードの拡張といった一連のサイクルを経て、問題を1つずつ解決し、個別にテストしていきます。1つのサイクルにかかる時間は10～30分程度で、ランダムな混乱によるスパイクはたまにあります。

## Unprotocols {#Unprotocols}

### ヤギのいないプロトコル {#Protocols-Without-The-Goats}

この人がプロトコルを考えるとき、この人は委員会が何年もかけて書いた巨大なドキュメントを思い浮かべる。IETF、W3C、ISO、Oasis、規制の捕捉、FRAND特許ライセンス紛争、そしてすぐに、ボリビア北部の山の中の素敵な小さな農場に引退することを思い浮かべます。

私は委員会には何の恨みもない。役立たずには、繁殖のリスクを最小限に抑えながら一生を終える場所が必要なのである。しかし、ほとんどの委員会プロトコルは、複雑（うまくいくもの）か、ゴミ（話題にしないもの）になる傾向があります。これにはいくつかの理由があります。1つは、危機に瀕しているお金の量です。お金がかかるということは、自分たちの偏見や思い込みを散文で表現したいと思う人が多いということです。しかし、2つ目は、構築するための優れた抽象的な要素がないことです。BEEPのような再利用可能なプロトコル抽象化機能を構築しようとした人はいたんだけど。しかし、そのほとんどは定着せず、定着したものもSOAPやXMPPのように複雑な側面があります。

数十年前、インターネットがまだ若く控えめだったころは、プロトコルは短くて甘いものでした。標準」ですらなく、「コメント要求」であったほど、控えめなものでした。1995年にiMatixを立ち上げて以来、私のような一般人が、委員会のオーバーヘッドなしに、小さくて正確なプロトコルを書く方法を見つけることが、私の目標の1つでした。

今、ZeroMQは、「ランダムなトランスポートでマルチパートメッセージを伝送する」という方法で、プロトコルの抽象化レイヤーを提供し、成功を収めているように見えます。ZeroMQはフレーム、コネクション、ルーティングを黙って扱うので、ZeroMQの上に完全なプロトコル仕様を書くのは驚くほど簡単で、[第4章 - 信頼できるリクエスト-リプライパターン](chapter4#reliable-request-reply) と [第5章 - 高度なパブ-サブパターン](chapter5#advanced-pub-sub) でその方法を紹介しています。

2007年の半ば頃、私はデジタル標準化機構を立ち上げ、小さな標準、プロトコル、仕様を作り出す新しいよりシンプルな方法を定義しました。私の弁護をすれば、それは静かな夏だったのです。当時、私は新しい仕様には[「説明するのに数分、設計するのに数時間、書くのに数日、証明するのに数週間、成熟するのに数ヶ月、そして置き換えるのに数年」](http://www.digistan.org/spec:1)かかるはずだと書きました。

2010年、私たちはこのような小さな仕様を*unprotocols*と呼ぶようになりました。ある人は、影のある国際組織による世界征服のための卑劣な計画と勘違いするかもしれませんが、実際には「ヤギのいないプロトコル」という意味でしかないのです。

### 契約は難しい {#Contracts-Are-Hard}

コントラクトを書くことは、おそらく大規模アーキテクチャの最も難しい部分である。プロトコルを使わないことで、不要な摩擦を可能な限り取り除くことができます。しかし、それでもなお、解決すべき問題は山積しています。良い契約（APIであれ、プロトコルであれ、賃貸契約であれ）は、シンプルで、曖昧さがなく、技術的に健全で、強制するのが簡単でなければならない。

どんな技術的スキルもそうですが、これは学び、実践しなければならないものです。には、一連の仕様があります。
[ZeroMQ RFCサイト](http://rfc.zeromq.org)に一連の仕様があります。読む価値がありますし、必要性を感じたときに自分の仕様の基礎として使うこともできます。

プロトコル作成者としての私の経験をまとめてみます：

* シンプルに始めて、ステップバイステップで仕様書を作成する。目の前にない問題を解決してはいけない。

* 非常に明確で一貫性のある言語を使用する。プロトコルはしばしばコマンドやフィールドに分解されるかもしれません。これらのエンティティには明確な短い名前を使用してください。

* 概念を発明しないようにしてください。既存の仕様からできる限りのものを再利用してください。聴衆にとって明白で明確な用語を使用すること。

* 緊急の必要性を証明できないものは作らない。仕様書は問題を解決するものであり、機能を提供するものではありません。あなたが特定した各問題に対して、最も単純なもっともらしい解決策を作りなさい。

* 各選択肢の技術的な結果を認識できるように、プロトコルを*構築しながら*実装してください。C言語のような難しい言語ではなく、Pythonのような簡単な言語を使用する。

* 仕様のテストは、他の人と一緒に行いましょう。仕様に関する最高のフィードバックは、あなたの頭の中にある仮定や知識なしに、他の誰かがそれを実装しようとするときです。

* 他の人のクライアントをあなたのサーバーに投げたり、その逆をしたりする、迅速かつ一貫したクロステストを行いなさい。

* 必要であれば、何度でもそれを捨ててやり直す用意がある。例えば、APIはそのままで、基礎となるプロトコルを変更できるように、アーキテクチャを重ねることによって、これを計画する。

* プログラミング言語やオペレーティングシステムに依存しない構成要素のみを使用する。

* 大きな問題を何層にも分けて解決し、各層を独立した仕様とする。モノリシックなプロトコルを作らないように注意する。各レイヤーがどれだけ再利用可能かを考える。異なるチームが各レイヤーでどのように競合する仕様を構築できるかを考える。

そして何よりも、*それを書き留める*ことです。コードは仕様書ではありません。書き込まれた仕様のポイントは、それがどんなに弱いものであっても、体系的に改善することができるということです。また、仕様を書き出すことで、コードでは見えない矛盾やグレーゾーンを発見することができます。

難しそうだと思われるかもしれませんが、あまり心配しないでください。ZeroMQを使うことで得られるあまり目立たない利点の1つは、フレーム、ルーティング、キューイングなどをすでに処理しているため、プロトコル仕様を書くのに必要な労力をおそらく90%以上削減できることです。これは、フレームやルーティング、キューイングなどをすでに処理しているため、迅速に実験し、安価に間違いを犯すことができ、その結果、迅速に学ぶことができることを意味します。

### アンプロトコルの書き方 {#How-to-Write-Unprotocols}

アンプロトコル仕様書を書き始めるときは、読者が何を期待しているのかわかるように、一貫した構造にこだわります。以下は、私が使っている構成です：

* カバーセクション：1行の要約、仕様書へのURL、正式名称、バージョン、誰に責任を負わせるかを記載します。
* 本文のライセンス：公開仕様の場合は絶対に必要です。
* 変更プロセス：すなわち、読者としてどのように仕様の問題を修正することができますか？
* 言語の使用： 言語の使用：MUST、MAY、SHOULDなど、RFC2119を参照しながら。
* 成熟度表示：これは実験的、ドラフト、安定、レガシー、または引退か？
* プロトコルの目標：どのような問題を解決しようとしているのか？
* 形式的な文法：テキストの解釈の違いによる論争を防ぐ。
* 技術的な説明：各メッセージのセマンティクス、エラー処理など。
* セキュリティに関する議論：プロトコルがどの程度安全であるかを明示的に説明する。
* 参考文献：他の文書やプロトコルなど。

明確で表現力豊かな文章を書くのは難しいです。プロトコルの実装を記述しようとするのは避けてください。契約書を書いていることを思い出してください。各当事者の義務や期待、義務のレベル、ルールを破った場合の罰則などを明確な言葉で記述するのです。各当事者がどのように契約の一部を履行するかを定義しようとはしません。

以下は、プロトコルのないものについての重要なポイントです：

* プロセスがオープンである限り、委員会は必要ありません：ただ、クリーンな最小限のデザインを作り、誰もが自由にそれを改善できるようにするのです。

* 既存のライセンスを使用すれば、その後の法的な心配はありません。私は、公開仕様書にはGPLv3を使用しており、あなたにもそうするようアドバイスしています。社内の仕事では、標準的な著作権が完璧です。

* 形式的なものは価値があります。つまり、ABNF（Augmented Backus-Naur Form）のような正式な文法を書くことを学び、これを使用してメッセージを完全に文書化することです。

* [DigistanのCOSS](http://www.digistan.org/spec:1)のような市場主導のライフサイクルプロセスを使うことで、人々があなたの仕様に適切な重みを置き、成熟する(あるいはしない)ようにします。

### なぜGPLv3を公共仕様に使うのか? {#Why-use-the-GPLv-for-Public-Specifications}

選択するライセンスは、パブリックな仕様書では特に重要です。伝統的に、プロトコルはカスタムライセンスで公開され、著者がテキストを所有し、派生作品が禁止されています。これは素晴らしいことですが（結局のところ、誰がプロトコルがフォークされるのを見たいのでしょうか）、実際には非常に危険です。プロトコル委員会は捕捉されやすく、プロトコルが重要で価値があれば、捕捉のインセンティブは大きくなります。

一旦捕獲されると、ある野生動物のように、重要なプロトコルはしばしば死んでしまうでしょう。本当の問題は、従来のライセンスで公開された捕獲されたプロトコルを*フリー*にする方法がないことです。フリー」という言葉は、単に言論や空気を表す形容詞ではなく、動詞でもあります。そして、ある作品を所有者の意に反してフォークする権利*は、捕獲を避けるために不可欠です。

これをもっと短い言葉で説明しましょう。iMatixが今日、本当に素晴らしくて人気のあるプロトコルを書いたと想像してください。私たちは仕様を公開し、多くの人がそれを実装します。それらの実装は高速で素晴らしく、しかもビールのように無料です。その結果、既存のビジネスが脅かされるようになりました。その高価な商用製品は速度が遅く、太刀打ちできない。ある日、彼らは韓国のメータン洞にあるアイマティックスのオフィスにやってきて、私たちの会社を買いたいと申し出てきた。私たちは、寿司とビールに莫大なお金を費やしているのだから、喜んで引き受けることにした。新しいプロトコルの所有者は、邪悪な笑いを浮かべながら、公開バージョンの改良を止め、仕様を閉じ、特許を取得した拡張機能を追加する。彼らの新製品はこの新しいプロトコルのバージョンをサポートするが、オープンソースのバージョンは法的にそれを阻止される。その会社は市場全体を支配し、競争は終わりを告げます。

オープンソースのプロジェクトに貢献するとき、自分の苦労がクローズドソースの競合他社に利用されないことを本当に知りたいと思うでしょう。これが、ほとんどの貢献者にとって、GPLが「より寛容な」BSD/MIT/X11ライセンスに勝る理由です。これらのライセンスは、不正行為を許可しているのです。これは、ソースコードと同じようにプロトコルにも当てはまります。

GPLv3仕様を実装するとき、あなたのアプリケーションはもちろんあなたのものであり、あなたが好きなようにライセンスされます。しかし、あなたは2つのことを確信することができます。一つは、その仕様がプロプライエタリな形に拡張されることは*決して*ないということです。この仕様の派生形態もGPLv3でなければなりません。2つ目は、このプロトコルを実装したり使ったりする人は、このプロトコルがカバーするものに対して特許攻撃をすることはありませんし、世界にフリーライセンスを与えることなく、自分の特許技術をこのプロトコルに追加することはできません。

### ABNFを使う {#Using-ABNF}

プロトコルの仕様を書くときの私のアドバイスは、正式な文法を学び、それを使うことです。他の人があなたの言いたいことを解釈して、避けられない間違った思い込みから回復するよりも、手間がかからないからです。文法の対象は、コンパイラではなく、他の人たち、エンジニアです。

私の好きな文法は、[RFC2234](http://www.ietf.org/rfc/rfc2234.txt)で定義されているABNFです。なぜなら、双方向通信プロトコルを定義するための形式言語としては、おそらく最も単純で最も広く使われているからです。IETF（インターネット技術タスクフォース）のほとんどの仕様がABNFを使用しており、これは良い仲間だと思います。

ABNFの書き方について30秒のクラッシュコースを提供しよう。正規表現を思い浮かべるかもしれない。文法はルールとして記述する。各ルールは、「name = elements」という形式をとります。要素には、別のルール（別のルールとして以下で定義する）、<tt>CRLF</tt>、<tt>OCTET</tt>、数字などのあらかじめ定義された*端末*を指定することができます。[RFC](http://www.ietf.org/rfc/rfc2234.txt)は、すべてのターミナルをリストアップしています。代替要素を定義するには、スラッシュで区切ります。繰り返しを定義する場合は，アスタリスクを使用する。要素をグループ化するには、括弧を使用します。直感的に理解できないので、RFCを読んでください。

この拡張が適切かどうかはわかりませんが、私は要素の前に「C:」と「S:」を付けて、それがクライアントから来たものかサーバーから来たものかを示しています。

この章の後半で出てくるNOMという非プロトコルのABNFの一部を紹介します：

```
nom-protocol = open-peering *use-peering

open-peering = C:OHAI ( S:OHAI-OK / S:WTF )

ユースピアリング = C:ICANHAZ
                / S:Cheezburger
                / C:HUGZ S:HUGZ-OK
                / S:HUGZ C:HUGZ-OK
```

これらのキーワード (<tt>OHAI</tt>, <tt>WTF</tt>) は、商用プロジェクトで実際に使用したことがあります。それらは、開発者をほくほくさせ、幸せにします。経営陣を混乱させる。後で捨てたくなるような最初の原稿には適しています。

### 安かろう悪かろうのパターン {#The-Cheap-or-Nasty-Pattern}

数十年にわたり、大小さまざまなプロトコルを書いてきた中で、私が学んだ一般的なレッスンがあります。私はこれを*Cheap or Nasty*パターンと呼んでいます。仕事を2つの側面や層に分け、それぞれを別々に解決することがよくあります。

CheapまたはNastyを実現するための重要な洞察は、多くのプロトコルが、制御のための低容量のチャット的な部分と、データのための高容量の非同期的な部分とが混在していることを理解することです。例えば、HTTPには、認証とページ取得のためのチャット的なダイアログと、データストリームのための非同期的なダイアログがあります。FTPでは、これを2つのポートに分割しています。1つは制御用のポート、もう1つはデータ用のポートです。

制御とデータを分離しないプロトコル設計者は、恐ろしいプロトコルを作りがちです。なぜなら、この2つのケースのトレードオフは、ほとんど完全に対立しているからです。制御には最適でもデータには不向きであり、データには最適でも制御には使えないのです。特に、拡張性や優れたエラーチェックと同時に高い性能を求める場合には、その傾向が顕著です。

古典的なクライアント/サーバーのユースケースを使って、これを分解してみましょう。クライアントはサーバーに接続し、認証する。そして、何らかのリソースを要求する。サーバーはチャットで応答し、データをクライアントに送り返す。やがて、クライアントが切断するか、サーバーが終了すると、会話は終了する。

さて、これらのメッセージの設計を始める前に、立ち止まって考え、制御ダイアログとデータフローを比較してみましょう：

* コントロールダイアログは短時間で終了し、メッセージ数も少ない。コントロールダイアログは短時間で終わり、メッセージの数も非常に少ない。

* コントロールダイアログは、例えば、認証されていない、見つからない、支払いが必要、検閲されている、など、すべての「通常の」エラーが起こる場所です。対照的に、データフロー中に起こるエラーはすべて例外的なものです（ディスクフル、サーバークラッシュ）。

* コントロールダイアログは、オプションやパラメータを追加することで、時間の経過とともに変化する場所です。リソースのセマンティクスは時間と共にかなり変化するため、データフローはほとんど変化しないはずです。

* コントロールダイアログは、基本的に同期型のリクエスト/リプライダイアログです。データフローは、基本的に一方通行の非同期フローです。

これらの違いは重要です。パフォーマンスについて語るとき、それはデータフローにのみ適用されます。1回限りの制御ダイアログを高速に設計するのは病的なことです。したがって、シリアライズのコストについて語るとき、これはデータフローにのみ適用される。制御フローをエンコード/デコードするコストは膨大になる可能性があり、多くの場合、それで何かが変わるということはない。そこで、Cheapを使って制御をエンコードし、Nastyを使ってデータフローをエンコードしています。

Cheapは本質的に同期的で、冗長で、記述的で、柔軟です。Cheapのメッセージは、アプリケーションごとに変化しうる豊富な情報に満ちています。設計者としての目標は、この情報を簡単に符号化・解析できるようにすること、実験や成長のために拡張するのが簡単なこと、そして前方や後方の変化に対して非常に堅牢であることです。プロトコルの安価な部分は次のようなものです：

* XML、JSON、HTTPスタイルのヘッダーなど、データに対して簡単な自己記述型の構造化エンコーディングを使用します。XML、JSON、HTTPスタイルのヘッダーなど、データのためのシンプルな自己記述型構造化エンコーディングを使用します。ターゲット言語でそのための標準的な単純なパーサーがある限り、どんなエンコーディングでもかまいません。

* 各リクエストに成功/失敗の返答がある、ストレートなリクエスト/リプライモデルを使用しています。このため、チープダイアログのための正しいクライアントとサーバーを書くのは簡単です。

* 高速であろうとする努力は微塵もしない。セッションに一度だけ、あるいは数回だけ何かをする場合、性能は重要ではありません。

Cheapパーサーは、あなたが棚から取り出して、データを投げるものです。クラッシュせず、メモリをリークせず、高い耐性を持ち、比較的簡単に扱えるものであるべきです。それだけです。

しかし、Nastyは本質的に非同期で、簡潔で、無口で、柔軟性に欠けるものです。Nastyのメッセージは、実質的に決して変化しない最小限の情報を運びます。デザイナーとしてのあなたのゴールは、この情報を超高速で解析すること、そしておそらくは拡張や実験が不可能になるようにすることです。理想的なNastyパターンは次のようなものです：

* データには手作業で最適化されたバイナリレイアウトを使用し、すべてのビットが精密に作られています。

* それは、1つまたは両方のピアが確認応答なしでデータを送信する（または、もしそうなら、彼らはクレジットベースのフロー制御のような卑劣な非同期技術を使用する）純粋な非同期モデルを使用しています。

* それは友好的であるために、わずかでさえ、試みない。1秒間に数百万回何かをするときに重要なのは、パフォーマンスです。

淫らなパーサーとは、ビット、バイト、ワード、整数を個別に正確に書き込んだり、読み込んだりする、あなたが手で書いたもののことです。気に入らないものはすべて拒否し、メモリ割り当てをまったく行わず、クラッシュすることもありません。

安かろう悪かろうは普遍的なパターンではなく、すべてのプロトコルがこの二項対立を持つわけではありません。また、Cheap or Nastyをどのように使うかは、状況によって異なります。場合によっては、1つのプロトコルの2つの部分となることもあります。また、ある場合には、2つのプロトコルを重ね合わせることもできます。

### エラー処理 {#Error-Handling}

CheapまたはNastyを使用すると、エラー処理がより簡単になります。2種類のコマンドと、エラーを通知する2つの方法があります：

* 同期制御コマンド：エラーは正常です：すべてのリクエストは、OKかエラー応答のどちらかの応答を持ちます。
* 非同期データコマンド：エラーは例外的です：悪いコマンドは黙って捨てられるか、接続全体が閉じられるかのどちらかです。

通常、数種類のエラーを区別することは良いことですが、いつものように最小限にとどめ、必要なものだけを追加してください。

## データのシリアライズ {#Serializing-Your-Data}

プロトコルの設計を始めると、最初に直面する問題の1つは、データをどのようにワイヤ上で符号化するかということです。普遍的な答えはありません。データをシリアライズする方法には、それぞれ長所と短所があり、6種類ほどあります。ここでは、そのうちのいくつかを紹介します。

### 抽象化レベル {#Abstraction-Level}

データを電線に乗せる方法を見る前に、アプリケーション間で実際に交換したいデータは何か、考えてみる価値があります。抽象化を行わない場合は、文字通り内部状態のシリアライズとデシリアライズを行います。つまり、私たちの機能を実装するために使用するオブジェクトや構造体です。

しかし、内部状態を電線上に置くことは、本当に悪い考えです。APIで内部状態を公開するようなものです。このようなことをすると、プロトコルに実装の決定をハードコーディングすることになります。また、必要以上に複雑なプロトコルを作成することになります。

古いプロトコルやAPIが複雑なのは、設計者がよりシンプルな概念に抽象化する方法を考えなかったからかもしれません。もちろん、抽象化されたものがより単純であるという保証はありませんし、そこが難しいところです。

優れたプロトコルやAPIの抽象化は、自然な使用パターンをカプセル化し、予測可能で規則性のある名前とプロパティを与えます。主要なユースケースを最小限に特定できるように、賢明なデフォルトを選択する。単純なケースはシンプルに、複雑なケースは表現豊かにすることを目指します。相互運用性のために絶対に必要な場合を除き、内部実装についていかなる声明や仮定も行いません。

### ZeroMQフレーミング {#ZeroMQ-Framing}

ZeroMQアプリケーションで最もシンプルで広く使用されているシリアライズ形式は、ZeroMQ独自のマルチパートフレーミングです。例えば、[Majordomo Protocol](http://rfc.zeromq.org/spec:7)がリクエストを定義する方法は次のとおりです：

```
Frame 0: Empty frame
Frame 1: "MDPW01" (six bytes, representing MDP/Worker v0.1)
Frame 2: 0x02 (one byte, representing REQUEST)
Frame 3: Client address (envelope stack)
Frame 4: Empty (zero bytes, envelope delimiter)
Frames 5+: Request body (opaque binary)
```

これをコードで読み書きするのは簡単ですが、これは制御フローの典型的な例です（MDPはおしゃべりなリクエスト・リプライ・プロトコルなので、本当は全体がそうなのですが）。MDPを第2バージョンに改良することになったとき、このフレーミングを変えなければならなかったのです。素晴らしいことに、既存の実装をすべて壊してしまいました！

後方互換性は難しいですが、制御フローにZeroMQのフレームを使うことは、*何の役にも立ちません*。私自身のアドバイスに従った場合、このプロトコルをどのように設計するべきだったかを紹介します（次のバージョンではこれを修正します）。これはCheapパートとNastyパートに分かれていて、ZeroMQフレーミングを使ってこれらを分離しています：

```
Frame 0: "MDP/2.0" for protocol name and version
Frame 1: command header
Frame 2: command body
```

様々な中間体（クライアントAPI、ブローカー、ワーカーAPI）でコマンドヘッダを解析し、アプリケーションからアプリケーションへコマンドボディをそのまま渡すと予想されるところです。

### シリアライズ言語 {#Serialization-Languages}

シリアライズ言語には流行がある。XMLは、以前は人気で大きく、その後、過剰なエンジニアリングで大きくなり、「企業情報アーキテクト」の手に落ち、それ以来、生きているのを見たことがありません。今日のXMLは、「その混乱のどこかに、逃れようとする小さくてエレガントな言語がある」ことの典型です。

それでもXMLは、SGML（Standard Generalized Markup Language）のような化け物を含むその前身よりもずっとずっと優れており、EDIFACTのような心を苦しめる化け物に比べれば、涼しい風だった。つまり、シリアライズ言語の歴史は、自分の仕事にしがみつこうとする反旗を翻したEIAの波に隠れながら、徐々に正気を取り戻してきたと言えるでしょう。

JSONは、JavaScriptの世界から飛び出したもので、「XMLを使うくらいなら辞めよう」と、データを電線に投げて再び取り出せる手軽な方法です。JSONは、最小限のXMLをJavaScriptのソースコードとしてこっそりと表現したものです。

以下は、チープなプロトコルでJSONを使用する簡単な例です：

```
"protocol": {
    "name": "MTL",
    "version": 1
},
"virtual-host": "test-env"
```

同じデータをXMLにすると、次のようになります（XMLでは、トップレベルのエンティティを1つだけ作る必要があります）：

```
<command>
    <protocol name = "MTL" version = "1" />
    <virtual-host>test-env</virtual-host>
</command>
```

そして、古いHTTPスタイルのヘッダーを使用した場合です：

```
Protocol: MTL/1.0
Virtual-host: test-env
```

これらは、パーサーやスキーマの検証や、その他の「私たちを信じてください、これはすべてあなたのためなのです」という無意味なことをやり過ぎない限り、すべてかなり同等です。安価なシリアライズ言語では、無料で実験することができます（「認識できない要素/属性/ヘッダーは無視する」）。また、例えば、コマンドをハッシュテーブルにサンクしたり、その逆を行う汎用パーサーを書くのも簡単です。

しかし、すべてがバラ色というわけではありません。最近のスクリプト言語はJSONやXMLを簡単にサポートしていますが、古い言語ではそうではありません。XMLやJSONを使うと、非自明な依存関係ができてしまう。また、C言語のような言語でツリー構造のデータを扱うのは、少々面倒です。

ですから、目指す言語に応じて選択を進めることができます。もし、あなたの世界がスクリプト言語であるなら、JSONにしましょう。より広いシステム利用のためのプロトコル構築を目指すのであれば、C言語開発者のためにシンプルに、HTTPスタイルのヘッダーにこだわってみてはいかがでしょうか。

### シリアライズライブラリ {#Serialization-Libraries}

<tt>msgpack.org</tt>のサイトにはこう書かれています：

> JSONのようなものだが、高速で小さい。MessagePack は、効率的なバイナリシリアライゼーションフォーマットです。JSONのように複数の言語間でデータを交換することができますが、より速く、より小さくすることができます。例えば、小さな整数（フラグやエラーコードなど）は1バイトにエンコードされ、典型的な短い文字列は、文字列そのものに加えて1バイト余分に必要とするだけです。

ここで、「速くて小さい」というのは、非問題を解決するための機能であるという、おそらく不評な主張をさせていただきます。シリアライゼーション・ライブラリが解決する唯一の真の問題は、私が知る限り、メッセージ・コントラクトを文書化し、実際にワイヤとの間でデータをシリアライズする必要があることです。

まず、「高速で小さい」という言葉を否定するところから始めましょう。これは2つの論法に基づいています。まず、メッセージを小さくしてエンコードとデコードにかかるCPUコストを削減すれば、アプリケーションのパフォーマンスに大きな違いが出るというものです。第二に、このことはすべてのメッセージに対して等しく有効であるということです。

しかし、実際のアプリケーションの多くは、2つのカテゴリーのいずれかに分類される傾向があります。データベースへのアクセスやアプリケーションコードのパフォーマンスなど、他のコストと比較して、シリアライズのスピードやエンコードのサイズはわずかなものである。あるいは、ネットワークのパフォーマンスが本当に重要であり、重要なコストはすべて少数の特定のメッセージタイプで発生する。

このように、全体的に「高速で小さい」ことを目指すのは、誤った最適化であると言えます。頻度の低い制御フローではCheapの簡単な柔軟性を、大量のデータフローではNastyの残酷な効率性を得ることはできません。さらに悪いことに、すべてのメッセージが何らかの形で等しいという仮定は、プロトコルの設計を腐らせる可能性があります。CheapかNastyかは、シリアライズ戦略だけでなく、同期か非同期か、エラー処理か、変更のコストか、といった問題でもあります。

私の経験では、メッセージベースのアプリケーションにおけるパフォーマンスの問題のほとんどは、（a）アプリケーション自体の改善、（b）大量のデータフローを手作業で最適化することで解決できる。そして、最も重要なデータフローを手作業で最適化するためには、データに関する悪用される事実を学ぶという、汎用のシリアライザーではできない不正行為が必要です。

次に、ドキュメンテーションと、契約書をコードだけでなく明示的かつ形式的に記述する必要性について説明します。これは解決すべき有効な問題であり、長寿命で大規模なメッセージベースアーキテクチャを構築するための主要な問題の1つです。

ここでは、MessagePack インターフェース定義言語 (IDL) を使って、典型的なメッセージをどのように記述するかを説明します：

```
message Person {
  1: string surname
  2: string firstname
  3: optional string email
}
```

さて、同じメッセージをGoogleプロトコルバッファのIDLを使用しています：

```
message Person {
  required string surname = 1;
  required string firstname = 2;
  optional string email = 3;
}
```

これは機能しますが、ほとんどの実用的なケースでは、手書きや機械的に作成された適切な仕様に裏打ちされたシリアライズ言語と比較して、ほとんど勝ち目がありません（これについては後述します）。その代償として、余計な依存関係が発生し、CheapやNastyを使った場合よりも全体的なパフォーマンスが低下する可能性があります。

### 手書きバイナリシリアライズ {#Handwritten-Binary-Serialization}

この本でお分かりのように、私がシステムプログラミングに好んで使う言語はC（C99にアップグレードされ、コンストラクタ/デストラクタのAPIモデルやジェネリックコンテナを備えている）である。この近代化されたC言語が好きな理由は2つあります。まず、私はC++のような大きな言語を学ぶには心が弱すぎるのです。人生には、理解すべきもっと面白いことがたくさんあるように思えるからです。第二に、この特殊なレベルの手動制御によって、より良い結果をより早く出すことができるということです。

ここで重要なのは、CとC++の違いではなく、ハイエンドのプロフェッショナルなユーザーにとってのマニュアルコントロールの価値です。世界最高の自動車、カメラ、エスプレッソマシンがマニュアルコントロールであることは偶然ではありません。その場での微調整が、世界的な成功か、二番煎じかの分かれ目となることが多いのです。

シリアル化の速度や結果の大きさ（これらは互いに矛盾することが多い）を本当に本当に気にする場合、手書きのバイナリシリアライズが必要です。つまり、Mr.Nastyのためにそれを聞くことができます！

効率的なNastyエンコーダ/デコーダ(コーデック)を書くための基本的なプロセスは以下の通りです：

* コーデックをストレステストできるような代表的なデータセットとテストアプリケーションを構築します。
* コーデックのファーストダムバージョンを書く。
* テスト、測定、改善、そして時間やお金がなくなるまで繰り返す。

私たちがコーデックをより良くするために使っているテクニックをいくつか紹介します：

* プロファイラを使用すること。ホットスポットが見つかったら、それを修正する。

* ヒープは最新のLinuxカーネルでは非常に高速ですが、ほとんどの素朴なコーデックではまだボトルネックになっています。古いカーネルでは、ヒープが悲惨なほど遅くなることがあります。できる限りヒープの代わりにローカル変数（スタック）を使ってください。

* 異なるプラットフォームで、異なるコンパイラとコンパイラオプションでテストすること * ヒープとは別に、他にも多くの違いがあります。ヒープ以外にも多くの違いがあります。主なものを学び、それらを許容する必要があります。

* コーデックのパフォーマンスを気にする場合、ほぼ間違いなく同じ種類のデータを何度も送信しています。データのインスタンス間には冗長性があるはずです。これらを検出し、それを圧縮に利用することができます（例えば、「前回と同じ」という意味の短い値など）。

* *データを知る.* 最適な圧縮技術（コンパクト化に対するCPUコストの観点から）には、データについて知ることが必要です。例えば、単語リスト、ビデオ、株式市場データのストリームを圧縮するために使用される技術は、すべて異なります。

* x86とARMは現代のCPUのほとんどを占めているが、リトルエンディアンを使用している（ARMは実際にはバイエンディアンだが、AndroidはWindowsやiOSと同様にリトルエンディアンである）。

### コード生成 {#Code-Generation}

前の2つのセクションを読んで、"汎用のものよりも優れたIDLジェネレーターを自分で書けないだろうか？"と思ったかもしれません。という疑問が湧いたかもしれませんが、実際にどれだけの労力が必要なのかという暗算に追われ、すぐにその考えは消えてしまったことでしょう。

もし私が、カスタムIDLジェネレーターを安価で素早く作る方法を教えてあげたらどうでしょう？完璧に文書化された契約書や、必要なだけ邪悪でドメインに特化したコードを手に入れることができ、必要なのは魂（※誰が本当に使ったことがあるのだろう、そうだろう？

アイマティクスでは、数年前までコードジェネレーションを使って、より大規模で野心的なシステムを構築していましたが、この技術（GSL）は一般的に使うには危険すぎると判断し、アーカイブを封印して、深いダンジョンに重い鎖で閉じ込めました。実際にGitHubに掲載しました。これから出てくる例を試したいなら、[リポジトリ](https://github.com/imatix/gsl)を入手して、<tt>gsl</tt>コマンドを自分でビルドしてください。srcサブディレクトリで "make "と入力すればOKです（Windowsが大好きなあの人なら、きっとプロジェクトファイル付きのパッチを送ってくれるはずです）。

このセクションはGSLについてではなく、あまり知られていない便利なトリックについてです。このトリックは、作品だけでなく自分自身のスケールも大きくしたい野心的な建築家にとって便利なものです。このトリックを覚えれば、自分のコードジェネレータを短時間で作り上げることができる。多くのソフトウェアエンジニアが知っているコードジェネレータには、ハードコーディングされたモデルが1つだけ付属しています。例えば、Ragelは「正規言語から実行可能な有限状態機械をコンパイルする」、つまり、Ragelのモデルは正規言語である。これは確かに良い問題群には有効ですが、普遍的とは言い難いです。RagelのAPIはどのように記述するのでしょうか？あるいはプロジェクトのmakefileは？あるいは、[第4章 信頼性の高い要求応答パターン](chapter4#reliable-request-reply)でBinary Starパターンを設計するために使ったような有限状態機械も？

これらはすべて、コード生成の恩恵を受けることになりますが、普遍的なモデルはありません。だから、必要なモデルを自分で設計し、そのモデルのための安価なコンパイラとしてコードジェネレータを作るのがコツです。良いモデルを作るにはある程度の経験が必要ですし、カスタムコードジェネレータを安く作る技術も必要です。PerlやPythonのようなスクリプト言語が良い選択肢です。しかし、私たちは実際にこのために特別にGSLを作りましたし、それが私の好みなのです。

ここでは、すでに知っていることに関連する簡単な例を見てみましょう。大規模な作業ではコード生成が重要な知識であると本当に信じているので、後でもっと大規模な例を見ることにします。第4章 - 信頼性の高いリクエスト・リプライのパターン](chapter4#reliable-request-reply)では、[Majordomo Protocol (MDP)](http://rfc.zeromq.org/spec:7) を開発し、そのためのクライアント、ブローカー、ワーカーを書きました。では、これらの部品を機械的に生成するために、独自のインタフェース記述言語やコードジェネレータを構築することはできないだろうか。

GSLモデルを書くときには、好きな意味論を使うことができます。つまり、ドメイン固有の言語をその場で発明することができるのです。何を表現しているかわかるかな？

```
slideshow
    name = Cookery level 3
    page
        title = French Cuisine
        item = Overview
        item = The historical cuisine
        item = The nouvelle cuisine
        item = Why the French live longer
    page
        title = Overview
        item = Soups and salads
        item = Le plat principal
        item = Béchamel and other sauces
        item = Pastries, cakes, and quiches
        item = Soufflé: cheese to strawberry
```

こちらはいかがでしょうか：

```
table
    name = person
    column
        name = firstname
        type = string
    column
        name = lastname
        type = string
    column
        name = rating
        type = integer
```

1つ目は、プレゼンテーションにまとめることができます。2つ目は、SQLにコンパイルして、データベースのテーブルを作成し、それを操作することができます。つまり、この演習では、ドメイン言語である*モデル*は、さまざまなタイプの「フィールド」を含む「メッセージ」を含む「クラス」で構成されています。これは、意図的に馴染みのあるものです。以下はMDPクライアントプロトコルです：

```
<class name = "mdp_client">
    MDP/Client
    <header>
        <field name = "empty" type = "string" value = ""
            >Empty frame</field>
        <field name = "protocol" type = "string" value = "MDPC01"
            >Protocol identifier</field>
    </header>
    <message name = "request">
        Client request to broker
        <field name = "service" type = "string">Service name</field>
        <field name = "body" type = "frame">Request body</field>
    </message>
    <message name = "reply">
        Response back to client
        <field name = "service" type = "string">Service name</field>
        <field name = "body" type = "frame">Response body</field>
    </message>
</class>
```

そして、MDPワーカープロトコルは以下の通りです：

```
<class name = "mdp_worker">
    MDP/Worker
    <header>
        <field name = "empty" type = "string" value = ""
            >Empty frame</field>
        <field name = "protocol" type = "string" value = "MDPW01"
            >Protocol identifier</field>
        <field name = "id" type = "octet">Message identifier</field>
    </header>
    <message name = "ready" id = "1">
        Worker tells broker it is ready
        <field name = "service" type = "string">Service name</field>
    </message>
    <message name = "request" id = "2">
        Client request to broker
        <field name = "client" type = "frame">Client address</field>
        <field name = "body" type = "frame">Request body</field>
    </message>
    <message name = "reply" id = "3">
        Worker returns reply to broker
        <field name = "client" type = "frame">Client address</field>
        <field name = "body" type = "frame">Request body</field>
    </message>
    <message name = "hearbeat" id = "4">
        Either peer tells the other it's still alive
    </message>
    <message name = "disconnect" id = "5">
        Either peer tells other the party is over
    </message>
</class>
```

GSL はモデリング言語として XML を使用します。XMLはあまりに多くの企業の下水道を通ってきたため、甘い香りがしないという悪い評判がありますが、シンプルに保つ限りは強いプラス面もあります。項目と属性の自己記述的な階層を記述する方法であれば、どんなものでもよい。

さて、ここでGSLで書かれた短いIDLジェネレータが、プロトコルモデルをドキュメントに変えてくれる：

```
.#  Trivial IDL generator (specs.gsl)
.#
.output "$(class.name).md"
## The $(string.trim (class.?''):left) Protocol
.for message
.   frames = count (class->header.field) + count (field)

A $(message.NAME) command consists of a multipart message of $(frames)
frames:

.   for class->header.field
.       if name = "id"
* Frame $(item ()): 0x$(message.id:%02x) (1 byte, $(message.NAME))
.       else
* Frame $(item ()): "$(value:)" ($(string.length ("$(value)")) \
bytes, $(field.:))
.       endif
.   endfor
.   index = count (class->header.field) + 1
.   for field
* Frame $(index): $(field.?'') \
.       if type = "string"
(printable string)
.       elsif type = "frame"
(opaque binary)
.           index += 1
.       else
.           echo "E: unknown field type: $(type)"
.       endif
.       index += 1
.   endfor
.endfor
```

XMLモデルとこのスクリプトは、サブディレクトリexamples/modelsにあります。コード生成を行うために、次のようなコマンドを与えています：

```
gsl -script:specs mdp_client.xml mdp_worker.xml
```

以下は、ワーカープロトコルのMarkdownテキストです：

```
## The MDP/Worker Protocol

A READY command consists of a multipart message of 4 frames:

* Frame 1: "" (0 bytes, Empty frame)
* Frame 2: "MDPW01" (6 bytes, Protocol identifier)
* Frame 3: 0x01 (1 byte, READY)
* Frame 4: Service name (printable string)

A REQUEST command consists of a multipart message of 5 frames:

* Frame 1: "" (0 bytes, Empty frame)
* Frame 2: "MDPW01" (6 bytes, Protocol identifier)
* Frame 3: 0x02 (1 byte, REQUEST)
* Frame 4: Client address (opaque binary)
* Frame 6: Request body (opaque binary)

A REPLY command consists of a multipart message of 5 frames:

* Frame 1: "" (0 bytes, Empty frame)
* Frame 2: "MDPW01" (6 bytes, Protocol identifier)
* Frame 3: 0x03 (1 byte, REPLY)
* Frame 4: Client address (opaque binary)
* Frame 6: Request body (opaque binary)

A HEARBEAT command consists of a multipart message of 3 frames:

* Frame 1: "" (0 bytes, Empty frame)
* Frame 2: "MDPW01" (6 bytes, Protocol identifier)
* Frame 3: 0x04 (1 byte, HEARBEAT)

A DISCONNECT command consists of a multipart message of 3 frames:

* Frame 1: "" (0 bytes, Empty frame)
* Frame 2: "MDPW01" (6 bytes, Protocol identifier)
* Frame 3: 0x05 (1 byte, DISCONNECT)
```

これは見ての通り、元の仕様書に手書きで書いたものに近いです。さて、<tt>zguide</tt>リポジトリをクローンして、<tt>examples/models</tt>にあるコードを見ていると、MDPクライアントとワーカーのコーデックを生成することができます。同じ2つのモデルを別のコードジェネレータに渡します：

```
gsl -script:codec_c mdp_client.xml mdp_worker.xml
```

これで<tt>mdp_client</tt>と<tt>mdp_worker</tt>クラスが出来上がりました。実際、MDPはとてもシンプルなので、コードジェネレータを書く労力はほとんどかかりません。儲かるのは、プロトコルを変更したいときです（スタンドアロンのMajordomoプロジェクトではそうしました）。プロトコルを変更し、コマンドを実行すると、より完璧なコードが飛び出してくるのです。

<tt>codec_c.gsl</tt>コード ジェネレーターは短いものではありませんが、結果として得られるコーデックは、私が Majordomo のために最初にまとめた手書きのコードよりもずっと優れています。たとえば、手書きのコードにはエラーチェック機能がなく、偽のメッセージを渡すと死んでしまうようなものでした。

これから、GSLを使ったモデル指向のコード生成の長所と短所を説明することにしよう。パワーはタダでは手に入りません。私たちのビジネスにおける最大の罠は、何もないところからコンセプトを発明する能力です。GSLはこれを特に簡単にするので、同じように危険なツールになり得るのです。

*コンセプトを発明してはいけません。デザイナーの仕事は問題を取り除くことであり、機能を追加することではないのです。

まず、モデル指向のコード生成の利点を整理しておきます：

* モデル指向のコード生成の利点について説明します。つまり、私たちのプロトコルモデルは、Majordomoの「現実世界」に100％対応しているのです。これは、モデルを調整したり変更したりする自由がなければ不可能なことです。
* このような完璧なモデルを迅速かつ安価に開発することができます。
* どんなテキスト出力も可能です。一つのモデルから、ドキュメント、あらゆる言語のコード、テストツールなど、文字通りあらゆるアウトプットを作成することができます。
* コードジェネレータをどのレベルまで向上させるのも安価なので、*完璧な*出力を生成することができます（私はこれを文字通り意味しています）。
* 仕様とセマンティクスを組み合わせた単一のソースを得ることができます。
* 小さなチームを大規模に活用することができます。iMatixでは、100万行のOpenAMQメッセージング製品を、コード生成スクリプトそのものを含め、おそらく85K行の入力モデルから作成しました。

では、デメリットも見てみましょう：

* プロジェクトにツールの依存関係を追加することになります。
* プロジェクトにツールの依存関係を追加することになります。
* 奇妙なもの」を見てしまう新参者を、あなたの仕事から遠ざけてしまうかもしれません。
* あなたのプロジェクトに投資しない強い口実を人々に与えるかもしれません。

皮肉なことに、モデル指向の乱用は、自分が少しの努力で維持でき、誰にも奪われることのない完璧なコードを大量に作り出したい環境では、とても有効です。でも、長期的な仕事の安定を求めるのであれば、これはほぼ完璧です。

もしあなたがGSLを使い、自分の作品の周りにオープンなコミュニティを作りたいのであれば、次のようなアドバイスをします：

* GSLを使うのは、手で面倒なコードを書かなければならないような場合に限ります。
* 人々が期待するような自然なモデルを設計する。
* 何が生成されるかを知るために、まず手でコードを書く。
* 使い過ぎないこと。シンプルに保つ！*メタになりすぎないように。
* プロジェクトに徐々に導入していく。
* 生成されたコードはリポジトリに置く。

ZeroMQ周辺のいくつかのプロジェクトでは、すでにGSLを使用しています。例えば、高レベルのCバインディングであるCZMQでは、ソケットオプションクラス（<tt>zsockopt</tt>）を生成するのにGSLを使用しています。300行のコードジェネレーターが、78行のXMLモデルを1,500行の完璧な、しかし本当に退屈なコードに変えてしまうのです。これは良い勝利だ。

## ファイルの転送 {#Transferring-Files}

さて、講義はお休みして、初恋の人、そしてこの仕事をする理由である「コード」に戻りましょう。

ZeroMQのメーリングリストでは、「ファイルを送信するにはどうしたらいいですか」というのがよくある質問です。ファイル転送はおそらく最も古く、最も明白なメッセージングの一種であるため、これは驚くべきことではありません。ネットワーク上でファイルを送信することは、著作権カルテルを困らせる以外にも、多くのユースケースがあります。ZeroMQは、イベントやタスクの送信には非常に優れていますが、ファイルの送信にはあまり適していません。

私は1年か2年前から、適切な説明を書くことを約束しています。ここで、あなたの朝を明るくするために、ありがたい情報をひとつ。"proper "という言葉は、古風なフランス語の*propre*から来ていて、「きれい」という意味です。暗黒時代のイギリスの庶民は、お湯や石鹸になじみがなかったため、この言葉を「外国の」「上流階級の」という意味に変えて、「それはちゃんとした食べ物だ！」と言ったが、後にこの言葉は「本当の」という意味になり、「それはあなたが私たちを巻き込んだちゃんとした混乱だ！」と言うようになった。

で、ファイル転送。適当なファイルを選んで目隠しし、メッセージに丸ごと押し込むことができないのには、いくつかの理由がある。最も明白な理由は、RAMのサイズは何十年もかけて決定的に大きくなったにもかかわらず（1024バイトのメモリ拡張カードを買ったことを懐かしく思わない古参の人はいないでしょう）、ディスクサイズは頑なに大きいままであることです。仮にsendfileのようなシステムコールを使って1命令でファイルを送れたとしても、ネットワークは無限に速くもなければ、完全に信頼できるものでもないという現実にぶつかる。低速で不安定なネットワーク（WiFiか？）で何度も大きなファイルをアップロードしようとすると、適切なファイル転送プロトコルには、失敗から回復する方法が必要であることに気づくでしょう。つまり、まだ受信していないファイルの部分のみを送信する方法が必要なのです。

最後に、適切なファイルサーバーを構築すると、単に大量のデータを多くのクライアントに送るだけでは、技術用語で「ヒープメモリが貧弱なアプリケーションに食われてサーバーが破綻した」と呼びたい状況が発生することに気づくはずです。適切なファイル転送プロトコルは、メモリ使用量に注意を払う必要があるのです。

これらの問題を一つずつ適切に解決していくことで、ZeroMQ上で動作する適切なファイル転送プロトコルにたどり着けることを期待したい。まず、ランダムデータで1GBのテストファイルを生成してみましょう（メモリ業界が好んで売るような偽シリコン製ではなく、2ギガのパワーオブツーギガのようなVon-Neummanを意図した本物のものです）：

```
dd if=/dev/urandom of=testdata bs=1M count=1024
```

これは、一度にたくさんのクライアントが同じファイルを要求したときに困るほどの大きさであり、多くのマシンでは、1GBはメモリに割り当てるには大きすぎるでしょう。参考までに、このファイルをディスクからディスクにコピーするのにかかる時間を測ってみましょう。これで、ファイル転送プロトコルがどれだけ追加されるかがわかります（ネットワークコストも含む）：

```
$ time cp testdata testdata2

real    0m7.143s
user    0m0.012s
sys     0m1.188s
```

4桁の精度は誤解を招きやすいので、どちらにしても25%のばらつきがあるものと考えてください。これは単なる「桁違い」の測定値です。

クライアントがテストデータを要求し、サーバーがそれを一連のメッセージとして、息を止めることなく送信し、各メッセージが1つの*チャンク*を保持する、コードの最初のカットです：

{{< examples name="fileio1" title="ファイル転送テスト、モデル1" >}}。

ROUTER ソケットに多くのデータを送信すると、簡単にオーバーフローしてしまいます。単純だが愚かな解決策は、ソケットに無限の高水準のマークを付けることだ。これは、サーバーのメモリを使い果たすことに対する保護がないため、愚かなことです。しかし、無限のHWMがなければ、大きなファイルの塊が失われる危険性があります。

試しに、HWMを1,000に設定し（ZeroMQ v3.xではこれがデフォルト）、チャンクサイズを100Kに減らして、10Kチャンクを一度に送信してみます。テストを実行すると、決して終了しないことがわかるでしょう。<tt>[zmq_socket()](http://api.zeromq.org/master:zmq_socket)</tt> のマニュアルページには、ROUTER ソケットについて次のように書かれています： 「ZMQ_HWM オプションの動作です： ドロップ "とあります。

サーバーが送信するデータ量を前もってコントロールする必要があるのです。ネットワークが処理できる以上のデータを送信しても意味がない。一度に1つのチャンクを送信してみましょう。このバージョンのプロトコルでは、クライアントが明示的に「チャンクNをくれ」と言うと、サーバーはディスクから特定のチャンクをフェッチして送信します。

これは、クライアントが一度に1つのチャンクを要求し、サーバーはクライアントからの要求ごとに1つのチャンクを送信するだけというものです：

{{< examples name="fileio2" title="ファイル転送テスト、モデル2" >}}。

クライアントとサーバーの間で行ったり来たりするチャットがあるため、現在はかなり遅くなっています。ローカルループ接続（クライアントとサーバーが同じ箱）の場合、リクエストとリプライの往復で約300マイクロ秒を支払っています。大したことはないように思えるが、すぐに増えてしまうのだ：

```
$ time ./fileio1
4296 chunks received, 1073741824 bytes

real    0m0.669s
user    0m0.056s
sys     0m1.048s

$ time ./fileio2
4295 chunks received, 1073741824 bytes

real    0m2.389s
user    0m0.312s
sys     0m2.136s
```

ここで2つの貴重な教訓があります。まず、リクエスト・リプライは簡単ですが、大量のデータフローには遅すぎるということです。300マイクロ秒を一度だけ支払うのは問題ないでしょう。特に、レイテンシーが1,000倍以上ある実際のネットワークでは、1つのチャンクごとに300マイクロ秒を支払うことは許されない。

2つ目のポイントは、以前にも言ったことがありますが、もう一度言います。ZeroMQでは、実験、測定、プロトコルの改良が非常に簡単です。そして、何かのコストが大幅に下がれば、より多くのものを手に入れることができるのです。プロトコルを単独で開発し、証明することを学んでください： アプリケーションに深く埋め込まれ、簡単にテストや修正ができないような設計の悪いプロトコルを改善しようとして、時間を浪費しているチームを見てきました。

私たちのモデル2ファイル転送プロトコルは、パフォーマンスを除けば、それほど悪いものではありません：

* メモリ枯渇の危険性を完全に排除しています。それを証明するために、送信側と受信側の両方でハイウォーターマークを1に設定しました。
ネットワーク状況、ファイルタイプ、あるいはメモリ消費をさらに減らすために、チャンクサイズのチューニングが必要な場合、それを行うべきはクライアントであるため、それは有用である*それは、チャンクサイズをクライアントが選択することができます。
* ファイル転送を完全に再開することができます。
* クライアントが任意の時点でファイル転送をキャンセルすることができます。

チャンクごとにリクエストをする必要がなければ、使えるプロトコルになります。必要なのは、サーバーがクライアントからのリクエストや確認を待たずに、複数のチャンクを送信する方法です。どのような選択肢があるのでしょうか？

* サーバーは一度に10個のチャンクを送信し、1回の確認を待つことができます。これはチャンクサイズを10倍するのと全く同じなので、無意味です。そうです、10という値はすべて無意味なのです。

* サーバは、クライアントからのチャッターを受けずにチャンクを送信することができますが、各送信の間にわずかな遅延があります。これは、サーバーがネットワーク層で何が起こっているかを知る必要があり、大変な作業に思えます。また、レイヤリングもひどく崩れてしまいます。また、ネットワークはとても速いのに、クライアントが遅い場合はどうなるのでしょう？そのときチャンクはどこにキューイングされるのでしょうか？

* サーバーは、送信キューをスパイして、つまり、キューがどれくらいいっぱいかを見て、キューがいっぱいでないときだけ送信しようとすることができます。まあ、ZeroMQは、スロットリングが機能しないのと同じ理由で、機能しないので、それを許可しません。サーバーとネットワークは十分すぎるほど速いかもしれませんが、クライアントは遅い小さなデバイスかもしれません。

* HWM に到達したときに何か他のアクションをとるように <tt>libzmq</tt> を変更することができます。おそらくブロックできるのでは? それは、たった一人の遅いクライアントがサーバー全体をブロックすることを意味するので、結構です。呼び出し元にエラーを返すこともできるかもしれませんね。そうすれば、サーバーは何か賢いことができるかもしれない......まあ、メッセージを削除するよりも良いことは何もないんだけどね。

複雑で様々な不快感を与えるだけでなく、これらのオプションはどれも機能しない。必要なのは、クライアントがサーバーに対して、非同期かつバックグラウンドで、「もういいよ」と伝える方法です。ある種の非同期フローコントロールが必要なのです。これがうまくいけば、データはサーバーからクライアントに途切れることなく流れますが、クライアントが読んでいる間だけは、その流れが続きます。3つのプロトコルをおさらいしてみましょう。これは最初のものでした：

```
C: fetch
S: chunk 1
S: chunk 2
S: chunk 3
....
```

そして2つ目は、各チャンクに対するリクエストを紹介しました：

```
C: fetch chunk 1
S: send chunk 1
C: fetch chunk 2
S: send chunk 2
C: fetch chunk 3
S: send chunk 3
C: fetch chunk 4
....
```

さて--不思議なことに手を振っている--パフォーマンスの問題を解決する変更されたプロトコルはこちらです：

```
C: fetch chunk 1
C: fetch chunk 2
C: fetch chunk 3
S: send chunk 1
C: fetch chunk 4
S: send chunk 2
S: send chunk 3
....
```

怪しげなほど似ていますね。実際、各リクエストの応答を待たずに複数のリクエストを送信していること以外は同じです。これは「パイプライン」と呼ばれるテクニックで、DEALERとROUTERのソケットが完全に非同期であるため、うまくいくのです。

パイプラインを使ったファイル転送テストベンチの3番目のモデルです。クライアントは、先にリクエストの数（「クレジット」）を送信し、受信したチャンクを処理するたびに、さらにクレジットを1つ送信します。サーバーは、クライアントが要求した以上のチャンクを送ることはありません：

{{< examples name="fileio3" title="ファイル転送テスト、モデル3" >}}。

この調整により、送信側と受信側のすべてのネットワークバッファとZeroMQキューを含むエンドツーエンドのパイプラインを完全に制御することができます。パイプラインが常にデータで満たされ、あらかじめ定義された限界を超えて成長することがないようにするのです。さらに、クライアントが送信者に「クレジット」を送信するタイミングを正確に決定します。それは、チャンクを受信した時であったり、チャンクを完全に処理した時であったりします。そして、これは非同期で行われ、大きなパフォーマンスコストはかかりません。

3つ目のモデルでは、パイプラインのサイズを10メッセージにしました（各メッセージがチャンクです）。この場合、1クライアントあたり最大2.5MBのメモリが必要になります。つまり、1GBのメモリがあれば、少なくとも400クライアントを処理できることになります。理想的なパイプラインのサイズを計算してみましょう。1GBのファイルを送信するのにかかる時間は約0.7秒で、1チャンクの場合は約160マイクロ秒になります。往復で300マイクロ秒ですから、パイプラインは少なくとも3〜5チャンクでないと、サーバーが忙しくなります。実際には、5チャンクのパイプラインでもパフォーマンススパイクが発生しました。おそらく、クレジットメッセージが送信データによって遅延することがあるからでしょう。そのため、10チャンクにすると、安定して動作するようになりました。

```
$ time ./fileio3
4291 chunks received, 1072741824 bytes

real    0m0.777s
user    0m0.096s
sys     0m1.120s
```

厳密な計測をすること。計算ではよくても、現実の世界は独自の意見を持ちがちです。

私たちが作ったものは、明らかにまだ本当のファイル転送プロトコルではありませんが、このパターンを証明するものであり、最も単純なもっともらしいデザインだと思います。実際に動作するプロトコルのためには、以下のようなものを追加したいかもしれません：

* 認証とアクセス制御、暗号化なしでも：ポイントは機密データを保護することではなく、テストデータを本番サーバーに送るようなエラーを検出することです。

* ファイルパス、オプションの圧縮、その他HTTPから有用であることを学んだもの（If-Modified-Sinceなど）を含むCheap-style request。

* 少なくとも最初のチャンクは、ファイルサイズなどのメタデータを提供するCheapスタイルのレスポンス（クライアントが事前割り当てを行い、ディスクがいっぱいになるような不快な状況を回避できるように）。

* そうでなければ、プロトコルは小さなファイルの大規模なセットのために非効率的になる、一度にファイルのセットを取得する機能。

* ファイルを完全に受信したことをクライアントが確認することで、クライアントが予期せず切断された場合に失われる可能性のあるチャンクを回復することができます。

つまり、受信者は特定のファイルが必要であることを（何らかの方法で）知っているので、それを要求するのです。どのファイルがどこに存在するかという知識は、帯域外（HTTPやHTMLページ内のリンクなど）で受け渡されます。

プッシュ」セマンティックはどうでしょうか？これには、2つのもっともな使用例があります。まず、メインの「サーバー」にファイルを置く集中型アーキテクチャを採用する場合（私が提唱することではありませんが、人々は時々このようなことをします）、クライアントがサーバーにファイルをアップロードできるようにすると非常に便利です。第二に、クライアントがある種の新しいファイルをすべて要求し、サーバーがそれを受け取るとクライアントに転送するという、ファイルのpub-subのようなことが可能になります。

フェッチセマンティックは同期的であり、プッシュセマンティックは非同期的である。非同期はおしゃべりが少ないので、より高速です。また、「このパスを購読する」というようなかわいいこともできるので、Pub-Subのファイル転送アーキテクチャを作ることができます。これは明らかに素晴らしいことで、どんな問題を解決するのか説明する必要はないでしょう。

しかし、フェッチセマンティックの問題点はここにあります：クライアントにファイルの存在を伝えるための帯域外のルートです。どのようにしても、結局は複雑になってしまいます。クライアントがポーリングするか、クライアントを最新の状態に保つために別のpub-subチャンネルが必要になるか、ユーザーとの対話が必要になるかです。

しかし、もう少し考えてみると、fetchはpub-subの特殊なケースに過ぎないことがわかります。つまり、両者の長所を生かすことができるのです。以下が一般的な設計です：

* このパスをフェッチする
* ここにクレジットがある（繰り返す）。

これを機能させるためには（そして親愛なる読者の皆さん、私たちはそうします）、サーバにクレジットを送る方法についてもう少し明確にする必要があります。パイプラインで接続された「Fetch chunk」リクエストをクレジットとして扱うというかわいいトリックは、クライアントが実際に存在するファイルやそのサイズなどをもはや知らないため、通用しません。クライアントが「25万バイトのデータでいい」と言えば、25万バイトの1ファイルでも、2500バイトの100ファイルでも、同じように使えるはずです。

これにより、「クレジットベースのフロー制御」が可能になり、ハイウォーターマークが不要になり、メモリオーバーのリスクもなくなる。

## ステートマシン {#State-Machines}

ソフトウェアエンジニアは、（有限）ステートマシンを一種の中間的なインタプリタとして考える傾向があります。つまり、正規の言語を用いてそれをステートマシンにコンパイルし、そのステートマシンを実行するのです。ステートマシンそのものは、開発者が目にすることはほとんどなく、最適化され、圧縮された、奇妙な内部表現です。

しかし、ステートマシンは、プロトコルハンドラ（ZeroMQクライアントやサーバーなど）のファーストクラスのモデリング言語としても価値があることが判明した。ZeroMQはプロトコルを設計するのがとても簡単ですが、クライアントやサーバーを適切に書くための良いパターンを定義したことはありません。

プロトコルには少なくとも2つのレベルがあります：

* ワイヤ上で個々のメッセージをどのように表現するか。
* ピアの間でメッセージがどのように流れるか、そして各メッセージの重要性。

この章では、シリアライズを処理するコーデックの作り方について見てきました。これは良いスタートです。しかし、2つ目の仕事を開発者に任せてしまうと、開発者が解釈する余地が多くなってしまいます。より野心的なプロトコル（ファイル転送＋心拍数＋クレジット＋認証）を作るにつれ、クライアントとサーバーを手作業で実装しようとするのは、だんだんまともでなくなってきます。

そう、人々はほとんどシステマティックにこれを実行している。しかし、そのコストは高く、しかも避けることができるのです。ここでは、ステートマシンを使ってプロトコルをモデル化する方法と、そのモデルからきちんとしたコードを生成する方法について説明します。

私がソフトウェア構築ツールとしてステートマシンを使用した経験は、1985年、アプリケーション開発者向けのツールを作るという最初の実際の仕事に始まりました。1991年、私はその知識をLiberoというフリーソフトウェアのツールにまとめました。

Liberoのモデルで重要なのは、それが読めるということでした。つまり、プログラムのロジックを名前付きのステートとして記述し、それぞれが一連のイベントを受け入れ、実際の作業を行うのです。その結果、ステートマシンはアプリケーションコードにフックされ、まるでボスのように駆動するのです。

Liberoは魅力的なほど優秀で、多くの言語に精通しており、ステートマシンの謎めいた性質を考えると、そこそこ人気がありました。私たちは、Liberoを何十もの大規模な分散アプリケーションで怒涛のように使いましたが、そのうちの1つは、20年間の運用を経て、2011年についに停止されました。ステートマシン駆動のコード構築は非常にうまくいったので、このアプローチがソフトウェアエンジニアリングの主流になることがなかったのは、少々印象的です。

そこでこのセクションでは、Liberoのモデルについて説明し、それを使ってZeroMQクライアントとサーバーを生成する方法を紹介します。今回もGSLを使いますが、原理は一般的なものなので、どんなスクリプト言語でもコードジェネレータを作ることができます。

作業例として、ROUTERソケットでピアとステートフルなダイアログを行う方法を紹介します。サーバーはステートマシンを使って開発します（クライアントは手作業で）。NOM "と呼ぶ簡単なプロトコルがあります。私は、とても真面目な [keywords for unprotocols](http://unprotocols.org/blog:2) という提案を使っています：

```
nom-protocol    = open-peering *use-peering

open-peering    = C:OHAI ( S:OHAI-OK / S:WTF )

use-peering     = C:ICANHAZ
                / S:CHEEZBURGER
                / C:HUGZ S:HUGZ-OK
                / S:HUGZ C:HUGZ-OK
```

ステートマシン・プログラミングの本質を説明する手っ取り早い方法は見つかっていません。私の経験では、必ず数日の練習が必要です。3、4日このアイデアに触れると、脳の中の何かがすべてのピースを結びつける「カチッ！」という音が聞こえてきそうです。NOMサーバーのステートマシンを見て、それを具体化する。

ステートマシンの便利なところは、状態ごとに読むことができることです。各状態には、固有の記述名と1つ以上の*イベント*があり、それらを任意の順序でリストアップします。各イベントに対して、0個以上の*アクション*を実行し、*次の状態*に移行する（または同じ状態にとどまる）。

ZeroMQプロトコルサーバーでは、クライアントごとに1つのステートマシンインスタンスが存在します。これは複雑に聞こえますが、後で見るように、そうではありません。最初の状態である<tt>Start</tt>は、1つの有効なイベントを持つものとして説明します： <tt>OHAI</tt>です。ユーザーの認証情報をチェックし、Authenticated 状態に到達します。

{{< textdiagram name="fig64.png" figno="64" title="The Start State" >}}
.-------------------.
| Start             |
'-+-----------------'
  |
  #-------------#                    .-------------------.
  | OHAI        +------------------->| Authenticated     |
  #-------------#                    '-------------------'
                   Check Credentials
{{< /textdiagram >}}

<tt>認証情報の確認</tt>アクションは、<tt>ok</tt>または<tt>error</tt>イベントのいずれかを生成します。この2つの可能性のあるイベントを処理するために、クライアントに適切な応答を返すのがAuthenticated状態です。認証に失敗した場合は、<tt>Start</tt>状態に戻り、クライアントが再試行できるようにします。

{{< textdiagram name="fig65.png" figno="65" title="The Authenticated State" >}}
.-------------------.
| Authenticated     |
'-+-----------------'
  |
  #-------------#                    .-------------------.
  | ok          +------------------->| Ready             |
  #-------------#                    '-------------------'
  |                Send OHAI-OK
  |
  #-------------#                    .-------------------.
  | error       +------------------->| Start             |
  #-------------#                    '-------------------'
                   Send WTF
{{< /textdiagram >}}

認証が成功すると、Ready状態になります。ここでは、クライアントからのICANHAZやHUGZメッセージ、ハートビートタイマーイベントなど、3つのイベントが考えられます。

{{< textdiagram name="fig66.png" figno="66" title="The Ready State" >}}
.-------------------.
| Ready             |
'-+-----------------'
  |
  #-------------#                    .-------------------.
  | ICANHAZ     +------------------->| Ready             |
  #-------------#                    '-------------------'
  |                Send CHEEZBURGER
  |
  #-------------#                    .-------------------.
  | HUGZ        +------------------->| Ready             |
  #-------------#                    '-------------------'
  |                Send HUGZ-OK
  |
  #-------------#                    .-------------------.
  | heartbeat   +------------------->| Ready             |
  #-------------#                    '-------------------'
                   Send HUGZ
{{< /textdiagram >}}

このステートマシン・モデルには、さらに知っておくとよいことがいくつかあります：

* 大文字のイベント（"HUGZ "のような）は、クライアントからメッセージとして来る*外部イベント*である。
* 小文字のイベント（「heartbeat」のような）は、サーバー内のコードによって生成される*内部イベント*である。
* SOMETHING "アクションは、クライアントに特定の返答を返すための略記法です。
* 特定のステートで定義されていないイベントは、静かに無視されます。

さて、このきれいな絵の元となるのは、XMLモデルです：

```
<class name = "nom_server" script = "server_c">

<state name = "start">
    <event name = "OHAI" next = "authenticated">
        <action name = "check credentials" />
    </event>
</state>

<state name = "authenticated">
    <event name = "ok" next = "ready">
        <action name = "send" message ="OHAI-OK" />
    </event>
    <event name = "error" next = "start">
        <action name = "send" message = "WTF" />
    </event>
</state>

<state name = "ready">
    <event name = "ICANHAZ">
        <action name = "send" message = "CHEEZBURGER" />
    </event>
    <event name = "HUGZ">
        <action name = "send" message = "HUGZ-OK" />
    </event>
    <event name = "heartbeat">
        <action name = "send" message = "HUGZ" />
    </event>
</state>
</class>
```

コードジェネレータは<tt>examples/models/server_c.gsl</tt>の中にあります。これはかなり完成度の高いツールで、後でもっと本格的な作業のために使い、拡張するつもりです。これは生成します：

* プロトコルフロー全体を実装した C のサーバクラス (<tt>nom_server.c</tt>, <tt>nom_server.h</tt>) 。
* XML ファイルに記載されたセルフテストのステップを実行するセルフ テスト・メソッド。
* グラフィック(きれいな絵)の形のドキュメント。

以下は、生成された NOM サーバを起動する簡単なメインプログラムである：

{{< fragment name="nomserver" >}}
#include "czmq.h"
#include "nom_server.h"

int main (int argc, char *argv [])
{
    printf ("Starting NOM protocol server on port 5670...\n");
    nom_server_t *server = nom_server_new ();
    nom_server_bind (server, "tcp://*:5670");
    nom_server_wait (server);
    nom_server_destroy (&server);
    return 0;
}
{{< /fragment >}}

生成されたnom_serverクラスは、かなり古典的なモデルである。ROUTERソケットでクライアントメッセージを受け取るので、リクエストの最初のフレームはクライアントの接続IDになります。サーバはクライアントの集合を管理し、それぞれがステートを持つ。メッセージが到着すると、それをステートマシンに*イベント*としてフィードする。以下は、GSLコマンドと私たちが生成しようとするCコードの組み合わせによる、ステートマシンのコア部分です：

{{< fragment name="gsl-client-fsm" >}}
client_execute (client_t *self, int event)
{
    self->next_event = event;
    while (self->next_event) {
        self->event = self->next_event;
        self->next_event = 0;
        switch (self->state) {
.for class.state
            case $(name:c)_state:
.   for event
.       if index () > 1
                else
.       endif
                if (self->event == $(name:c)_event) {
.       for action
.           if name = "send"
                    zmsg_addstr (self->reply, "$(message:)");
.           else
                $(name:c)_action (self);
.           endif
.       endfor
.       if defined (event.next)
                    self->state = $(next:c)_state;
.       endif
                }
.   endfor
                break;
.endfor
        }
        if (zmsg_size (self->reply) > 1) {
            zmsg_send (&self->reply, self->router);
            self->reply = zmsg_new ();
            zmsg_add (self->reply, zframe_dup (self->address));
        }
    }
}
{{< /fragment >}}

各クライアントは、ステートマシンのインスタンスを表現するために必要な変数を含む、様々なプロパティを持つオブジェクトとして保持される：

{{< fragment name="fsm-instance" >}}
event_t next_event;         //  Next event
state_t state;              //  Current state
event_t event;              //  Current event
{{< /fragment >}}

もうお分かりだと思いますが、技術的に完璧なコードが生成され、私たちが望む正確なデザインと形状を備えています。<tt>nom_server</tt> クラスが手書きでないことを示す唯一の手がかりは、コードが *too good* であることです。コード生成ツールが貧弱なコードを生成すると文句を言う人は、貧弱なコード生成ツールに慣れているのです。私たちのモデルを必要に応じて拡張するのは簡単なことです。例えば、セルテストのコードを生成する方法は次のとおりです。

まず、ステートマシンに「selftest」アイテムを追加し、テストを記述します。XMLの文法や検証は一切使っていないので、エディタを開いて半ダースのテキストを追加するだけである：

```
<selftest>
    <step send = "OHAI" body = "Sleepy" recv = "WTF" />
    <step send = "OHAI" body = "Joe" recv = "OHAI-OK" />
    <step send = "ICANHAZ" recv = "CHEEZBURGER" />
    <step send = "HUGZ" recv = "HUGZ-OK" />
    <step recv = "HUGZ" />
</selftest>
```

その場でデザインしてみると、"send "と "recv "は「このリクエストを送ったら、この返答を期待する」ということを表現するのに適していると思いました。このモデルを実際のコードにするGSLコードは以下の通りです：

```
.for class->selftest.step
.   if defined (send)
    msg = zmsg_new ();
    zmsg_addstr (msg, "$(send:)");
.       if defined (body)
    zmsg_addstr (msg, "$(body:)");
.       endif
    zmsg_send (&msg, dealer);

.   endif
.   if defined (recv)
    msg = zmsg_recv (dealer);
    assert (msg);
    command = zmsg_popstr (msg);
    assert (streq (command, "$(recv:)"));
    free (command);
    zmsg_destroy (&msg);

.   endif
.endfor
```

最後に、より厄介な、しかし、どんなステートマシン生成器でも絶対に必要な部分の1つは、*どのように私はこれを私自身のコードにプラグインするのでしょうか？少し考えた後、ステートマシンモデルから直接コードを取得する、つまり、XMLファイルにアクションボディを埋め込むことにしました。だから<tt>nom_server.xml</tt>の中に、こんなのがあります：

```
<action name = "check credentials">
    char *body = zmsg_popstr (self->request);
    if (body && streq (body, "Joe"))
        self->next_event = ok_event;
    else
        self->next_event = error_event;
    free (body);
</action>
```

そして、コードジェネレータはその C コードを取得し、生成された <tt>nom_server.c</tt> ファイルに挿入しています：

```
.for class.action
static void
$(name:c)_action (client_t *self) {
$(string.trim (.):)
}
.endfor
```

サーバーのステートマシンを記述し、アクションのネイティブ実装を含む1つのソースファイルが完成しました。高水準と低水準のいいとこ取りで、Cコードに比べて約90%も小さくなっています。

しかし、このような活用をすると、どんな素晴らしいものができるのか、頭の中がぐるぐると回ってしまうので、注意してください。このアプローチは、本当の力を与えてくれる反面、仲間から遠ざかり、行き過ぎると一人で仕事をしていることになる。

ところで、このシンプルで小さなステートマシンの設計では、カスタムコードに3つの変数を公開するだけです：

<tt>self->next_event</tt> です。
* <tt>self->next_event</tt> * <tt>self->request</tt>
<tt>self->next_event</tt> * <tt>self->request</tt> * <tt>self->reply</tt>

Liberoのステートマシンモデルでは、ここでは使用していませんが、より大きなステートマシンを書くときに必要となる概念がいくつかあります：

* 例外は、より大きなステートマシンを書くことができます。あるアクションが例外を発生させると、そのイベントに対するそれ以上の処理は停止します。ステートマシンは、例外イベントをどのように処理するかを定義することができます。
<tt>Defaults</tt> 状態では、イベントに対するデフォルトの処理を定義することができます(特に例外イベントに対して有用です)。

## SASL による認証 {#Authentication-Using-SASL}

2007年にAMQPを設計したとき、認証レイヤーに[Simple Authentication and Security Layer](http://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer) (SASL) を選択しました。これは、[BEEP protocol framework](http://www.rfc-editor.org/rfc/rfc3080.txt) から取り入れたアイデアの1つでした。SASLは一見複雑そうに見えますが、実はシンプルで、ZeroMQベースのプロトコルにすっきりと収まるのです。私がSASLで特に気に入っているのは、スケーラブルであることです。匿名アクセスやプレーンテキスト認証など、セキュリティのない状態から始めて、プロトコルを変更することなく、時間をかけてより安全なメカニズムに成長させることができます。

SASLを実際に使うのはもう少し後になるので、今は深い説明をするつもりはない。しかし、その原理を説明することで、すでにある程度の準備はできているはずです。

NOMプロトコルでは、クライアントはOHAIコマンドで開始し、サーバーはそれを受け入れるか（「Hi Joe！」）、拒否するかしていました。これはシンプルですが、サーバーとクライアントが行う認証のタイプについて前もって合意する必要があるため、スケーラブルではありません。

SASLが導入したのは天才的で、完全に抽象化され、交渉可能なセキュリティ層であり、プロトコルレベルでの実装がまだ容易であることです。その仕組みは次の通りです：

* クライアントが接続する。
* サーバーはクライアントに挑戦し、それが知っているセキュリティ「メカニズム」のリストを渡します。
* クライアントは、それが知っているセキュリティメカニズムを選択し、不透明なデータのブロブでサーバーの挑戦に答える（そしてここで巧妙なトリックです）いくつかの汎用セキュリティライブラリが計算し、クライアントに与える。
* サーバーは、クライアントが選んだセキュリティ機構と、そのデータの塊を受け取り、それを自分のセキュリティライブラリに渡します。
* そのライブラリはクライアントの答えを受け入れるか、サーバーが再度チャレンジします。

フリーのSASLライブラリはいくつもあります。実際のコードでは、特別なライブラリを必要としないANONYMOUSとPLAINという2つのメカニズムだけを実装することになる。

SASLをサポートするためには、「open-peering」フローにオプションでチャレンジ/レスポンスのステップを追加する必要があります。その結果、プロトコルの文法は次のようになります（私はこれを行うためにNOMを修正しています）：

```
secure-nom      = open-peering *use-peering

open-peering    = C:OHAI *( S:ORLY C:YARLY ) ( S:OHAI-OK / S:WTF )

ORLY            = 1*mechanism challenge
mechanism       = string
challenge       = *OCTET

YARLY           = mechanism response
response        = *OCTET
```

ORLYとYARLYは、文字列（ORLYではメカニズムのリスト、YARLYでは1つのメカニズム）と不透明なデータのブロブを含んでいます。メカニズムによっては、サーバーからの最初のチャレンジは空である可能性があります。我々は気にしない：我々はこれをセキュリティライブラリに渡して処理させるだけである。

SASL [RFC](http://tools.ietf.org/html/rfc4422)は、他の機能(私たちには必要ない)や、SASLが攻撃される可能性のある種類の方法などについて詳しく述べています。

## 大規模ファイル公開: FileMQ {#Large-Scale-File-Publishing-FileMQ}

これらのテクニックをまとめて、FileMQと呼ぶファイル配布システムにしましょう。これは、[GitHub](https://github.com/zeromq/filemq)上で生きている、実際の製品になる予定です。ここで作るのは、トレーニングツールとしてのFileMQの最初のバージョンです。コンセプトがうまくいけば、本物はいずれ自分の本ができるかもしれません。

### なぜFileMQを作るのか？ {#Why-make-FileMQ}

なぜファイル配布システムを作るのか？ZeroMQで大きなファイルを送る方法はすでに説明しましたが、これは本当に簡単なことなんです。しかし、ZeroMQを使える人の100万倍以上の人がメッセージングにアクセスできるようにしたいのであれば、別の種類のAPIが必要です。私の5歳の息子でも理解できるようなAPIです。ユニバーサルで、プログラミングが不要で、あらゆるアプリケーションで動作するAPIです。

そう、ファイルシステムの話です。DropBoxのように、ファイルをどこかに置いておくと、ネットワークがつながったときに魔法のように別の場所にコピーされるというパターンです。

しかし、私が目指しているのは、gitに似た完全な分散型アーキテクチャで、クラウドサービスを必要とせず（FileMQをクラウドに置くことはできますが）、マルチキャスト、つまり一度に多くの場所にファイルを送ることができるものなのです。

FileMQは、セキュアであること（可能であること）、ランダムなスクリプト言語に簡単にフックできること、国内とオフィスのネットワークで可能な限り高速であることが求められます。

WiFi経由で携帯電話からノートパソコンに写真をバックアップするのに使いたい。会議中に50台のノートパソコンでプレゼンテーションのスライドをリアルタイムで共有したい。会議で同僚とドキュメントを共有したい。センサーから中央のクラスターに地震データを送信する。デモや暴動で撮影した私の携帯電話のビデオをバックアップする。Linuxサーバーのクラウド上で設定ファイルを同期させる。

先見の明があるアイデアですね？まあ、アイデアは安いものです。難しいのは、これを作ること、そしてそれをシンプルにすることです。

### 初期設計のカット：API {#Initial-Design-Cut-the-API}

最初のデザインはこんな感じです。FileMQは分散型でなければなりません。つまり、すべてのノードがサーバーであり、同時にクライアントでもあり得るということです。でも、プロトコルを左右対称にするのは、無理矢理感があるので嫌なんです。A地点からB地点への自然なファイルの流れがあり、Aが「サーバー」、Bが「クライアント」です。もしファイルが逆に流れてきたら、2つの流れがあることになります。FileMQはまだディレクトリ同期プロトコルではありませんが、私たちはそれをかなり近づけます。

したがって、FileMQをクライアントとサーバーの2つのピースとして構築することにします。そして、クライアントとしてもサーバーとしても動作するメイン アプリケーション (<tt>filemq</tt> ツール) にこれらをまとめようと思います。この2つのピースは、<tt>nom_server</tt>とよく似ていて、同じようなAPIを持つことになります：

{{< fragment name="filemq-main" >}}
fmq_server_t *server = fmq_server_new ();
fmq_server_bind (server, "tcp://*:5670");
fmq_server_publish (server, "/home/ph/filemq/share", "/public");
fmq_server_publish (server, "/home/ph/photos/stream", "/photostream");

fmq_client_t *client = fmq_client_new ();
fmq_client_connect (client, "tcp://pieter.filemq.org:5670");
fmq_client_subscribe (server, "/public/", "/home/ph/filemq/share");
fmq_client_subscribe (server, "/photostream/", "/home/ph/photos/stream");

while (!zctx_interrupted)
    sleep (1);

fmq_server_destroy (&server);
fmq_client_destroy (&client);
{{< /fragment >}}

このC言語のAPIを他の言語でラップすれば、FileMQのスクリプト化、アプリケーションの組み込み、スマートフォンへの移植などが簡単にできるようになる。

### 初期設計カット：プロトコル {#Initial-Design-Cut-the-Protocol}

プロトコルの正式名称は「File Message Queuing Protocol」、ソフトウェアと区別するために大文字で「FILEMQ」とします。まず、プロトコルをABNF文法で記述します。まず、クライアントとサーバーの間のコマンドの流れから説明します。これらは、これまで見てきた様々なテクニックの組み合わせであることがわかるはずです：

```
filemq-protocol = open-peering *use-peering [ close-peering ]

open-peering    = C:OHAI *( S:ORLY C:YARLY ) ( S:OHAI-OK / error )

use-peering     = C:ICANHAZ ( S:ICANHAZ-OK / error )
                / C:NOM
                / S:CHEEZBURGER
                / C:HUGZ S:HUGZ-OK
                / S:HUGZ C:HUGZ-OK

close-peering   = C:KTHXBAI / S:KTHXBAI

error           = S:SRSLY / S:RTFM
```

以下は、サーバーとのコマンドのやり取りです：

```
;   The client opens peering to the server
OHAI            = signature %x01 protocol version
signature       = %xAA %xA3
protocol        = string        ; Must be "FILEMQ"
string          = size *VCHAR
size            = OCTET
version         = %x01

;   The server challenges the client using the SASL model
ORLY            = signature %x02 mechanisms challenge
mechanisms      = size 1*mechanism
mechanism       = string
challenge       = *OCTET        ; ZeroMQ frame

;   The client responds with SASL authentication information
YARLY           = %signature x03 mechanism response
response        = *OCTET        ; ZeroMQ frame

;   The server grants the client access
OHAI-OK         = signature %x04

;   The client subscribes to a virtual path
ICANHAZ         = signature %x05 path options cache
path            = string        ; Full path or path prefix
options         = dictionary
dictionary      = size *key-value
key-value       = string        ; Formatted as name=value
cache           = dictionary    ; File SHA-1 signatures

;   The server confirms the subscription
ICANHAZ-OK      = signature %x06

;   The client sends credit to the server
NOM             = signature %x07 credit
credit          = 8OCTET        ; 64-bit integer, network order
sequence        = 8OCTET        ; 64-bit integer, network order

;   The server sends a chunk of file data
CHEEZBURGER     = signature %x08 sequence operation filename
                  offset headers chunk
sequence        = 8OCTET        ; 64-bit integer, network order
operation       = OCTET
filename        = string
offset          = 8OCTET        ; 64-bit integer, network order
headers         = dictionary
chunk           = FRAME

;   Client or server sends a heartbeat
HUGZ            = signature %x09

;   Client or server responds to a heartbeat
HUGZ-OK         = signature %x0A

;   Client closes the peering
KTHXBAI         = signature %x0B
```

また、サーバーがクライアントに伝えることのできるさまざまな方法を以下に示します：

```
;   Server error reply - refused due to access rights
S:SRSLY         = signature %x80 reason

;   Server error reply - client sent an invalid command
S:RTFM          = signature %x81 reason
```

FILEMQ は [ZeroMQ unprotocols website](http://rfc.zeromq.org/spec:19) に存在し、IANA (the Internet Assigned Numbers Authority) に登録された TCP ポートは 5670 番ポートである。

### FileMQの構築と試行 {#Building-and-Trying-FileMQ}

FileMQスタックは[GitHub](https://github.com/zeromq/filemq)にあります。古典的なC/C++のプロジェクトのように動作します：

```
git clone git://github.com/zeromq/filemq.git
cd filemq
./autogen.sh
./configure
make check
```

これには最新のCZMQマスターを使いたいところです。では、<tt>track</tt>コマンドを実行してみてください。これは、FileMQを使って、あるディレクトリの変更を別のディレクトリで追跡するシンプルなツールです：

```
cd src
./track ./fmqroot/send ./fmqroot/recv
```

そして、2つのファイルナビゲータウィンドウを開き、1つは <tt>src/fmqroot/send</tt> に、1つは <tt>src/fmqroot/recv</tt> に入れます。sendフォルダにファイルをドロップすると、recvフォルダにファイルが届くのを確認できます。サーバーは1秒に1回、新しいファイルがあるかどうかをチェックします。sendフォルダのファイルを削除すると、recvフォルダでも同様に削除されます。

私は、USBドライブとしてマウントしたMP3プレーヤーのアップデートなどにtrackを使用しています。ノートパソコンのMusicフォルダーにファイルを追加したり削除したりすると、MP3プレーヤーでも同じように変更が行われます。FILEMQはまだ完全なレプリケーション・プロトコルではありませんが、これは後で修正します。

### 内部アーキテクチャ {#Internal-Architecture}

FileMQを構築するために、私は多くのコードジェネレータを使用しました。チュートリアルには多すぎるかもしれません。しかし、これらのコードジェネレータはすべて他のスタックで再利用可能であり、[第8章 分散コンピューティングのためのフレームワーク](chapter8#moving-pieces)の最終プロジェクトにとって重要なものとなっています。これらは、以前に見たセットの進化版です：

* <tt>codec_c.gsl</tt>: 与えられたプロトコルのためのメッセージコーデックを生成します。
* <tt>server_c.gsl</tt>: プロトコルとステートマシンのためのサーバクラスを生成します。
* <tt>client_c.gsl</tt>: プロトコルとステートマシンのためのクライアントクラスを生成します。

GSLコード生成の使い方を学ぶには、これらを自分の好きな言語に翻訳して、自分のデモプロトコルやスタックを作るのが一番です。かなり簡単なことがわかるはずです。FileMQ 自身は多言語をサポートしようとはしていません。できるかもしれませんが、不必要に複雑になってしまうからです。

FileMQのアーキテクチャは、実際には2つのレイヤーに分かれています。チャンク、ディレクトリ、ファイル、パッチ、SASLセキュリティ、設定ファイルなどを扱う一般的なクラスのセットがある。そして、生成されたスタック（メッセージ、クライアント、サーバー）があります。もし私が新しいプロジェクトを作るとしたら、FileMQプロジェクト全体をフォークして、3つのモデルを修正します：

* <tt>fmq_msg.xml</tt>: メッセージのフォーマットを定義しています。
* <tt>fmq_msg.xml</tt>: メッセージのフォーマットを定義しています。
* <tt>fmq_server.xml</tt>: サーバーについても同様です。

混乱を避けるために名前を変えたくなるものです。なぜ、再利用可能なクラスを別のライブラリにしなかったのでしょうか？その答えは2つあります。まず、実際にこれを必要とする人がいない（まだ）。第二に、FileMQを構築して遊んでいるあなたにとって、物事をより複雑にすることになるからです。理論的な問題を解決するために複雑さを増すのは、決して無駄なことではありません。

私はFileMQをC言語で書きましたが、他の言語へのマッピングは簡単です。CZMQの汎用的なzlistやzhashコンテナ、クラススタイルを追加すると、C言語がこんなに素敵になるとは、とても驚きです。早速、クラスを見ていきましょう：

* <tt>fmq_sasl</tt>: SASLチャレンジのエンコードとデコードを行います。PLAINメカニズムだけを実装しましたが、これはコンセプトを証明するのに十分なものです。

* <tt>fmq_chunk</tt>: 可変サイズのブロブで動作します。ZeroMQのメッセージほど効率的ではありませんが、奇妙なことをすることが少ないので、理解しやすくなっています。チャンククラスは、ディスクからチャンクを読み書きするメソッドを持っています。

* <tt>fmq_file</tt>: ディスク上に存在するかしないかわからないファイルを扱います。ファイルに関する情報(サイズなど)を提供し、ファイルへの読み書き、ファイルの削除、ファイルが存在するかどうかのチェック、ファイルが「安定」しているかどうかのチェック(これについては後で詳しく説明します)を行うことができます。

* <tt>fmq_dir</tt>: ディレクトリを扱い、ディスクから読み込み、2つのディレクトリを比較して、何が変更されたかを確認します。変更があった場合、"パッチ "のリストを返します。

* <tt>fmq_patch</tt>: 1つのパッチを扱いますが、実際には「このファイルを作成する」「このファイルを削除する」というだけです(毎回 fmq_file の項目を参照します)。

* <tt>fmq_config</tt>: コンフィギュレーションデータを扱います。クライアントとサーバーの設定については、また後日紹介します。

すべてのクラスにはテストメソッドがあり、主な開発サイクルは「編集、テスト」です。これらはほとんど単純な自己テストですが、信頼できるコードとまだ壊れることがわかっているコードとの違いを生み出します。テストケースでカバーされていないコードには、未発見のエラーがあることは間違いない。私は外部のテストハーネスが好きなわけではありません。しかし、機能を書くときに書く内部テストコードは、ナイフの柄のようなものです。

ソースコードを読んで、これらのクラスが何をしているのかを迅速に理解できるようになる必要があります。もし、楽しくコードを読めないのなら、教えてください。FileMQの実装を他の言語に移植したい場合は、リポジトリ全体をフォークすることから始め、後で1つの全体的なリポジトリでこれを行うことが可能かどうかを確認することになります。

### パブリック API {#Public-API}

パブリックAPIは2つのクラスから構成されています(以前にスケッチしたとおりです)：

* <tt>fmq_client</tt>: クライアント API を提供し、サーバへの接続、クライアントの設定、パスの購読を行うメソッドを持ちます。

* <tt>fmq_server</tt>: サーバー API を提供し、ポートにバインドし、サーバーを設定し、パスを公開するメソッドを提供します。

これらのクラスは*マルチスレッドAPI*を提供し、これまで何度か使用してきたモデルです。APIインスタンスを作成するとき（つまり<tt>fmq_server_new()</tt>または<tt>fmq_client_new()</tt>）、このメソッドは実際の作業、つまりサーバーまたはクライアントを実行するバックグラウンドスレッドをキックオフします。他のAPIメソッドは、ZeroMQソケット（inproc://を介した2つのPAIRソケットからなる*パイプ*）を介してこのスレッドに話しかけます。

もし私が他の言語でFileMQを使いたいという熱心な若い開発者だったら、この公開APIのバインディングを週末に書いて、filemqプロジェクトの<tt>bindings/</tt>というサブディレクトリに貼り付けて、プルリクエストをすることでしょうね。

実際のAPIメソッドは、ステートマシンの記述から、次のように得られます（サーバーの場合）：

```
<method name = "publish">
<argument name = "location" type = "string" />
<argument name = "alias" type = "string" />
mount_t *mount = mount_new (location, alias);
zlist_append (self->mounts, mount);
</method>
```

このようなコードになります：

{{< fragment name="fmq-server-methods" >}}
void
fmq_server_publish (fmq_server_t *self, char *location, char *alias)
{
    assert (self);
    assert (location);
    assert (alias);
    zstr_sendm (self->pipe, "PUBLISH");
    zstr_sendfm (self->pipe, "%s", location);
    zstr_sendf (self->pipe, "%s", alias);
}
{{< /fragment >}}

### デザインノート {#Design-Notes}

FileMQを作る上で一番大変だったのは、プロトコルの実装ではなく、内部で正確な状態を維持することでした。FTPやHTTPのサーバーは、基本的にステートレスです。しかし、パブリッシュ/サブスクライブサーバーは、少なくともサブスクリプションを維持する必要がある*。

そこで、設計の面をいくつか見ていくことにします：

* クライアントは、サーバーからのハートビート（<tt>HUGZ</tt>）の欠如によって、サーバーが死んだかどうかを検出する。そして、<tt>OHAI</tt>を送信することによって、ダイアログを再開します。ZeroMQ DEALERソケットは送信メッセージを無限にキューに入れるので、<tt>OHAI</tt>にタイムアウトはありません。

* クライアントがサーバーが送信するハートビートに対して(<tt>HUGZ-OK</tt>)で応答しなくなった場合、サーバーはクライアントが死んだと判断し、サブスクリプションを含むクライアントのすべての状態を削除します。

* クライアントAPIはサブスクリプションをメモリに保持し、正常に接続されたときにそれらを再生します。つまり、呼び出し元はいつでもサブスクライブできる（接続や認証が実際に行われるタイミングを気にしない）。

* サーバとクライアントは、HTTPやFTPサーバと同じように仮想パスを使用します。あなたは、サーバー上のディレクトリに対応する1つまたは複数の*マウントポイント*を公開します。マウントポイントが1つしかない場合は「/」のように、それぞれが仮想パスにマッピングされます。クライアントは仮想パスを購読し、ファイルは受信トレイのディレクトリに到着します。物理的なファイル名をネットワーク上に送信することはありません。

* クライアントが接続してサブスクライブしている間にサーバーがマウントポイントを作成すると、サブスクリプションが正しいマウントポイントにアタッチされないというタイミングの問題があります。そのため、最後にサーバーのポートをバインドしています。

* クライアントが<tt>OHAI</tt>を送信すると、以前の会話の終了と新しい会話の開始を知らせます。私はいつか、サーバー上でサブスクリプションを耐久性のあるものにするかもしれないので、切断されても生き残ることができます。クライアント スタックは、再接続後、呼び出し元アプリケーションがすでに作成したすべてのサブスクリプションをリプレイします。

### 設定 {#Configuration}

私は、90年代後半に流行したXitami Webサーバーや[OpenAMQメッセージングサーバー](http://www.openamq.org)などの大規模サーバー製品をいくつか構築してきました。設定を簡単かつ明白にすることが、これらのサーバーを楽しく使うための大きなポイントでした。

私たちは通常、いくつかの問題を解決することを目標としています：

* 製品にデフォルトの設定ファイルを同梱する。
* ユーザがカスタム設定ファイルを追加できるようにし、決して上書きされないようにする。
* ユーザがコマンドラインから設定できるようにする。

そして、コマンドラインでの設定がカスタム設定を上書きし、カスタム設定がデフォルト設定を上書きするように、これらを1つずつ重ねていく。これを正しく行うには、かなりの労力が必要です。FileMQの場合は、APIからすべての設定を行うという、ややシンプルなアプローチをとっています。

たとえば、このようにサーバーを起動し、設定するのです：

{{< fragment name="fmq-server-api" >}}
server = fmq_server_new ();
fmq_server_configure (server, "server_test.cfg");
fmq_server_publish (server, "./fmqroot/send", "/");
fmq_server_publish (server, "./fmqroot/logs", "/logs");
fmq_server_bind (server, "tcp://*:5670");
{{< /fragment >}}

[ZPL](http://rfc.zeromq.org/spec:4)という最小限の構文で、数年前にZeroMQの「デバイス」に使い始めましたが、どのサーバーでもうまく機能するもので、設定ファイルには特定の形式を使用しています：

```
#   Configure server for plain access
#
server
    monitor = 1             #   Check mount points
    heartbeat = 1           #   Heartbeat to clients

publish
    location = ./fmqroot/logs
    virtual = /logs

security
    echo = I: use guest/guest to login to server
    #   These are SASL mechanisms we accept
    anonymous = 0
    plain = 1
        account
            login = guest
            password = guest
            group = guest
        account
            login = super
            password = secret
            group = admin
```

生成されたサーバーコードが行うかわいいこと(便利そう)は、(<tt>fmq_server_configure()</tt>メソッドを使ったときに)この設定ファイルを解析して、APIメソッドと一致するセクションを実行することです。したがって、<tt>publish</tt>セクションは<tt>fmq_server_publish()</tt>メソッドとして動作します。

### ファイルの安定性{#File-Stability}。

ディレクトリに変更がないかポーリングし、新しいファイルに対して何か「面白い」ことをするのはよくあることです。しかし、あるプロセスがファイルに書き込んでいるとき、他のプロセスにはファイルが完全に書き込まれたタイミングがわかりません。1つの解決策は、最初のファイルを作成した後に作成する2番目の「指標」ファイルを追加することです。しかし、これは邪魔になります。

もっと簡単な方法があります。それは、ファイルが「安定」したとき、つまり、誰も書き込まなくなったときを検出することです。FileMQは、ファイルの修正時間をチェックすることでこれを実現します。1秒以上経過していれば、そのファイルは安定していると判断され、少なくともクライアントに出荷できるほどには安定していることになります。5分後にプロセスがやってきてファイルに追加された場合、そのファイルは再び出荷されることになる。

これは、FileMQをうまく使いたいアプリケーションの必須条件ですが、書き込み前に1秒分以上のデータをメモリにバッファリングしないでください。非常に大きなブロックサイズを使用すると、ファイルが安定しているように見えても、そうでない場合があります。

### 配信通知 {#配信通知}」。

私たちが使用しているマルチスレッドAPIモデルの良い点の1つは、基本的にメッセージベースであることです。このため、イベントを呼び出し元に返すのに適しています。より一般的なAPIアプローチは、コールバックを使用することです。しかし、スレッドの境界を越えるコールバックは、ややデリケートです。以下は、クライアントが完全なファイルを受信したときに、メッセージを送り返す方法です：

{{< fragment name="send-deliver" >}}
zstr_sendm (self->pipe, "DELIVER");
zstr_sendm (self->pipe, filename);
zstr_sendf (self->pipe, "%s/%s", inbox, filename);
{{< /fragment >}}

これで、クライアントから戻ってくるイベントを待つ_recv()メソッドをAPIに追加することができます。クライアント・オブジェクトを作成し、それを設定し、それが返すイベントを受信して処理するという、呼び出し側にとってクリーンなスタイルになります。

### シンボリックリンク{#Symbolic-Links}」です。

ステージング・エリアを使用することは、シンプルで良いAPIですが、送信者にとってはコストも発生します。カメラに 2GB のビデオファイルがあり、それを FileMQ で送信したい場合、現在の実装では、購読者に送信する前にステージング・エリアにコピーするよう要求されます。

コンテンツ ディレクトリ全体 (<tt>/home/me/Movies</tt> など) をマウントすることもできますが、これはアプリケーションが個々のファイルの送信を決定できないことを意味するため、壊れやすいと言えます。すべてか何もないかです。

簡単な答えは、ポータブル シンボリック リンクを実装することです。Wikipediaの説明によると 「シンボリックリンクは、オペレーティングシステムが自動的に解釈し、別のファイルまたはディレクトリへのパスとして従うテキスト文字列を含んでいます。この他のファイルやディレクトリは、*ターゲット*と呼ばれます。シンボリックリンクは、ターゲットとは独立して存在する第2のファイルです。シンボリックリンクが削除された場合、そのターゲットは影響を受けずに残ります。"

これはプロトコルに何ら影響を与えるものではなく、サーバーの実装における最適化である。簡単なポータブル実装をしてみましょう：

* シンボリックリンクは、<tt>.ln</tt>という拡張子を持つファイルから構成されています。
<tt>.ln</tt>を除いたファイル名が公開ファイル名となります。
* リンクファイルには1行が含まれ、これがファイルへの実際のパスとなります。

ファイルに対するすべての操作を1つのクラス(<tt>fmq_file</tt>)に集めたので、すっきりとした変更になりました。新しいファイル オブジェクトを作成するときに、それがシンボリック リンクであるかどうかをチェックし、すべての読み取り専用アクション (ファイル サイズの取得、ファイルの読み取り) は、リンクではなくターゲット ファイルに対して操作します。

### リカバリーとレイトジョイナー{#Recovery-and-Late-Joiners}」。

現在のところ、FileMQには1つの大きな問題が残っています。それは、クライアントが障害から回復する方法を提供していないことです。シナリオは、サーバーに接続されたクライアントがファイルの受信を開始し、何らかの理由で切断されるというものです。ネットワークが遅かったり、壊れたりすることもあります。クライアントがノートパソコンで、シャットダウンされ、その後再開される。WiFiが切断された。私たちがよりモバイルな世界に移行するにつれ（「第8章 分散コンピューティングのためのフレームワーク」（chapter8#moving-pieces）参照）、このユースケースはますます頻繁に起こるようになりました。ある意味、支配的なユースケースになりつつあります。

古典的なZeroMQのpub-subパターンでは、2つの強い前提があり、FileMQの現実世界ではその両方が通常間違っています。まず、データの有効期限は非常に早いので、古いデータから問い合わせることに興味はない。第二に、ネットワークは安定しており、滅多に壊れない（そのため、インフラの改善に多くを投資し、復旧にはあまり投資しない方が良い）。

FileMQのユースケースを見てみると、クライアントが接続を解除して再接続すれば、取りこぼしたデータをすべて取得できることがわかります。さらに改良すれば、HTTPやFTPのように、部分的な障害から回復できるようになるでしょう。しかし、一度に1つのことをするのです。

FILEMQプロトコルの最初のドラフトでは、サーバーがクライアントの識別子を保持・保存することで、「耐久性のあるサブスクリプション」をサポートすることを目的としていました。そのため、障害が発生した後にクライアントが再び現れた場合、サーバーはどのファイルを受信していないのかを知ることができます。

しかし、ステートフルサーバーは、作るのが大変で、規模を拡大するのも難しい。例えば、セカンダリサーバーへのフェイルオーバーはどうするのか？セカンダリーサーバーはどこからサブスクリプションを取得するのでしょうか？各クライアント接続が独立して動作し、必要なステートをすべて持ち運べる方がずっといい。

耐久性のあるサブスクリプションのもう一つの難点は、前もっての調整が必要なことです。前もっての調整は、それが一緒に働く人々のチームであろうと、互いに会話するプロセスの束であろうと、常に赤旗です。後発組の場合はどうでしょう？現実の世界では、顧客はきれいに整列して、全員が同時に「準備完了！」と言うわけではありません。現実の世界では、クライアントは恣意的に出入りしています。

これに対処するために、私はプロトコルに 2 つの概念を追加します。*resynchronization* オプションと <tt>cache</tt> フィールド (辞書) です。クライアントが回復を望む場合、再同期オプションを設定し、<tt>cache</tt> フィールドを介して、すでに持っているファイルをサーバーに知らせます。空のフィールドとヌル フィールドを区別する方法がプロトコルにはないため、両方が必要です。FILEMQ RFC では、これらのフィールドを次のように説明しています：

<tt>options</tt> フィールドは、サーバーに追加情報を提供します。サーバーはこれらのオプションを実装すべきです(SHOULD)： <tt>RESYNC=1</tt> - クライアントがこれを設定した場合、サーバーは仮想パスの全内容をクライアントに送信しなければなりません。ただし、<tt>cache</tt>フィールドのSHA-1ダイジェストで特定される、クライアントがすでに持っているファイルは除きます。

とある：

> クライアントが<tt>RESYNC</tt>オプションを指定すると、<tt>cache</tt>辞書フィールドは、クライアントがすでに持っているファイルをサーバに知らせます。<tt>cache</tt>辞書の各エントリは、「filename=digest」キーと値のペアであり、digestは印刷可能な16進数形式のSHA-1ダイジェストでなければならない（SHALL）。ファイル名が「/」で始まる場合は、パスで始まるべきであり、そうでない場合はサーバーはそれを無視しなければならない(MUST)。ファイル名が"/"で始まらない場合、サーバーはそれをパスに対する相対的なものとして扱わなければならない(SHALL)。

古典的なpub-subユースケースであることを知っているクライアントは、キャッシュデータを提供しないだけであり、回復を望むクライアントは、キャッシュデータを提供する。これは、サーバーの状態や事前の調整を必要とせず、全く新しいクライアント（帯域外の手段でファイルを受け取った可能性がある）でも、いくつかのファイルを受け取った後にしばらく接続が切れたクライアントでも同じように機能する。

私がSHA-1ダイジェストを使うことにしたのには、いくつかの理由があります。第一に、十分に高速であること。私のノートパソコンで25MBのコアダンプを消化するのに150msecです。第二に、信頼性が高い。1つのファイルの異なるバージョンで同じハッシュを得る確率は、ゼロに近い。第三に、最も広くサポートされているダイジェスト・アルゴリズムであることです。巡回冗長検査（CRC-32など）は、より高速ですが、信頼性はありません。最近のSHAバージョン（SHA-256、SHA-512）はより安全ですが、CPUサイクルが50％以上かかり、我々のニーズにはオーバーキルです。

キャッシュと再同期の両方を使用した場合の典型的なICANHAZメッセージは次のようになります（これは生成されたコーデッククラスの<tt>dump</tt>メソッドから出力されたものです）：

```
ICANHAZ:
    path='/photos'
    options={
        RESYNC=1
    }
    cache={
        DSCF0001.jpg=1FABCD4259140ACA99E991E7ADD2034AC57D341D
        DSCF0006.jpg=01267C7641C5A22F2F4B0174FFB0C94DC59866F6
        DSCF0005.jpg=698E88C05B5C280E75C055444227FEA6FB60E564
        DSCF0004.jpg=F0149101DD6FEC13238E6FD9CA2F2AC62829CBD0
        DSCF0003.jpg=4A49F25E2030B60134F109ABD0AD9642C8577441
        DSCF0002.jpg=F84E4D69D854D4BF94B5873132F9892C8B5FA94E
    }
```

FileMQではこのようなことはしませんが、サーバーはキャッシュ情報を使って、クライアントが見逃した削除に追いつくのを助けることができます。これを行うには、削除のログを記録し、クライアントが購読したときにこのログとクライアントキャッシュを比較する必要があります。

### テスト使用例：トラックツール {#Test-Use-Case-The-Track-Tool} (トラックツールのテスト使用例)

FileMQのようなものを適切にテストするためには、ライブデータを扱うテストケースが必要です。私のシスアドの仕事の1つは、私の音楽プレーヤーのMP3トラックを管理することで、ちなみにこれはSansa ClipをRock Boxでリフラッシュしたものです。Musicフォルダにトラックをダウンロードしたら、プレーヤーにコピーしたいですし、迷惑なトラックを見つけたら、Musicフォルダで削除して、プレーヤーからも削除したいです。

これは、強力なファイル配布プロトコルとしては、ちょっとやりすぎです。bashやPerlのスクリプトを使ってこれを書くこともできますが、正直なところ、FileMQで最も大変だったのはディレクトリ比較のコードで、私はその恩恵を受けたいと考えています。そこで、FileMQ API を呼び出す <tt>track</tt> というシンプルなツールを組みました。コマンドラインから、送信側と受信側のディレクトリを2つの引数として実行します：

```
./track /home/ph/Music /media/3230-6364/MUSIC
```

このコードは、FileMQ APIを使用してローカルファイル配布を行う方法の適切な例である。以下は、ライセンステキストを除いたプログラム全体です（MIT/X11ライセンスです）：

{{< fragment name="track" >}}
#include "czmq.h"
#include "../include/fmq.h"

int main (int argc, char *argv [])
{
    fmq_server_t *server = fmq_server_new ();
    fmq_server_configure (server, "anonymous.cfg");
    fmq_server_publish (server, argv [1], "/");
    fmq_server_set_anonymous (server, true);
    fmq_server_bind (server, "tcp://*:5670");

    fmq_client_t *client = fmq_client_new ();
    fmq_client_connect (client, "tcp://localhost:5670");
    fmq_client_set_inbox (client, argv [2]);
    fmq_client_set_resync (client, true);
    fmq_client_subscribe (client, "/");

    while (true) {
        //  Get message from fmq_client API
        zmsg_t *msg = fmq_client_recv (client);
        if (!msg)
            break;              //  Interrupted
        char *command = zmsg_popstr (msg);
        if (streq (command, "DELIVER")) {
            char *filename = zmsg_popstr (msg);
            char *fullname = zmsg_popstr (msg);
            printf ("I: received %s (%s)\n", filename, fullname);
            free (filename);
            free (fullname);
        }
        free (command);
        zmsg_destroy (&msg);
    }
    fmq_server_destroy (&server);
    fmq_client_destroy (&client);
    return 0;
}
{{< /fragment >}}

このツールで物理パスをどのように扱うかに注目してください。サーバーは物理パス<tt>/home/ph/Music</tt>を公開し、これを仮想パス<tt>/</tt>にマッピングしています。クライアントは<tt>/</tt>を購読し、<tt>/media/3230-6364/MUSIC</tt>内のすべてのファイルを受信する。サーバーのディレクトリ内でどんな構造を使っても、クライアントの受信トレイに忠実にコピーされます。APIメソッド<tt>fmq_client_set_resync()</tt>が、サーバーとクライアントの同期を引き起こすことに注目してください。

## 公式ポート番号の取得{#Getting-an-Official-Port-Number}。

FILEMQの例では、ポート5670を使用しています。本書のこれまでの例とは異なり、このポートは任意ではなく、「DNSルート、IPアドレス、その他のインターネットプロトコルリソースのグローバルな調整を担当する」Internet [Assigned Numbers Authority (IANA)](http://www.iana.org) によって [割り当てられた](http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt) です。

アプリケーションプロトコルの登録ポート番号をいつ、どのように要求するか、ごく簡単に説明します。主な理由は、アプリケーションを他のプロトコルと衝突させることなく実行できるようにするためです。技術的には、1024から49151までのポート番号を使用するソフトウェアを出荷する場合、IANAに登録されたポート番号のみを使用する必要があります。しかし、多くの製品はこれを気にせず、代わりにIANAリストを「避けるべきポート」として使用する傾向があります。

FILEMQのような重要なプロトコルの公開を目指すのであれば、IANAに登録されたポートが欲しいところです。そのための方法を簡単に説明します：

* IANAは、あなたがポートをどのように使うつもりなのかの仕様を求めているので、あなたのプロトコルを明確に文書化してください。それは完全なプロトコルの仕様である必要はありませんが、専門家のレビューに合格するのに十分な固さでなければなりません。

* どのようなトランスポートプロトコルを使用するかを決定します： UDP、TCP、SCTPなど。ZeroMQでは、通常、TCPだけが必要でしょう。

* iana.orgのアプリケーションに必要な情報を記入する。

* IANAは、あなたの申請が受理されるか拒否されるまで、電子メールでプロセスを継続します。

特定のポート番号を要求するのではなく、IANAが割り当てることに注意してください。したがって、このプロセスは、ソフトウェアを出荷した後ではなく、出荷前に開始するのが賢明です。