---
weight: 8
title: '8. 分散型コンピューティングのためのフレームワーク'
---

# 分散コンピューティングのためのフレームワーク {#moving-pieces}

私たちはZeroMQを様々な側面から理解する旅をしてきました。今では、私が説明した技術や自分で考えた技術を使って、自分の製品を作り始めていることでしょう。そして、これらの製品を現実の世界でどのように動作させるかという疑問に直面するようになります。

しかし、その「現実の世界」とは何でしょうか？私は、「現実の世界」は、ますます多くの部品が動く世界になりつつある、と主張します。モノのインターネット "という言葉を使う人もいますが、現在のスマートフォンやタブレット、ノートパソコン、サーバーよりも数が多く、かつバカにできないデバイスの新しいカテゴリーが登場することを示唆しています。しかし、私は、このようなデータはまったくないと思っています。確かにデバイスの数は増えていますが、それらは決してバカではありません。スマートでパワフルで、常に進化し続けているのです。

このメカニズムは、私が「コストグラビティ」と呼んでいるもので、18～24カ月ごとにテクノロジーのコストが半分になる効果があります。別の言い方をすれば、私たちの世界的な計算能力は2年ごとに2倍になり、何度も何度も繰り返されるのです。未来は、何兆台ものデバイスが完全にパワフルなマルチコアコンピューターで埋め尽くされ、切り詰められた「モノのためのOS」ではなく、完全なOSと完全なアプリケーションを実行します。

そしてこれが、私たちがZeroMQでターゲットにしている世界なのです。スケール」といっても、何百台、何千台というコンピュータのことではありません。小さなスマートで自己複製可能なマシンの雲が、すべての人を取り囲み、あらゆる空間を満たし、壁を覆い、隙間を埋め、やがて私たちの一部となり、生まれる前に手に入れ、死ぬまで付きまとうようになることを想像してください。

これらの小さな機械の雲は、インターネット・プロトコルを使用した近距離無線リンクで、常に互いに会話しています。メッシュネットワークを構築し、神経信号のように情報やタスクを伝達する。記憶、視覚、コミュニケーションのあらゆる側面、そして身体機能を増強してくれるのです。そして、その会話やイベント、作業や情報の交換に力を与えてくれるのがZeroMQなのです。

さて、今日、このようなことを少しでも実現するためには、一連の技術的な問題を解決する必要があります。以下のような問題です： ピアはどのようにしてお互いを発見するのか？ピアがお互いを発見する方法、Webのような既存のネットワークに接続する方法、ピアが運ぶ情報を保護する方法などです。ピアが運ぶ情報をどのように保護するのか？ピアが何をしているのか、どうやって追跡・監視すればいいのか？そして、ほとんどのエンジニアが忘れていることですが、この解決策を一般の開発者が簡単に使えるようなフレームワークにパッケージ化することが必要です。

この章では、API、プロトコル、実装として、分散アプリケーションのためのフレームワークを構築することを目指します。これは小さな挑戦ではありませんが、ZeroMQはこのような問題を簡単に解決してくれると私はよく主張してきましたので、それがまだ正しいかどうか見てみましょう。

私たちは次のことを取り上げます：

* 分散コンピューティングの要件
* 近接ネットワークのためのWiFiの長所と短所
* UDPとTCPを使ったディスカバリー
* メッセージベースのAPI
* 新しいオープンソースプロジェクトを作成する
* ピアツーピアの接続性（Harmonyパターン）
* ピアの存在と消滅を追跡する
* 中央調整なしのグループメッセージング
* 大規模なテストとシミュレーション
* 高水準のピアとブロックされたピアへの対応
* ロギングとモニタリングの分散化

## Design for The Real World {#Design-for-The-Real-World}

部屋いっぱいのモバイルデバイスをWiFiで接続する場合でも、仮想ボックスのクラスタを模擬イーサネットで接続する場合でも、同じような問題にぶつかります。それは次のようなものです：

* ディスカバリー*：ネットワーク上の他のノードをどのように知るか？ディスカバリー*：ネットワーク上の他のノードをどのように知るか？ディスカバリーサービス、集中メディエーション、またはある種のブロードキャストビーコンを使用するか？

* プレゼンス*：他のノードがいつ来て、いつ去るかをどのように追跡するか？ある種の中央登録サービス、ハートビート、ビーコンを使うか？

* 接続性：どのように1つのノードを別のノードに実際に接続するのですか？ローカルネットワーク、ワイドエリアネットワーク、あるいは中央のメッセージブローカーを使って転送を行うか？

* Point-to-point messaging*：あるノードから別のノードにメッセージを送るにはどうしたらいいか？ノードのネットワークアドレスに送るか、中央のメッセージブローカーを介した間接的なアドレス指定を使うか。

* グループメッセージング：1つのノードから他のグループへメッセージを送るにはどうすればいいのか？中央集権的なメッセージブローカーを経由するか、ZeroMQのようなパブサブモデルを使用するか？

* テストとシミュレーション*：パフォーマンスを適切にテストするために、大量のノードをどのようにシミュレートするのでしょうか？Androidタブレットを2ダース購入する必要があるのか、それとも純粋なソフトウェア・シミュレーションを使用できるのか？

* 分散ロギング*: ノードのクラウドが何をしているかを追跡して、パフォーマンスの問題や障害を検出できるようにするにはどうすればよいでしょうか。メインのロギングサービスを作るか、それともすべてのデバイスがその周りの世界をロギングできるようにするか？

* コンテンツ配信*：あるノードから別のノードにコンテンツを送るにはどうすればいいか？FTPやHTTPのようなサーバー中心のプロトコルを使うか、FileMQのような分散型のプロトコルを使うか。

これらの問題や、今後出てくるであろう問題（セキュリティや広域ブリッジなど）をうまく解決できれば、「Really Cool Distributed Applications」、あるいは私の孫が言うように「我々の世界が動くソフトウェア」と呼ぶべきフレームワークのようなものができる。

私の美辞麗句から、私たちが進むべき方向は大きく2つに分かれることがおわかりいただけたと思います。ひとつは、すべてを中央集権化すること。もうひとつは、すべてを分散させることです。私は分散に賭けるつもりです。中央集権を望むのであれば、ZeroMQは必要ないでしょう。

というわけで、非常に大雑把ですが、こんな感じです。1つ目は、動く部品の数が時間とともに指数関数的に増加する（24ヶ月ごとに2倍になる）。2つ目は、ケーブルをどこにでも引っ張っていくのは本当に退屈なので、これらの部品はワイヤーを使わなくなる。3つ目は、[第6章 ZeroMQコミュニティ](chapter6#the-community)のBenevolent Tyrantパターンを使って、将来のアプリケーションがこれらのピースのクラスター間で実行されることです。4、今日、このようなアプリケーションを構築するのは本当に難しく、いや、むしろまだ不可能だ。5、私たちが築き上げたすべての技術とツールを使って、安価で簡単にできるようにしましょう。六つ目、パルタイ！

## WiFiの秘密の生活 {#The-Secret-Life-of-WiFi}

多くの大企業がデータをクラウドに集約して生活していますが、未来はそれほど一元化されたものではなさそうです。ネットワークの端にいるデバイスは、年々賢くなる一方で、鈍くなっているわけではありません。彼らは、仕事と、消化すべき情報と、そこから利益を得ることに飢えています。そして、夜間の電源確保を除いては、ケーブルを引き回すこともない。すべてワイヤレスで、しかも802.11ブランドのWiFiで、さまざまなアルファベットのフレーバーがあります。

### メッシュはなぜまだここにないのか？ {#Why-Mesh-Isn-t-Here-Yet}

私たちの未来に欠かせない存在であるWiFiには、あまり議論されることのない大きな問題がありますが、それに賭ける人は知っておく必要があります。世界の電話会社は、政府が機能しているほぼすべての国で、電波とアイデアの独占権がなければ世界が崩壊すると政府を説得し、利益を上げる携帯電話カルテルを構築しました。技術的には、これを「規制の掌握」と「特許」と呼んでいるが、実際には脅迫と腐敗の一形態に過ぎない。もし国家が、私という企業に、過剰な請求、市場への課税、真の競争相手をすべて追放する権利を与えてくれるなら、私は5％を差し上げますよ。物足りないか？10％ならどうだ？よし、15％プラスお菓子だ。断れば、サービスを停止する。

しかし、WiFiは、無許可の空域を借りて、オープンで、特許を取得していない、極めて革新的なインターネット・プロトコル・スタックの背中に乗って、この難関を潜り抜けた。そのため、今日、ソウルからブリュッセルへ電話をかけるのに、何十年もかけて国が補助してきたインフラを使えば1分間に数ユーロかかるが、規制されていないWiFiアクセスポイントを見つければまったくかからないという不思議な状況になっている。しかも、ビデオも撮れるし、ファイルや写真も送れるし、ホームムービーも丸ごとダウンロードできて、しかも値段はゼロ・ポイント・ゼロ（好きな通貨で）。もし、実際にお金を払っているサービスを使って、写真を1枚でも送ろうとしたら、神様は私を助けてくれるでしょう。その場合、撮影したカメラよりも高くつくことになります。

これは、「私たちを信じてください、私たちは専門家です」という特許制度を長い間容認してきたことの代償です。しかしそれ以上に、技術部門の一部、特に反インターネットのGSM、GPRS、3G、LTEスタックの特許を所有し、通信事業者を主要顧客として扱うチップセットメーカーにとっては、WiFi開発を積極的に妨害する大きな経済的インセンティブとなっているのです。そしてもちろん、WiFiを定義するIEEEの委員会を支配しているのは、これらの企業です。

弁護士主導の「イノベーション」に対してこのような暴言を吐く理由は、「もしWiFiが本当に無料だったら」という方向に考えを誘導するためです。これは、そう遠くない日に起こることであり、それに賭ける価値がある。いくつかのことが起こるでしょう。第一に、干渉の心配がない近距離通信のために、空域がより積極的に利用されるようになります。第二に、より多くの空域を並行して利用できるようになることで、容量が大幅に向上することです。第三に、標準化プロセスの加速化です。最後に、本当に面白い接続を実現するための機器への幅広い対応です。

今、携帯電話からテレビに映画をストリーミングすることは「最先端」と考えられています。これは馬鹿げています。本当に野心的なことを考えましょう。スタジアムの人々が試合を観戦し、写真やHDビデオをリアルタイムで共有し、文字通りデジタルな熱狂で空域を飽和させるようなアドホックなイベントを作るのはどうでしょう。周囲からテラバイト単位の画像を、1時間で収集できるはずだ。なぜ、TwitterやFacebook、そして高価なモバイルデータ接続を経由する必要があるのでしょうか？何百ものデバイスがメッシュを介して互いに通信し、誰かがドアベルを鳴らすと、ポーチライトの映像が携帯電話やテレビに送られるような家はどうでしょう？電話機と会話し、ダブステップのプレイリストを再生できる自動車はどうでしょう。

もっと深刻なのは、なぜ私たちのデジタル社会は、監視され、検閲され、記録され、私たちが誰と話したかを追跡し、私たちに対する証拠を収集するために使用され、そして当局が私たちの言論の自由が大きすぎると判断すると閉鎖される中央拠点の手にあるのでしょう。私たちが経験しているプライバシーの喪失は、それが一方的なものである場合にのみ問題となりますが、その場合、問題は甚大なものになるのです。真にワイヤレスな世界では、中央の検閲はすべて回避されるでしょう。インターネットはそのように設計されており、技術的にはかなり実現可能です（実現可能というのは最高のものです）。

### いくつかの物理学 {#Some-Physics}

分散型ソフトウェアの素朴な開発者は、ネットワークを無限に速く、完璧に信頼できるものとして扱います。これはイーサネットを使った単純なアプリケーションではほぼ真実ですが、WiFiは魔法のような思考と科学の違いを急速に証明しました。つまり、WiFiはストレスがかかると簡単に、そして劇的に壊れてしまうので、あえて実際の仕事に使う人がいるのだろうかと思うことがある。WiFiが良くなるにつれて天井は上がっていきますが、私たちが天井にぶつかるのを止められるほど速くはないでしょう。

WiFiの技術的な性能を理解するには、物理学の基本的な法則を理解する必要があります：2点を接続するのに必要な電力は、距離の2乗に従って増加します。大きな家で育った人は、声が指数関数的に大きくなることを、私はダラスで学びました。WiFiネットワークの場合、2つの無線機の距離が離れると、より多くの電力を使うか、信号速度を下げなければならないことになります。

バッテリーから電力を引き出せるのは、そのデバイスが絶望的に壊れたとユーザーに扱われる前だけです。したがって、WiFiネットワークが一定の速度で評価されていても、アクセスポイント（AP）とクライアント間の実際のビットレートは、両者の距離がどれくらい離れているかによって異なります。WiFi対応携帯電話をAPから遠ざけると、互いに通信しようとする2つの無線は、まずパワーを上げ、次にビットレートを下げます。

この効果は、人形のようにワイヤーを後ろにぶら下げることのない、堅牢な分散型アプリケーションを構築したいのであれば、注意しなければならないいくつかの結果をもたらすものです：

* APと会話するデバイスのグループがある場合、APが最も遅いデバイスと会話しているときは、ネットワーク全体が待たされることになります。これは、ユーモアのセンスがなく、まだ完全かつ悲劇的にしらふで、言葉もよくわからない指名ドライバーに、パーティーでジョークを繰り返さなければならないようなものです。

* ユニキャストTCPを使用して複数のデバイスにメッセージを送信する場合、APは各デバイスに個別にパケットを送信する必要があります。しかし、1台の遠い（またはパワーの低い）デバイスがあると、その最も遅いデバイスが追いつくまですべてが待機することになることを理解してください。

* マルチキャストやブロードキャスト（ほとんどの場合、同じ働きをします）を使用する場合、APは一度にネットワーク全体に単一のパケットを送信します、これは素晴らしいことですが、それは可能な限り遅いビットレート（通常1Mbps）でそれを行います。一部のAPでは、このレートを手動で調整することができます。ただし、その場合、APの到達距離は短くなります。もっと高価なAPを購入すれば、もう少しインテリジェンスがあり、安全に使用できる最高ビットレートを割り出すことも可能です。また、IGMP（インターネットグループ管理プロトコル）をサポートし、ZeroMQのPGMトランスポートを使用して、購読しているクライアントにのみ送信するエンタープライズAPを使用することも可能です。しかし、そのようなAPが広く利用できるようになるとは思えません。

APに多くのデバイスを載せようとすると、パフォーマンスが急速に悪化し、デバイスを1台追加するとネットワーク全体が壊れてしまうほどです。多くのAPは、モバイルホットスポットでは4～8台、コンシューマー向けAPでは30～50台、エンタープライズ向けAPでは100台といった具合に、クライアントがある限界に達するとランダムに切断することでこれを解決しています。

### 現状はどうなっているのか？ {#What-s-the-Current-Status}

WiFiは、野放しにされた企業向け技術として不快な役割を担っていますが、すでにSkypeの無料通話以上の用途で利用されています。理想的とは言えませんが、面白い問題を解決するのに十分な機能を備えています。それでは、簡単な現状報告をさせていただきます。

まず、ポイントツーポイントとアクセスポイント・ツークライアントについて。従来のWiFiは、すべてAP-clientです。すべてのパケットは、クライアントAからAP、そしてクライアントBに送らなければなりません。帯域幅を50％削減することができますが、それは問題の半分にすぎません。逆電力則について説明しました。AとBが非常に近くにいても、どちらもAPから遠い場合、どちらも低いビットレートを使用することになります。APがガレージにあり、あなたがリビングルームで携帯電話からテレビにビデオをストリーミングしようとしていると想像してください。幸運を祈ります！

しかし、これはあまりにも遅いので、楽しいものではありませんし、もちろん、すべてのモバイルチップセットで無効になっています。実は、チップセットメーカーがハードウェアメーカーに親切に提供する極秘ドライバで無効化されているのです。新しい*Tunneled Direct Link Setup*（TDLS）プロトコルがあり、2つのデバイスが直接リンクを作成し、APを発見には使用するが、トラフィックには使用しないことができます。そして、リンク速度をギガビットにまで高める「5G」WiFi規格（マーケティング用語なので、引用符で囲んでいます）があります。TDLSと5Gを組み合わせれば、携帯電話からテレビへのHD映画ストリーミングが現実味を帯びてきます。TDLSは、通信事業者をなだめるために、さまざまな形で制限されることになると思います。

最後に、802.11sメッシュプロトコルの標準化が、10年ほどの歳月を経て、2012年に実現しました。メッシュは、少なくともそれが存在し、広く使われている想像上の未来においては、アクセスポイントを完全に取り除くものである。デバイスは互いに直接会話し、パケットを転送するための近隣の小さなルーティングテーブルを維持します。APソフトウェアがすべてのデバイスに組み込まれていて、マルチホップを行うのに十分な賢さを持っていると想像してください（言うほど感動的ではありません）。

モバイルデータの強奪で儲けている人は誰も802.11が使えるようになることを望んでいません。街中のメッシュは収益にとって悪夢だからです。メッシュ技術を広く普及させる力を持つ（そして地対地ミサイルを持つ）大組織は、アメリカ陸軍だけです。しかし、メッシュは出現するでしょうし、2020年くらいには802.11sが家電製品に広く普及することに賭けてみたいですね。

次に、ポイント・トゥ・ポイントがない場合、現在のAPはどこまで信頼できるのでしょうか？アメリカのスターバックスに行き、無料WiFiで接続した2台のラップトップを使ってZeroMQの「Hello World」の例を試してみると、接続できないことがわかる。なぜか？その答えは、「attwifi」という名前にあります。AT&TはWiFiを嫌う古き良き通信事業者で、おそらくスターバックスなどに安くサービスを提供し、独立系企業が市場に参入できないようにしているのでしょう。しかし、購入したアクセスポイントは、クライアントからAP、APからクライアントへのアクセスをサポートします。

3つ目は、パフォーマンスです。APがボトルネックになっているのは明らかで、APの横に文字通りAとBを置いたとしても、宣伝されている速度の半分以上を得ることはできない。さらに悪いことに、同じ空域に他のAPがあると、お互いに大声を出してしまうのです。私の家では、2軒先の隣人が増幅したAPを持っているため、WiFiはほとんど機能しません。別のチャンネルでも、我が家のWiFiに干渉してくるのです。今座っているカフェでは、10以上のネットワークがあります。現実的には、APベースのWiFiに依存している限り、ランダムな干渉と予測不可能なパフォーマンスにさらされることになる。

4つ目は、バッテリーの寿命です。WiFiはアイドル時に、例えばBluetoothよりも空腹になるような固有の理由はありません。同じ無線機と低レベルのフレーミングを使用しています。主な違いは、チューニングとプロトコルにあります。ワイヤレスの省電力化がうまく機能するためには、デバイスはほとんどスリープ状態で、他のデバイスにビーコンを発信するのは1回に限られます。そのためには、クロックの同期が必要です。携帯電話の場合、これが適切に行われるため、私の古いフリップフォンは充電で5日間駆動することができます。WiFiが動作しているときは、より多くの電力を使うことになります。現在のパワーアンプ技術も非効率的です。つまり、空気中に送り出すよりも多くのエネルギーをバッテリーから引き出すことになります（廃棄物は熱い携帯電話になります）。パワーアンプは、人々がモバイルWiFiにもっと注目するにつれて改善されています。

最後に、モバイルアクセスポイントです。中央集権的なAPを信頼できず、デバイスがフルOSを実行できるほどスマートなら、それらをAPとして機能させることはできないだろうか。というご質問をいただき、とても嬉しく思っています。はい、できますよ。特に、AndroidのようなモダンなOSでは、ソフトウェアでオン・オフを切り替えることができますから。繰り返しますが、平和の悪役はアメリカの通信事業者で、彼らはこの機能を嫌って、自分たちがコントロールする電話機でこの機能を停止させたり、不具合にしたりします。賢い通信事業者は、この機能が自分たちの「ラストマイル」を増幅し、より多くのユーザーに価値の高い製品を提供する方法であることに気づいているが、悪党は賢さでは勝負しないのである。

### 結論 {#Conclusions}

WiFiはイーサネットではないので、将来のZeroMQアプリケーションは非常に重要な分散型ワイヤレスプレゼンスを持つことになると思いますが、それは簡単な道のりではなさそうです。イーサネットに期待される基本的な信頼性と容量の多くが欠落しています。WiFi上で分散型アプリケーションを実行する場合、頻繁なタイムアウト、ランダムなレイテンシ、任意の切断、インターフェース全体のダウンとアップなどを許容しなければなりません。

ワイヤレスネットワークの技術的な進化は、「遅くて楽しくない」という表現がぴったりです。分散型ワイヤレスを活用しようとするアプリケーションやフレームワークは、ほとんど存在しないか貧弱です。近接ネットワークのオープンソースフレームワークは、Qualcomm社の[AllJoyn](https://www.alljoyn.org)が唯一の存在です。しかし、ZeroMQによって、既存のプレイヤーの惰性や老朽化した無能さが、私たちがじっとしている理由にはならないことを証明しました。問題を正確に理解すれば、それを解決することができる。想像したことは、現実にすることができるのです。

## ディスカバリー {#Discovery}

ディスカバリーはネットワーク・プログラミングに不可欠な要素であり、ZeroMQ開発者にとっては第一級の問題です。すべての<tt>zmq_connect（）</tt>呼び出しはエンドポイント文字列を提供し、それはどこかから来るものでなければなりません。これまで見てきた例では、発見を行いません。接続先のエンドポイントは、コード内の文字列としてハードコーディングされています。これはサンプルコードとしては問題ないのですが、実際のアプリケーションでは理想的ではありません。ネットワークはそんなにうまくはいきません。物事は変化するものであり、変化にいかにうまく対応できるかが、長期的な成功を左右するのです。

### サービス・ディスカバリー {#Service-Discovery}

まず、定義から始めましょう。ネットワーク・ディスカバリーとは、ネットワーク上に他のピア（仲間）がいることを発見することです。サービス・ディスカバリーとは、それらのピア（仲間）が私たちのために何をしてくれるかを知ることです。Wikipediaでは、「ネットワークサービス」を「コンピュータネットワーク上でホストされるサービス」と定義し、「サービス」を「異なる目的のために再利用できる関連するソフトウェア機能のセットと、その使用を制御するためのポリシー」と定義しています。あまり参考にならないですね。Facebookはネットワークサービスなのか？

実は「ネットワークサービス」の概念は、時代とともに変化しています。18〜24ヶ月ごとに可動部品の数が倍増し、古い概念モデルを壊し、よりシンプルでスケーラブルなものを求めています。サービスとは、私にとって、他のプログラムが会話できるシステムレベルのアプリケーションのことです。ネットワークサービスは、リモートでアクセスできるサービスです（例えば、コマンドラインのサービスである「grep」コマンドと比較すると）。

BSDのソケットモデルでは、サービスはネットワークポートに1対1で対応します。コンピュータシステムは、「FTP」や「HTTP」のような多くのサービスを提供し、それぞれにポートが割り当てられています。BSD API には、サービス名をポート番号にマッピングするための <tt>getservbyname</tt> のような関数があります。つまり、古典的なサービスは、ネットワークのエンドポイントにマッピングされます。サーバーのIPアドレスを知っていれば、そのFTPサービスが実行されていれば、それを見つけることができます。

しかし、現代のメッセージングでは、サービスはエンドポイントに1対1でマッピングされるわけではありません。1つのエンドポイントから多くのサービスにつながることがあり、サービスは時間の経過とともに、ポート間、あるいはシステム間で移動することがあります。クラウドストレージはどこにあるのか？したがって、現実的な大規模分散アプリケーションでは、何らかのサービス発見メカニズムが必要です。

これを実現する方法はたくさんあるので、網羅的なリストを提供するつもりはない。しかし、いくつかの古典的なパターンがあります：

* エンドポイントからサービスへの古い1対1マッピングを強制し、あるTCPポート番号があるサービスを表していることを前もって表明することができます。プロトコルは、これをチェックできるようにする必要があります（「リクエストの最初の4バイトは "HTTP "か」）。

* よく知られたエンドポイントとサービスに接続し、「本当の」サービスを求め、その返りとしてエンドポイントを得る。これは、私たちにサービスルックアップサービスを与えます。ルックアップ・サービスが許可すれば、サービスが場所を更新する限り、移動することができます。

* よく知られたエンドポイントやサービスが、他のサービスに間接的に（つまりメッセージを転送することによって）提供するように、あるサービスを他のサービスを通してプロキシすることができます。これは例えば、私たちのMajordomoサービス指向ブローカーがどのように機能するかということです。

* 分散ネットワークの各ノードがネットワーク全体の最終的に一貫したマップを構築できるように、ゴシップアプローチや集中型アプローチ（Cloneパターンのような）を使用して、時間とともに変化する既知のサービスやエンドポイントのリストを交換することができます。

* ネットワークエンドポイントとサービスの間にさらに抽象的な層を作ることができます。例えば、各ノードに一意の識別子を割り当てることで、各ノードがいくつかのサービスを提供し、ランダムなネットワークエンドポイントに現れるかもしれない「ノードのネットワーク」を得ることができます。

* 例えば、エンドポイントに接続し、どのようなサービスを提供しているか尋ねることで、日和見的にサービスを発見することができます。"こんにちは、あなたは、共有プリンタを提供していますか？もしそうなら、メーカーと機種は何ですか？"

正しい答え」はありません。選択肢は膨大であり、ネットワークの規模が大きくなるにつれて変化していきます。ネットワークによっては、どのサービスがどこで動いているかという知識が、文字通り政治的な力になることもあります。ZeroMQは特定のモデルを押し付けず、私たちに最も適したものを簡単に設計・構築できるようにします。ただし、サービスディスカバリーを構築するためには、ネットワークディスカバリーを解決することから始めなければなりません。

### ネットワーク・ディスカバリー {#Network-Discovery}

ネットワーク・ディスカバリーについて、私が知っている解決策を列挙してみます：

* ハードコードされたエンドポイント文字列*、つまり固定IPアドレスと合意されたポートを使用する。これは、10年前の社内ネットワークで、少数の「大きなサーバー」があり、それらが非常に重要であったため、固定IPアドレスを取得していたときに機能しました。しかし、最近では、例やプロセス中の作業（スレッドが新しいビッグアイアン）以外には使えません。DNSを使えば少しはマシになりますが、副業でシステム管理をしていない人にとっては、これはまだ辛いことです。

* 設定ファイルからエンドポイント文字列を取得する。これは名前解決をユーザー空間に押し込むもので、DNSよりは痛くないが、それは顔面へのパンチが股間へのキックより痛くないと言うようなものである。しかし、これは顔面パンチが股間キックより痛くないと言うようなものです。ここで、非自明な管理問題が発生します。誰が、いつ、設定ファイルを更新するのか？設定ファイルはどこに保存するのか？Salt Stackのような分散管理ツールを導入するか？

* *メッセージブローカーを使う*。ブローカーに接続するためには、ハードコードされた、あるいは設定されたエンドポイント文字列がまだ必要ですが、このアプローチでは、ネットワーク内の異なるエンドポイントの数を1つに減らすことができます。これは本当にインパクトがあり、ブローカーベースのネットワークはうまくスケールします。しかし、ブローカーは単一障害点であり、管理およびパフォーマンスに関する独自の心配事をもたらします。

* アドレスブローカーを使用します。言い換えれば、アドレス情報を仲介する中央のサービス（ダイナミックDNSセットアップのような）を使用し、ノードが直接メッセージを送り合うことを可能にします。これは良いモデルですが、それでも障害と管理コストのポイントを作成します。

* ZeroConf*のようなヘルパーライブラリを使用し、集中型インフラストラクチャなしでDNSサービスを提供します。これは特定のアプリケーションには良い答えですが、あなたの走行距離によって異なります。ヘルパーライブラリはゼロコストではありません。ソフトウェアを構築するのがより複雑になり、独自の制約があり、必ずしもポータブルではありません。

* ARPやICMP ECHOパケットを送信し、応答するすべてのノードに問い合わせることによって、システムレベルの発見を構築することができます。例えばTCP接続で問い合わせることもできますし、UDPメッセージを送ることでも問い合わせることができます。Eye-Fiワイヤレスカードのように、これを行う製品もあります。

* ネットワークセグメント内のすべてのアドレスに接続しようとすることで、ユーザーレベルのブルートフォースディスカバリー*を実行します。ZeroMQはバックグラウンドで接続を処理するため、これを簡単に行うことができます。複数のスレッドも必要ありません。これは残酷ですが楽しいことで、デモやワークショップではとてもうまくいきます。しかし、それはスケールしないし、まともな考えを持つエンジニアを困らせる。

* 独自のUDPベースのディスカバリープロトコル*を開発する。多くの人がこれをやっています（StackOverflowでこのトピックに関する質問を約80件数えました）。UDPはこのためにうまく機能し、技術的に明確です。しかし、正しく行うには技術的に厄介で、最初の数回これを行う開発者は劇的に間違ってしまうだろうほどだ。

* ゴシップ発見プロトコル*。完全に相互接続されたネットワークは、ノード数が少ない場合（例えば、100や200まで）には非常に効果的です。ノードの数が多い場合は、ある種のゴシッププロトコルが必要です。つまり、私たちが合理的に発見できるノード（例えば、私たちと同じセグメント上にあるノード）が、より遠くにあるノードについて教えてくれるのです。ゴシッププロトコルは、ZeroMQで最近必要なものを超えていますが、将来的にはより一般的になるでしょう。広域のゴシップモデルの一例として、メッシュ・ネットワーキングがあります。

### ユースケース {#The-Use-Case}

ユースケースをもっと明確に定義してみましょう。結局のところ、これらの異なるアプローチはすべて機能し、現在もある程度機能しています。建築家として興味があるのは未来であり、数年以上にわたって機能し続ける設計を見つけることです。これは、長期的なトレンドを見極めることを意味します。私たちのユースケースは今ここではなく、今日から10年、20年後の話です。

以下は、私が分散型アプリケーションで目にする長期的なトレンドです：

* 動く部品の数は増え続けています。私の予想では、24ヶ月ごとに2倍になりますが、その速さは、ネットワークにどんどんノードを追加していくという事実より重要ではありません。ノードとは、単なる箱ではなく、プロセスやスレッドでもあるのです。ここでの原動力はコストで、[下がり続けている](http://cultureandempire.com/)。10年後には、平均的なティーンエイジャーは30～50台のデバイスを常に携帯するようになるでしょう。

* 制御が中心から遠ざかるのです。データもそうなるかもしれません。しかし、単純な分散型情報ストアを構築する方法を理解するには、まだほど遠いのが現状です。いずれにせよ、スター型トポロジーは徐々に衰退し、クラウド・オブ・クラウドに取って代わられつつあります。将来的には、リモートノードとセンター間のトラフィックよりも、ローカル環境（自宅、オフィス、学校、バー）内のトラフィックの方がはるかに多くなることが予想されます。つまり、遠隔地の通信は近距離の通信よりもコストがかかり、動作も遅く、自然なものではない、ということです。友人と休日のビデオを共有するには、Facebookよりも地元のWiFiで共有する方が技術的にも社会的にも正確です。

* ネットワークはますます共同化され、管理されなくなる*。これは、人々が自分のデバイスを持ち寄り、それらがシームレスに動作することを期待することを意味します。ウェブはこれを実現する1つの方法を示したが、1人1台の平均的なデバイスを超えるようになり、ウェブができることの限界に達しつつある。

* ネットワークがスケールするためには、新しいノードをネットワークに接続するコストが比例して低下する必要があります。つまり、ノードが必要とする設定の量を減らすことで、事前共有状態やコンテキストを少なくするのです。繰り返しになりますが、ウェブはこの問題を解決しましたが、その代償として集中化が進みました。私たちは、同じようにプラグアンドプレイの体験を、中央の機関なしで得たいと考えています。

何兆ものノードが存在する世界では、最も身近にいるノードと話すことができます。これが現実の世界でのやり方であり、大規模なアーキテクチャを拡張する最も健全な方法なのです。論理的または物理的に近いノードのグループは、他のノードのグループとブリッジで接続されています。ローカルグループは、半ダースのノードから数千のノードまであります。

そこで、2つの基本的なユースケースを紹介します：

* 近接ネットワーク**の発見、つまり、互いに近接していることを発見したノードのセットです。互いに近い」とは、「同じネットワークセグメント上にある」と定義することができます。すべてのケースで当てはまるわけではありませんが、スタート地点としては十分に有効な方法です。

* ワイドエリア・ネットワーク**を横断するディスカバリー、つまり近接したネットワーク同士を橋渡しすること。私たちはこれを「フェデレーション」と呼ぶことがあります。フェデレーションを行うには多くの方法がありますが、複雑なため、別の場所で取り上げることにします。ここでは、中央集権的なブローカーやサービスを使ってフェデレーションを行うことを想定しています。

そうすると、近接ネットワークという問題が残ります。ネットワークにモノを接続し、互いに会話できるようにしたい。学校にあるタブレットであろうと、クラウドにある大量のサーバーであろうと、事前の契約や調整が少なければ少ないほど、安価に拡張することができるのです。ですから、設定ファイルやブローカー、中央集権的なサービスなどは、すべて排除しています。

また、現実の世界がそうなっている（人々がアプリをダウンロードする）ため、また、私のノートパソコンで大規模なネットワークをシミュレートするため、1台のボックスでいくつでもアプリケーションを使えるようにしたいと考えています。また、私のノートパソコンで大規模なネットワークのシミュレーションを行うこともできます。エンジニアが「うまくいくだろう」と思っていることに驚かされます。「あの橋は、通行できるようにしたら、きっと大丈夫だろう」。最も可能性の高い3つの故障をシミュレーションして修正していなければ、開通日にはまだそこにあるはずです。

同じマシン上で複数のサービスのインスタンスを、前もって調整することなく実行することは、エフェメラル・ポート、つまりサービス用にランダムに割り当てられたポートを使用しなければならないことを意味します。エフェメラルポートは、ブルートフォースTCPディスカバリーや、ZeroConfを含むあらゆるDNSソリューションを排除します。

最後に、ディスカバリーはユーザースペースで行わなければなりません。なぜなら、私たちが構築するアプリケーションは、必ずしも私たちが所有し管理しているわけではないランダムなボックス上で実行されるからです。例えば、他人のモバイル機器などです。そのため、root権限を必要とするディスカバリーは除外されます。ARPやICMP、そしてZeroConfもサービスパーツにroot権限が必要なため、除外しています。

### 技術的要件 {#Technical-Requirements}

要件を再確認してみましょう：

* 動作する最もシンプルなソリューションであること。アドホックネットワークには多くのエッジケースがあるため、余分な機能や特徴はすべてリスクとなります。

* 現実的なシミュレーションができるように、エフェメラルポートをサポートすること。テストする唯一の方法が実際のデバイスを使用することであるならば、テストを実行するのは不可能なほど高価で時間がかかるようになります。

* ルートアクセスは不要で、ユーザー空間で100％実行する必要があります。私たちは、携帯電話のような私たちが所有していない、ルートアクセスが利用できないデバイスに、完全にパッケージ化されたアプリケーションを出荷したいのです。

* システム管理者には見えないので、アプリケーションの実行に管理者の手助けは必要ありません。どのような技術を使うにしても、ネットワークに優しく、デフォルトで利用できるものでなければなりません。

* アプリケーション自体のインストールを除けば、*ゼロコンフィギュレーション*です。ユーザーに何らかの設定を求めることは、アプリケーションを使わないための口実を与えることになります。

* すべての近代的なオペレーティングシステムに完全に移植可能であること。特定のOSで動作することを前提にすることはできません。標準的なユーザースペースネットワーキングを除いて、オペレーティングシステムからのサポートを想定することはできません。ZeroMQとCZMQが利用可能であると仮定することができます。

* 最大100-150人の参加者がいるWiFiネットワーク*に優しい。これは、メッセージを小さく保ち、WiFiネットワークがどのようにスケールし、どのように圧力で壊れるかを意識することを意味します。

* プロトコルニュートラル*、つまり、ビーコニングは特定のディスカバリープロトコルを課すものではありません。これが何を意味するかは、後で少し説明します。

* 任意の言語での再実装が容易であること。もちろん、私たちは素敵なC言語の実装を持っていますが、他の言語で再実装するのに時間がかかりすぎると、ZeroMQコミュニティの大きな塊が排除されてしまいます。ですから、繰り返しますが、シンプルです。

* 速いレスポンスタイム*。これは、新しいノードが非常に短い時間、せいぜい1秒か2秒でそのピアに見えるようにすることを意味します。ネットワークは急速に形を変えます。ピアがいなくなったことに気づくまで、30秒くらいかかってもいいんです。

私が集めた可能な解決策のリストから、1つ以上の理由で失格にならない唯一の選択肢は、UDPベースのディスカバリースタックを独自に構築することです。何十年もかけてネットワーク・ディスカバリーを研究してきたのに、このような結果になったのは少し残念なことです。しかし、コンピュータの歴史は、複雑なものから単純なものへと変化していくように見えるので、それが普通なのかもしれません。

### 30秒で自己修復するP2Pネットワーク {#A-Self-Healing-P-P-Network-in-Seconds}

ブルートフォースディスカバリーについて述べました。それがどのように機能するか見てみましょう。ソフトウェアの良いところは、学習体験をブルートフォースで進めることです。仕事を投げ出すことに満足できる限り、安全な椅子からでは非常識に思えるようなことを試してみるだけで、急速に学習することができるのです。

2012年のワークショップで生まれた、ZeroMQのブルートフォース・ディスカバリー・アプローチを説明します。それは驚くほど単純で愚かなことです。部屋にあるすべてのIPアドレスに接続します。例えば、ネットワークセグメントが192.168.55.xであれば、次のようにします：

```
connect to tcp://192.168.55.1:9000
connect to tcp://192.168.55.2:9000
connect to tcp://192.168.55.3:9000
...
connect to tcp://192.168.55.254:9000
```

ZeroMQ語で言うと、次のようになります：

{{< fragment name="brute-force-discovery" >}}
int address;
for (address = 1; address < 255; address++)
    zsocket_connect (listener, "tcp://192.168.55.%d:9000", address);
{{< /fragment >}}

愚かなのは、自分自身への接続は問題ないと思い込んでいるところ、すべてのピアが同じネットワークセグメントにあると思い込んでいるところ、ファイルハンドルを自由であるかのように浪費しているところです。幸運なことに、これらの仮定はしばしば完全に正確です。少なくとも、楽しいことができるようになるには十分な頻度です。

ループが機能するのは、ZeroMQのコネクトコールが*非同期で日和見的*だからです。空腹の猫のように影に隠れて、ポート9000でサービスを立ち上げる勇気のある無邪気なネズミに襲いかかるのをじっと待っているのです。これはシンプルで効果的であり、初回で成功しました。

さらに、ピアがネットワークから離れたり、参加したりすると、自動的に再接続されるようになっています。30秒、3行のコードで、自己修復型ピアツーピアネットワークを設計しました。

しかし、これは実際のケースには使えません。劣悪なオペレーティング・システムではファイル・ハンドルが不足しがちですし、ネットワークは1セグメントよりも複雑になりがちです。また、1つのノードが数百のファイルハンドルを抱えているとしたら、大規模なシミュレーション（1つのボックスや1つのプロセスで多くのノードを扱う）は問題外です。

それでも、この方法を捨てる前に、どこまでできるかを見てみましょう。ここに、同じネットワークセグメント上の誰とでも会話できる、小さな分散型チャットプログラムがあります。このコードには、リスナーとブロードキャスターという2つのスレッドがあります。リスナーはSUBソケットを作成し、ネットワーク上のすべてのピアにブルートフォース接続を行う。ブロードキャスターは、コンソールからの入力を受け取り、PUBソケットで送信します：

{{< examples name="dechat" title="Decentralized Chat" >}}

<tt>dechat</tt> プログラムは、現在の IP アドレス、インターフェイス、エイリアスを知る必要があります。これらをオペレーティング システムからコードで取得することもできますが、それは移植不可能な不格好なコードです。そこで、この情報をコマンドラインで提供することにしました：

```
dechat 192.168.55.122 eth0 Joe
```

### 生ソケットでのプリエンプティブ・ディスカバリー {#Preemptive-Discovery-over-Raw-Sockets}

短距離ワイヤレスの素晴らしい点の1つは、近接性です。WiFiは物理的な空間と密接に対応しており、それは私たちが自然に組織化する方法と密接に対応しています。実際、インターネットは非常に抽象的であるため、多くの人が混乱し、「なんとなくわかる」けど「実はよくわからない」ということがあります。WiFiの場合、技術的な接続が可能であり、潜在的に超具体的なものである。目に見えるものを手に入れ、目に見えるものを手に入れる。目に見えるということは、わかりやすいということであり、一般的な不満や憎しみではなく、ユーザーからの愛情を意味するはずです。

近接性が鍵になります。私たちは、部屋の中にたくさんのWiFiラジオを置き、楽しそうにビーコンを鳴らし合っています。多くのアプリケーションでは、ユーザーの入力なしにお互いを見つけてチャットを始めることができるのは理にかなっています。結局のところ、現実世界のほとんどのデータはプライベートなものではなく、高度にローカライズされているだけなのです。

ソウルの江南にあるホテルの一室で、4Gワイヤレスホットスポット、Linuxノートパソコン、Android携帯を数台使っています。電話とラップトップは、ホットスポットに接続しています。<tt>ifconfig</tt>コマンドによると、私のIPアドレスは192.168.1.2です。いくつかの<tt>ping</tt>コマンドを試してみます。DHCPサーバーは順番にアドレスを配る傾向があるので、私の携帯電話はおそらく数字的には近くにあるはずです：

```
$ ping 192.168.1.1
PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.
64 bytes from 192.168.1.1: icmp_req=1 ttl=64 time=376 ms
64 bytes from 192.168.1.1: icmp_req=2 ttl=64 time=358 ms
64 bytes from 192.168.1.1: icmp_req=4 ttl=64 time=167 ms
^C
--- 192.168.1.1 ping statistics ---
3 packets transmitted, 2 received, 33% packet loss, time 2001ms
rtt min/avg/max/mdev = 358.077/367.522/376.967/9.445 ms
```

1つ見つかりました！往復で150-300msecのレイテンシ...意外と高い数字ですね、後々気になるところです。この数字は意外と高いので、後で覚えておこう：

```
$ ping 192.168.1.2
PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.
64 bytes from 192.168.1.2: icmp_req=1 ttl=64 time=0.054 ms
64 bytes from 192.168.1.2: icmp_req=2 ttl=64 time=0.055 ms
64 bytes from 192.168.1.2: icmp_req=3 ttl=64 time=0.061 ms
^C
--- 192.168.1.2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 1998ms
rtt min/avg/max/mdev = 0.054/0.056/0.061/0.009 ms
```

レスポンスタイムが少し速くなったので、期待通りですね。次の2つのアドレスを試してみましょう：

```
$ ping 192.168.1.3
PING 192.168.1.3 (192.168.1.3) 56(84) bytes of data.
64 bytes from 192.168.1.3: icmp_req=1 ttl=64 time=291 ms
64 bytes from 192.168.1.3: icmp_req=2 ttl=64 time=271 ms
64 bytes from 192.168.1.3: icmp_req=3 ttl=64 time=132 ms
^C
--- 192.168.1.3 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2001ms
rtt min/avg/max/mdev = 132.781/231.914/291.851/70.609 ms
```

これが2台目の電話で、1台目と同じようなレイテンシが発生しています。続けて、ホットスポットに接続されている他のデバイスがあるかどうかを確認してみましょう：

```
$ ping 192.168.1.4
PING 192.168.1.4 (192.168.1.4) 56(84) bytes of data.
^C
--- 192.168.1.4 ping statistics ---
3 packets transmitted, 0 received, 100% packet loss, time 2016ms
```

といったところでしょうか。さて、<tt>ping</tt>は生のIPソケットを使用して<tt>ICMP_ECHO</tt>メッセージを送信します。<tt>ICMP_ECHO</tt>の便利な点は、意図的にエコーをオフにしていないIPスタックから応答を得ることができることです。これは、不正なメッセージによってマシンがクラッシュする可能性のある、古い「死の ping」エクスプロイトを恐れる企業の Web サイトでは、まだ一般的な方法です。

私はこれを「先取り発見」と呼んでいますが、これはデバイスからの協力を必要としないためです。電話機がそこに座っているのを見るのに、電話機の協力に頼ることはありません。電話機が積極的に私たちを無視しない限り、私たちはそれを見ることができます。

なぜこれが便利なのかと聞かれるかもしれません。<tt>ICMP_ECHO</tt> に応答するピアは ZeroMQ を実行しているか、私たちとの会話に興味があるか、私たちが使用できるサービスがあるか、あるいはどんな種類のデバイスであるかさえも知りません。しかし、アドレス192.168.1.3に何かあることを知ることは、すでに有用です。さらに、そのデバイスが相対的にどのくらい離れているのか、ネットワーク上に何台のデバイスがあるのか、ネットワークの大まかな状態（良い、悪い、ひどい、など）もわかっているのです。

<tt>ICMP_ECHO</tt>メッセージを作成し、それを送信することは、それほど難しいことではありません。数十行のコードで、ZeroMQのマルチスレッドを使用して、自分のIPアドレスの上下に広がるアドレスに対して並行してこれを実行することができるのです。ちょっと楽しいかもしれない。

しかし、悲しいことに、デバイスの検出に <tt>ICMP_ECHO</tt> を使用するという私のアイデアには、致命的な欠陥があります。生の IP ソケットを開くには、POSIX ボックスで root 権限が必要です。それは、不正なプログラムが他の人のために意図されたデータを取得するのを阻止するためです。Linux では、コマンドに sudo 権限を与えることで、生のソケットを開く力を得ることができます (ping にはいわゆる *sticky bit* が設定されています)。AndroidのようなモバイルOSでは、root権限、つまり携帯電話やタブレットをroot化する必要があります。これはほとんどの人にとって問題外なので、<tt>ICMP_ECHO</tt>はほとんどのデバイスにとって手の届かないものです。

*ユーザースペースで何かやってみましょう。ほとんどの人が取る次のステップは、UDP マルチキャストまたはブロードキャストです。その軌跡をたどってみましょう。

### UDPブロードキャストを使った協調的発見 {#Cooperative-Discovery-Using-UDP-Broadcasts}

マルチキャストはブロードキャストよりも現代的で「良い」と見なされる傾向がある。IPv6では、ブロードキャストは全く機能せず、常にマルチキャストを使用する必要があります。しかし、IPv4のローカルネットワーク発見プロトコルはすべて、UDPブロードキャストを使用することになります。その理由は、ブロードキャストとマルチキャストの動作がほぼ同じで、ブロードキャストの方がシンプルでリスクが少ないからです。マルチキャストは、ネットワークセグメントを越えて漏れる可能性があるため、ネットワーク管理者には危険視されています。

UDPを使ったことがない人は、UDPが非常に優れたプロトコルであることに気がつくでしょう。ある意味、ZeroMQを彷彿とさせ、1対1、1対多の2種類のパターンでピアにメッセージ全体を送ります。UDPの主な問題点は、(a)POSIXソケットAPIはシンプルさではなく、普遍的な柔軟性のために設計されていること、(b)UDPメッセージは実用上、LANでは約1,500バイト、インターネットでは512バイトに制限されていること、(c) UDPを使って実際のデータを扱うと、メッセージがドロップされることがある、特にインフラがUDPよりもTCPに傾くため。

以下は、<tt>ICMP_ECHO</tt>の代わりにUDPを使用する最小限のpingプログラムです：

{{< examples name="udpping1" title="UDP discovery, model 1" >}}

このコードは、1 つのソケットを使用して 1 バイトのメッセージをブロードキャストし、他のノードがブロードキャストしているものを受信します。実行すると、1つのノードが表示され、それは自分自身です：

```
Pinging peers...
Found peer 192.168.1.2:9999
Pinging peers...
Found peer 192.168.1.2:9999
```

すべてのネットワーク接続を切ってからもう一度試してみると、予想通りメッセージの送信に失敗しました：

```
Pinging peers...
sendto: Network is unreachable
```

喉から手が出るほど欲しい問題を解決する」ことを基本に、この最初のモデルで最も緊急性の高い問題を解決してみましょう。これらの問題は以下の通りです：

* 255.255.255.255のブロードキャストアドレスを使うのは、ちょっと怪しいです。一方では、このブロードキャストアドレスは、まさに「ローカルネットワーク上のすべてのノードに送信し、転送しない」ことを意味します。しかし、複数のインターフェース（有線イーサネット、WiFi）を持っている場合、ブロードキャストはデフォルトルートのみで、1つのインターフェースを経由して発信されることになります。そこで、各インターフェイスのブロードキャストアドレスにブロードキャストを送信するか、WiFiインターフェイスとそのブロードキャストアドレスを検索することになります。

* ソケットプログラミングの多くの側面と同様に、ネットワークインターフェイスの情報を取得することは移植性がありません。ソケットプログラミングの多くの側面と同様に、ネットワークインターフェイスの情報を取得することは移植性がありません。いや、これはライブラリに隠したほうがいい。

* WiFiが切れた」というような一過性の問題に対して、「abort」以外のエラー処理は残酷すぎる。コードはソフトエラー（無視と再試行）とハードエラー（アサート）を区別する必要があります。

* コードは、自分自身のIPアドレスを知り、それが発信したビーコンを無視する必要があります。ブロードキャストアドレスを見つけるのと同様に、これは利用可能なインターフェイスを検査する必要があります。

これらの問題に対する最も簡単な答えは、UDPのコードを、次のように、きれいなAPIを提供する別のライブラリに押し込むことです：

{{< fragment name="zyre-udp" >}}
//  Constructor
static udp_t *
    udp_new (int port_nbr);

//  Destructor
static void
    udp_destroy (udp_t **self_p);

//  Returns UDP socket handle
static int
    udp_handle (udp_t *self);

//  Send message using UDP broadcast
static void
    udp_send (udp_t *self, byte *buffer, size_t length);

//  Receive message from UDP broadcast
static ssize_t
    udp_recv (udp_t *self, byte *buffer, size_t length);
{{< /fragment >}}

このライブラリを呼び出すUDP pingプログラムをリファクタリングしたものがこちらで、よりすっきりとしたものになっています：

{{< examples name="udpping2" title="UDP discovery, model 2" >}}

このライブラリ<tt>udplib</tt>は、不快なコードの多くを隠しています (これは、これをより多くのシステムで動作させると、より醜くなります)。そのコードをここで印刷するつもりはありません。リポジトリで](https://github.com/imatix/zguide/blob/master/examples/C/udplib.c)読むことができます。

さて、私たちを評価し、私たちから昼食を作ることができるかどうか疑問に思っている問題がもっとあります。まず、IPv4とIPv6、マルチキャストとブロードキャストです。IPv6では、ブロードキャストは全く存在せず、マルチキャストを使用します。私のWiFiの経験では、IPv4のマルチキャストとブロードキャストは、ブロードキャストが正常に動作する状況でマルチキャストが壊れることを除いて、同じように動作します。アクセスポイントによっては、マルチキャストパケットを転送しないものもあります。モバイルAPとして動作するデバイス（タブレットなど）がある場合、マルチキャストパケットを受信しない可能性があります。つまり、ネットワーク上の他のピアを見ることができないのです。

最もシンプルで妥当な解決策は、今のところIPv6を無視してブロードキャストを使用することです。もっと賢い解決策は、マルチキャストを使い、非対称なビーコンが発生した場合に対処することでしょう。

私たちは、今のところ、バカでシンプルなものにこだわることにします。もっと複雑にする時間はいつでもある。

### 1つのデバイスで複数のノードを使う {#Multiple-Nodes-on-One-Device}

WiFiネットワーク上のノードが期待通りにビーコンを発信していれば、ノードを発見できるわけです。そこで、2つのプロセスでテストしてみます。しかし、udpping2を2回実行すると、2回目のインスタンスが「Address already in use' on bind」と文句を言って終了してしまいました。あ、そうか。UDPもTCPも、同じポートに2つの異なるソケットをバインドしようとすると、エラーを返すんだ。これは正しい。1つのソケットに2つの読者がいるというセマンティクスは、控えめに言っても奇妙だろう。奇数/偶数バイト？あなたは1を、私は0をすべて取得する？

しかし、stackoverflow.comを素早くチェックし、<tt>SO_REUSEADDR</tt>というソケット・オプションの記憶をたどってみると、金脈が見つかりました。これを使うと、複数のプロセスを同じUDPポートにバインドすることができ、そのポートに到着したメッセージをすべて受信することができます。まるで、これを設計した人たちが私の心を読んでいたかのようです！(それは、私が車輪の再発明をしているかもしれないという可能性よりも、ずっともっともな話です)。

簡単なテストでは、<tt>SO_REUSEADDR</tt> が約束通り動作することがわかりました。私が次にやりたいことは、API を設計して、何十ものノードを起動して、それらがお互いを発見するのを見ることなので、これは素晴らしいことです。各ノードを別々のデバイスでテストしなければならないのは、本当に面倒なことです。また、大規模で不安定なネットワーク上で実際のトラフィックがどのように振る舞うかをテストする場合、シミュレーションか一時的な狂気の沙汰かの2択になる。

この夏、私たちは一度に何十台ものデバイスでテストをしていました。完全なテスト実行をセットアップするのに約1時間かかり、再現性を求めるならWiFi干渉を遮断した空間が必要です（テストケースが「オルヴァルが渇きを癒すよりも早く干渉がWiFiネットワークを殺すことを証明せよ」でない限り）。

もし私が週末に暇なAndroid開発者だったら、すぐに（2日あれば）このコードを携帯電話に移植して、PCにビーコンを送信させるだろうね。しかし、時には怠け者の方が得策です。私はLinuxのラップトップが好きです。1つのプロセスから何十ものスレッドを起動し、それぞれのスレッドが独立したノードのように動作するのが好きなんです。ラップトップでシミュレートできるのなら、本物のファラデーケージの中で作業する必要はない。

### APIの設計 {#Designing-the-API}

デバイス上でN個のノードを走らせるつもりですが、それらは互いに、またローカルネットワーク上の他のノードの束を発見しなければならないでしょう。ローカルディスカバリーにもリモートディスカバリーにもUDPを使用することができます。ZeroMQのinproc://トランスポートなどに比べると効率は悪いですが、全く同じコードがシミュレーションでも実際のデプロイでも動作するという大きな利点があります。

1つのデバイスに複数のノードがある場合、IPアドレスとポート番号をノードアドレスとして使用できないのは明らかです。何らかの論理的なノード識別子が必要です。ノード識別子は、そのデバイスのコンテキスト内でユニークであればよいのです。実際のUDPポートに座って内部ノードにメッセージを転送するスーパーノードなど、作れそうな複雑なものが頭をよぎります。私は、「新しい概念を発明する」という発想がなくなるまで、テーブルで頭を打ちました。

経験上、WiFiは、アプリケーションの実行中に消えたり現れたりするものです。ユーザーが何かをクリックすると、セッションの途中でIPアドレスが変更されるような興味深いことが起こります。IPアドレスや確立された接続（TCP方式）に依存することはできません。インターフェイスやコネクションが破壊され、再作成されても生き残る、長期的なアドレス指定メカニズムが必要です。

すべてのノードにUUIDを与え、そのUUIDで表されるノードが特定のIPアドレス：ポートエンドポイントに出現または再出現し、また消えるように指定するのです。失われたメッセージの回復については、後で説明します。UUIDは16バイトです。つまり、WiFiネットワーク上に100のノードがあるとすると、発見と存在のために1秒間に3,200バイトのビーコンデータを送信しなければならないことになります。許容範囲だと思います。

コンセプトの話に戻ります。APIには名前が必要です。少なくとも、「私たち」であるノードオブジェクトと、「私たち」のピアであるノードオブジェクトを区別する方法は必要です。 私たちは、「私たち」を作って、その「私たち」が知っているピアの数とその人数を尋ねるようなことをします。ピア」という用語は、十分に明確です。

開発者の視点から見ると、ノード（アプリケーション）は外の世界と話をする方法が必要です。ネットワークの用語を借りて、これを「インターフェース」と呼ぶことにしましょう。インターフェイスは、私たちを世界の残りの部分に対して表現し、世界の残りの部分を他のピアのセットとして私たちに提示します。インターフェイスは自動的に、必要なあらゆる発見を行います。私たちがピアと話したいときは、インターフェイスにそれを代行してもらいます。そして、ピアが私たちに話しかけるとき、私たちにメッセージを届けるのはインターフェイスです。

これはクリーンなAPI設計のように思えます。内部はどうなっているのでしょうか？

* インターフェースはマルチスレッドでなければならず、1つのスレッドがバックグラウンドでI/Oを行い、フォアグラウンドのAPIがアプリケーションと会話することができます。CloneとFreelanceのクライアントAPIでは、この設計を採用しました。

* UDPポートにバインドし、UDPビーコンを送信し、ビーコンを受信します。

* 少なくともビーコンメッセージにUUIDを送信する必要があり、それによって自分たちのビーコンとピアのビーコンを区別することができます。

* 現れたり、消えたりするピアを追跡する必要があります。このために、すべての既知のピアを保存し、いくつかのタイムアウト後にピアを失効させるハッシュテーブルを使用することにします。

* 我々は、呼び出し側にピアとイベントを報告する方法が必要です。ここで私たちは重大な疑問を抱くことになる。バックグラウンドのI/Oスレッドは、どのようにしてフォアグラウンドのAPIスレッドに、何かが起こっていることを伝えるのでしょうか？コールバックでしょうか？*もちろん、ZeroMQメッセージを使用します。

UDP pingプログラムの3回目の繰り返しは、2回目よりもさらにシンプルで美しいものです。C言語で書かれた本体は、わずか10行のコードです。

{{< examples name="udpping3" title="UDPの発見、モデル3" >}}。

インターフェイスのコードは、マルチスレッドAPIクラスの作り方を勉強したことがある人なら知っているはずです：

{{< examples name="interface" title="UDP ping interface" >}}。

これを2つのウィンドウで実行すると、1つのピアがネットワークに参加していることが報告されます。そのピアを殺すと、数秒後、そのピアが去ったことを教えてくれます：

```
--------------------------------------
[006] JOINED
[032] 418E98D4B7184844B7D5E0EE5691084C
--------------------------------------
[004] LEFT
[032] 418E98D4B7184844B7D5E0EE5691084C
```

ZeroMQ-messageベースのAPIの良いところは、これを好きなようにラッピングできることです。例えば、本当に必要ならコールバックに変えることができます。また、API上のすべてのアクティビティを非常に簡単にトレースできる。

チューニングに関するいくつかの注意点。Ethernetでは、5秒（このコードで使用した有効時間）は多いように思える。ストレスの多いWiFiネットワークでは、30秒以上のpingレイテンシーを得ることができます。有効期限にあまりに攻撃的な値を使用すると、まだそこにあるノードを切断してしまうことになります。一方、エンドユーザーアプリケーションは、ある種の活気を期待しています。ノードが消えたことを報告するのに30秒かかると、ユーザーはイライラしてしまいます。

適切な戦略としては、消えたノードを迅速に検出して報告し、より長い間隔をおいてから削除することです。視覚的には、ノードが生きているときは緑色で、手が届かなくなるとしばらく灰色になり、最後に消えるという感じです。今はまだやっていませんが、私たちが作っているまだ名前のないフレームワークの実際の実装では、これを行う予定です。

後述するように、UDPビーコンだけでなく、ノードからのあらゆる入力を生存の証として扱わなければならない。TCPトラフィックが多いと、UDPはつぶされてしまうかもしれません。これが、既存のUDPディスカバリー・ライブラリを使用しない主な理由です。これを動作させるためには、ZeroMQメッセージングと緊密に統合する必要があります。

### UDPについてもっと知りたい {#More-About-UDP}

つまり、UDP IPv4ブロードキャストでディスカバリーとプレゼンスが動作しているのです。理想的ではありませんが、現在のローカルネットワークではうまくいっています。しかし、UDPを実際の業務に使用することはできません。UDPにはジョークがありますが、わかるときとわからないときがあります。

一対一のメッセージングにはTCPを使うことにしましょう。ディスカバリーの後にもう1つUDPのユースケースがあり、それはマルチキャストファイル配信です。その理由と方法を説明し、別の日に持ち越します。なぜかというと、私たちが「ソーシャルネットワーク」と呼んでいるものは、拡張された文化に過ぎないからです。私たちは共有することで文化を創造しますが、これは、私たちが作ったりリミックスしたりした作品を、より多く共有することを意味します。写真、文書、契約書、ツイート。私たちが目指しているデバイスのクラウドは、これをより多く、より少なくするものではありません。

さて、コンテンツの共有には、2つの主要なパターンがあります。1つは、1つのノードが他のノードに同時にコンテンツを送信するPub-Subパターンです。もうひとつは「レイトジョイナー」と呼ばれるパターンで、あるノードがやや遅れてやってきて、会話に追いつこうとするものです。レイトジョイナーには、TCPユニキャストで対応することができます。しかし、TCPユニキャストをクライアントのグループに対して同時に行うことには、いくつかのデメリットがあります。第一に、マルチキャストより遅くなることがあります。第二に、一部の人が他の人より先にコンテンツを入手することになるため、不公平感があります。

UDPマルチキャストプロトコルの設計に取り掛かる前に、単純な計算ではないことを理解しておいてください。マルチキャストパケットを送信するとき、WiFiアクセスポイントは、最も遠いデバイスでも安全にそれを取得できるように、低いビットレートを使用します。ほとんどの通常のAPは、最も遠いデバイスの距離を測定してそのビットレートを使用するという、当たり前の最適化を行いません。その代わりに、固定値を使用します。そのため、APの近くに数台のデバイスがある場合、マルチキャストの速度が極端に遅くなります。しかし、教科書の次の章を読みたがっている機器が部屋中にあれば、マルチキャストは非常に効果的です。

ネットワークにもよりますが、約6～12台のデバイスで曲線が交差します。理論的には、カーブをリアルタイムで測定して、適応的なプロトコルを作成することができます。それはクールなことですが、おそらく最も賢い人たちにとっても難しすぎることでしょう。

もし、UDPマルチキャストプロトコルのスケッチをするのであれば、失われたパケットを回収するためのチャネルが必要であることを理解してください。おそらく、ZeroMQを使用してTCP上でこれを行いたいと思うでしょう。しかし、今のところ、UDPのマルチキャストのことは忘れて、すべてのトラフィックがTCPで行われると仮定することにします。

## Spinning Off a Library Project {#Spinning-Off-a-Library-Project}

しかし、この段階では、コードが例よりも大きくなっているので、適切な GitHub プロジェクトを作成する必要があります。これはルールです。プロジェクトを一般公開し、その都度人々に伝えることで、マーケティングとコミュニティ形成を初日から行うことができます。そのために、初日からマーケティングとコミュニティ作りを始めるのです。第6章 ZeroMQコミュニティ](chapter6#the-community)で、プロジェクト周辺のコミュニティの成長について説明しました。私たちはいくつかのものを必要としています：

* 名前
* スローガン
* 公開されたgithubリポジトリ
* C4プロセスへのリンクとなるREADME
* ライセンスファイル
* イシュー・トラッカー
* 2人のメンテナ
* 最初のブートストラップバージョン

名前とスローガンが先。21世紀の商標はドメイン名である。だから、プロジェクトをスピンオフさせるときに最初にすることは、うまくいきそうなドメイン名を探すことです。かなりランダムに、私たちの古いメッセージングプロジェクトの1つが「Zyre」と呼ばれていて、私はそのドメイン名を持っています。正式名称は、ZeroMQ Realtime Exchange frameworkという略語です。

私は、新しいプロジェクトをZeroMQコミュニティに積極的に押し込むことをやや恥ずかしがっていて、通常は私の個人アカウントかiMatixの組織のどちらかでプロジェクトを開始することにしています。しかし、人気が出てからプロジェクトを動かすのは逆効果であることを学びました。私の予想では、動く部品で埋め尽くされた未来は、有効か無効かのどちらかです。もしこの章が妥当なら、最初からZeroMQのプロジェクトとして立ち上げたほうがいいかもしれません。もし間違っていれば、後でリポジトリを削除するか、忘れ去られた長い開始リストの底に沈めることができます。

基本的なことから始めましょう。プロトコル（UDPとZeroMQ/TCP）はZRE（ZeroMQ Realtime Exchange protocol）、プロジェクトはZyreとします。2人目のメンテナが必要なので、友人のDong Min（純粋なJavaのZeroMQスタックであるJeroMQを開発した韓国のハッカー）に参加してもらうことにしました。彼は非常に似たようなアイデアに取り組んでいたので、熱意があります。私たちはこのことについて話し合い、JeroMQの上にZyreを構築し、さらにCZMQと<tt>libzmq</tt>の上にも構築するというアイデアを得ました。そうすれば、Android 上で Zyre を実行するのがより簡単になります。また、最初から 2 つの完全に分離した実装が得られるので、プロトコルとしては常に良いことです。

そこで、[第7章 ZeroMQを使った高度なアーキテクチャ](chapter7#advanced-architecture)で構築したFileMQプロジェクトをテンプレートとして、新しいGitHubプロジェクトを作成します。GNU autoconfツールはかなりまともですが、構文が苦しいです。既存のプロジェクトファイルをコピーして修正するのが一番簡単です。FileMQプロジェクトは、ライブラリを構築し、テストツール、ライセンスファイル、マニュアルページなどを備えています。あまり大きくないので、良い出発点だと思います。

プロジェクトの目標を要約し、C4を指し示すためにREADMEをまとめました。新しいGitHubプロジェクトでは、課題追跡機能がデフォルトで有効になっているので、UDP pingのコードを最初のバージョンとしてプッシュしたら、もう準備は完了です。しかし、より多くのメンテナを募集するのは常に良いことなので、私は「メンテナ募集」というイシューを作成し、次のように述べています：

> もし、緑色の「Merge Pull Request」ボタンをクリックするのを手伝いたいなら、http://rfc.zeromq.org/spec:22 の C4 プロセスを読み、理解したことを確認するコメントを追加してください。

最後に、イシュー・トラッカーのラベルを変更します。デフォルトでは、GitHubには様々なタイプのイシューが用意されていますが、C4ではそれを使いません。その代わり、2つのラベル（"Urgent "は赤、"Ready "は黒）が必要なだけです。

## ポイント・トゥ・ポイント・メッセージング {#Point-to-Point-Messaging}

前回のUDP pingプログラムを利用して、その上にポイントツーポイントメッセージングレイヤーを構築することにします。目標は、ネットワークに参加したり離脱したりするピアを検出し、そのピアにメッセージを送り、返信を得ることです。この問題を解決するのは非自明なことで、「Hello World」バージョンを動作させるのに、ミンと私で2日かかりました。

私たちは、いくつかの問題を解決しなければなりませんでした：

* UDPビーコンでどのような情報を送信するか、そしてそれをどのようにフォーマットするか。
* ノードを相互接続するために使用するZeroMQソケットタイプ。
* どのようなZeroMQメッセージを送信するか、またどのようにフォーマットするか。
* 特定のノードにメッセージを送信する方法。
* 返信を送信できるように、メッセージの送信者を知る方法。
* 失われたUDPビーコンから回復する方法。
* ビーコンでネットワークに過負荷をかけない方法。

私たちがなぜこのような選択をしたのか、その理由を理解していただくために、コードの断片を交えながら、これらを詳しく説明することにします。このコードには [version 0.1.0](https://github.com/zeromq/zyre/zipball/v0.1.0) というタグを付けましたので、コードを見ることができます: 難しい作業のほとんどは <tt>zre_interface.c</tt> で行われています。

### UDP ビーコンフレーミング {#UDP-Beacon-Framing}

ネットワークにUUIDを送ることは、論理的なアドレス指定スキームとして最低限必要なことです。しかし、これが実際に使われるようになるには、さらにいくつかの点を解決する必要があります：

* 無効なパケットをチェックし、拒否できるように、プロトコルの識別が必要である。
* このプロトコルを時間と共に変更できるように、バージョン情報が必要である。
* 他のノードにTCP経由でのアクセス方法、つまりZeroMQポートで会話できるようにする必要があります。

ビーコン・メッセージのフォーマットから始めましょう。おそらく、将来のバージョンで変わることのない固定プロトコルヘッダと、バージョンに依存するボディが必要でしょう。

{{< textdiagram name="fig67.png" figno="67" title="ZRE discovery message" >}}
#---+---+---+------#  #------+------#
| Z | R | E | %x01 |  | UUID | port |
#---+---+---+------#  #------+------#

       Header               Body
{{< /textdiagram >}}

UUIDは16バイト、ポートは2バイトのポート番号で、UDPは受信するメッセージごとに送信者のIPアドレスをきれいに教えてくれるからです。これで22バイトのフレームができあがります。

C言語（とErlangのような他のいくつかの言語）は、バイナリ構造の読み書きを簡単にします。ビーコンフレーム構造を定義します：

{{< fragment name="zyre-beacon" >}}
#define BEACON_PROTOCOL     "ZRE"
#define BEACON_VERSION      0x01

typedef struct {
    byte protocol [3];
    byte version;
    uuid_t uuid;
    uint16_t port;
} beacon_t;
{{< /fragment >}}

これにより、ビーコンの送受信が非常に簡単になります。以下は、<tt>zre_udp</tt>クラスを使って、移植性のないネットワーク呼び出しを行い、ビーコンを送信する方法です：

{{< fragment name="zyre-beacon-send" >}}
//  Beacon object
beacon_t beacon;

//  Format beacon fields
beacon.protocol [0] = 'Z';
beacon.protocol [1] = 'R';
beacon.protocol [2] = 'E';
beacon.version = BEACON_VERSION;
memcpy (beacon.uuid, self->uuid, sizeof (uuid_t));
beacon.port = htons (self->port);

//  Broadcast the beacon to anyone who is listening
zre_udp_send (self->udp, (byte *) &beacon, sizeof (beacon_t));
{{< /fragment >}}

ビーコンを受信した場合、偽のデータに対するガードが必要です。例えば、サービス拒否攻撃などに対して偏執的になるつもりはない。悪い ZRE 実装が誤ったフレームを送信してきたときに、クラッシュしないようにしたいだけです。

フレームを検証するために、そのサイズとヘッダーをチェックします。それらが問題なければ、本体は使用可能であると判断します。自分自身ではないUUIDを取得した場合（自分自身のUDPブロードキャストが戻ってくることを思い出してください）、これをピアとして扱うことができます：

{{< fragment name="zyre-beacon-recv" >}}
//  Get beacon frame from network
beacon_t beacon;
ssize_t size = zre_udp_recv (self->udp,
    (byte *) &beacon, sizeof (beacon_t));

//  Basic validation on the frame
if (size != sizeof (beacon_t)
||  beacon.protocol [0] != 'Z'
||  beacon.protocol [1] != 'R'
||  beacon.protocol [2] != 'E'
||  beacon.version != BEACON_VERSION)
    return 0;               //  Ignore invalid beacons

//  If we got a UUID and it's not our own beacon, we have a peer
if (memcmp (beacon.uuid, self->uuid, sizeof (uuid_t))) {
    char *identity = s_uuid_str (beacon.uuid);
    s_require_peer (self, identity,
        zre_udp_from (self->udp), ntohs (beacon.port));
    free (identity);
}
{{< /fragment >}}

### 真のピア接続（ハーモニーパターン） {#True-Peer-Connectivity-Harmony-Pattern}

ZeroMQは分散メッセージングを簡単にするように設計されているため、真のピア（明白なクライアントとサーバーと比較して）のセットを相互接続する方法を尋ねる人がよくいます。これは難しい問題で、ZeroMQは明確な答えを1つだけ提供しているわけではありません。

ZeroMQで最もよく使われるトランスポートであるTCPは対称的ではありません。一方はバインドしなければならず、一方は接続しなければなりませんが、ZeroMQはこれに関して中立であろうとします。接続すると、発信メッセージパイプが作成されます。バインドすると、そうではありません。パイプがない場合、メッセージを書き込むことはできません（ZeroMQは<tt>EAGAIN</tt>を返します）。

ZeroMQを研究し、等しいピアのセット間でN対N接続を作成しようとする開発者は、しばしばROUTERからROUTERへのフローを試みます。理由は明らかで、各ピアがピアのセットをアドレスする必要があり、それにはROUTERが必要だからです。通常、このフローは、リストへの平凡な電子メールで終わります。

経験上、ROUTER-to-ROUTERをうまく使うのは特に困難です。少なくとも、1つのピアがバインドし、1つのピアが接続しなければならず、アーキテクチャが対称的でないことを意味します。つまり、アーキテクチャが対称的でないということです。つまり、ピアに話しかけられたら話しかけられるが、ピアに話しかけられるまでは話しかけられないという、キャッチボール状態になってしまうのです。どちらか一方がメッセージを失うため、リトライしなければならず、つまりピアが対等であることはありえない。

この問題を解決する、Zyreで使っているHarmonyパターンを説明します。

ネットワーク上にピアが「出現」したときに、ZeroMQがメッセージをドロップすることなく、安全に会話できることを保証したい。そのためには、ピアに接続するDEALERソケットやPUSHソケットを使用する必要があり、接続にゼロではない時間がかかったとしても、すぐにパイプができ、ZeroMQは送信メッセージを受け入れることができます。

DEALERソケットは、複数のピアを個別にアドレス指定することはできません。しかし、1つのピアに対して1つのDEALERを用意し、そのDEALERをピアに接続すれば、ピアに接続した時点で安全にメッセージを送信することができる。

さて、次の問題は、誰が特定のメッセージを送ってきたかを知ることです。任意のメッセージを送信したノードのUUIDである返信アドレスが必要です。DEALERでは、すべてのメッセージの前に16バイトのUUIDを付けない限り、これを行うことはできませんが、これは無駄なことです。ROUTERは、ルーターに接続する前にIDを適切に設定すれば、それが可能です。

そして、Harmonyのパターンは、以下の構成要素に集約されます：

* ROUTERソケットを1つ、エフェメラルポートにバインドし、ビーコンでブロードキャストする。
* ピアのROUTERソケットに接続する、ピアごとに1つのDEALERソケット。
* ROUTERソケットから読み込む。
* 相手のDEALERソケットに書き込みます。

次の問題は、ディスカバリーがきちんと同期していないことです。ピアから最初のビーコンを取得できるのは、ピアからメッセージを受信し始めた後です。メッセージはROUTERソケットに届き、素敵なUUIDが添付されていますが、物理的なIPアドレスとポートがありません。TCP上で強制的に検出する必要があります。これを行うには、接続する新しいピアに対する最初のコマンドは、IP アドレスとポートを持つ <tt>OHAI</tt> コマンドになります。これにより、コマンドを送信しようとする前に、受信者が私たちに接続し直すことを確実にします。

以下は、その手順です：

* 新しいピアからUDPビーコンを受信すると、DEALERソケットを通してそのピアに接続します。
* ROUTERソケットからメッセージを読み、各メッセージには送信者のUUIDが付属しています。
* もしそれが<tt>OHAI</tt>メッセージであれば、まだそのピアに接続されていない場合、そのピアに接続し直します。
* 他のメッセージであれば、そのピアにすでに接続している必要があります（アサーションのための良い場所）。
* 各ピアへのメッセージ送信は、ピアごとのDEALERソケットを使用し、接続されている必要があります。
* ピアに接続すると、そのピアが存在することをアプリケーションにも伝えます。
ピアに接続するとき、ピアに存在することをアプリケーションにも伝えます * ピアからメッセージを受け取るたびに、それをハートビートとして扱います（それは生きています）。

UDPではなく、他の発見メカニズムを使っていたとしても、私は真のピアネットワークのためにHarmonyパターンを使用します。ROUTER をバインドし、DEALER を接続し、戻り IP アドレスとポートを提供する <tt>OHAI</tt> 相当で各会話を開始します。各接続をブートストラップするために、何らかの外部メカニズムが必要でしょう。

### 失踪の検出 {#Detecting-Disappearances}

ハートビートって簡単そうだけど、そうでもないんだよね。UDPパケットはTCPトラフィックが多いときにドロップされるので、UDPビーコンに依存すると、偽の切断が発生することになります。TCPトラフィックは、ネットワークが本当に混雑している場合、5秒、10秒、30秒と遅れることがあります。そのため、ネットワークが静かになったときにピアを殺すと、誤った切断が発生します。

UDPビーコンは信頼できないので、TCPビーコンを追加したくなります。結局のところ、TCPは確実にビーコンを配信してくれます。しかし、1つだけ小さな問題があります。ネットワーク上に100台のノードがあり、各ノードが1秒に1回TCPビーコンを送信すると想像してください。各ビーコンは、TCPのフレーミング・オーバーヘッドを除いて22バイトです。つまり、1秒間に100 * 99 * 22バイト、つまり217,000バイト/秒が心拍数として発生します。これは、一般的なWiFiネットワークの理想的な容量の約1～2％で、問題ないと思われます。しかし、ネットワークにストレスがかかったり、他のネットワークと空域を争ったりすると、1秒間に20万バイトの追加で、残りの容量が壊れてしまいます。UDPブロードキャストは、少なくとも低コストです。

そこで、特定のピアからしばらくUDPビーコンが送られてこない場合のみ、TCPハートビートに切り替えることにしています。そして、その1つのピアに対してのみTCPハートビートを送信します。そのピアが沈黙を続けている場合は、そのピアがいなくなったと判断します。もし、そのピアが別のIPアドレスやポートで戻ってきたら、DEALERソケットを切断し、新しいポートに再接続する必要があります。

これにより、各ピアの状態が得られますが、現段階では正式なステートマシンは使用していません：

* UDPビーコンのおかげでピアが見える（ビーコンのIPアドレスとポートを使って接続する）。
<tt>OHAI</tt> コマンドのおかげでピアが見える (コマンドの IP アドレスとポートを使用して接続します)
* ピアは生きているようです（最近、UDPビーコンまたはTCP上のコマンドを取得しました）。
* ピアは静かなようです (しばらく活動がなかったので、<tt>HUGZ</tt>コマンドを送りました)
* ピアが消えた (<tt>HUGZ</tt> コマンドに応答がないため、ピアを破棄した)

この段階のコードで対処していないシナリオが 1 つ残っています。実際に消滅イベントをトリガーすることなく、ピアが IP アドレスとポートを変更することは可能です。たとえば、ユーザーがWiFiをオフにしてからオンに戻すと、アクセス・ポイントはピアに新しいIPアドレスを割り当てることができます。ROUTERソケットのバインドを解除し、可能な限り再バインドすることで、ノード上で消えたWiFiインターフェイスを処理する必要があります。これは今の設計の中心ではないので、GitHubのトラッカーにissueを記録して、雨の日のために残しておくことにしました。

## グループメッセージング {#Group-Messaging}

グループメッセージングとは、一般的で非常に便利なパターンです。コンセプトは単純で、1つのノードに話しかけるのではなく、ノードの「グループ」に話しかけるのです。グループは単なる名前であり、アプリケーションで合意した文字列です。まさに、PUBソケットやSUBソケットでpub-subという接頭辞を使うようなものです。実は、「PUB-SUB」ではなく「グループ・メッセージング」と言ったのは、混乱を防ぐためです。

PUB-SUBソケットならほとんど使えるでしょう。しかし、私たちは、レイトジョイナー問題を解決するために、これほど多くの作業を行ったばかりです。アプリケーションは、グループにメッセージを送る前にピアが到着するのを待つことが避けられないので、Harmonyパターンの横で再び始めるのではなく、Harmonyパターンの上に構築する必要があるのです。

グループに対して行いたい操作について見てみましょう：

* グループへの参加と離脱をしたい。
* グループへの参加、脱退をしたい。
* グループへの参加、脱退をしたい。

これらは、インターネットリレーチャットを使ったことがある人にはおなじみのようですが、サーバーがないことを除けば、そうではありません。各ノードは、各グループが何を表しているかを追跡する必要があります。この情報は、ネットワーク上で常に完全に一貫しているわけではありませんが、十分に近いものになるでしょう。

私たちのインターフェースは、グループのセット（それぞれがオブジェクト）を追跡します。これらは、私たち自身を除く、1つ以上のメンバーノードを持つすべての既知のグループである。ノードはグループから離脱したり、グループに参加したりするので、それを追跡します。ノードはいつでもネットワークに参加できるため、新しい仲間に自分がどのグループに属しているのかを伝える必要があります。ピアがいなくなったら、私たちが知っているすべてのグループからそのピアを削除します。

これにより、いくつかの新しいプロトコル コマンドが得られます：

<tt>JOIN</tt> - グループに参加するときに、すべてのピアにこれを送信します。
<tt>JOIN</tt> - グループに参加するときに、すべてのピアにこれを送ります。

さらに、最初に送信するコマンドに <tt>groups</tt> フィールドを追加します (コマンド動詞のより大きな語彙が必要なので、この時点で <tt>OHAI</tt> から <tt>HELLO</tt> に改名しました)。

最後に、仲間たちが自分のグループ データの正確さを再確認する方法を追加しましょう。リスクは、上記のメッセージのいずれかを見逃してしまうことです。起動時の典型的なメッセージロスを避けるためにHarmonyを使用していますが、妄想してみる価値はあります。今のところ、必要なのはそのような障害を検出する方法だけです。実際に問題が発生した場合の復旧については、後で対処することにしよう。

これにはUDPビーコンを使うことにしよう。私たちが欲しいのは、あるノードの参加と離脱の操作（「トランジション」）が何回あったかを示す、単純なローリング・カウンタです。0から始まり、グループに参加または離脱するたびに増加します。最小限の1バイトの値を使用することで、天文学的に稀な「256のメッセージを連続して失った」という失敗（これは最初のデモで発生したものです）を除くすべての失敗を捕らえることができるからです。また、<tt>JOIN</tt>、<tt>LEAVE</tt>、<tt>HELLO</tt> コマンドにトランジション カウンターを入れる予定です。そして、問題を誘発するために、高水準を10程度に設定した数百のグループに参加/離脱してテストすることにします。

そろそろ、グループメッセージの動詞を選ぶ時期です。一人の仲間と話す」という意味のコマンドと、「多くの仲間と話す」という意味のコマンドが必要です。何度か試した結果、私のベストチョイスは<tt>WHISPER</tt>と<tt>SHOUT</tt>で、このコードはこれを使用しています。<tt>SHOUT</tt> コマンドは、送信元ピアだけでなく、グループ名もユーザーに伝える必要があります。

グループは pub-sub のようなものなので、これを使用して <tt>JOIN</tt> と <tt>LEAVE</tt> コマンドをブロードキャストし、おそらくすべてのノードが参加する「グローバル」グループを作成したくなることがあります。私のアドバイスとしては、2 つの理由から、グループは純粋にユーザー スペースの概念として維持することです。まず、<tt>JOIN</tt> コマンドを送信するためにグローバル グループが必要な場合、どのようにしてグローバル グループに参加するのでしょうか。2つ目は、面倒な特別なケース (予約名) を作成することです。

接続されているすべてのピアに <tt>JOIN</tt> と <tt>LEAVE</tt> を明示的に送信するほうがシンプルです。

グループ メッセージングの実装を詳しく説明するつもりはありません。なぜなら、かなり衒学的であまりエキサイティングではないからです。グループとピアの管理のためのデータ構造は、最適ではありませんが、実行可能です。私たちは以下のものを使っています：

<tt>HELLO</tt> コマンドで新しいピアに送ることができる、私たちのインターフェイスのグループのリスト；
* 他のピアのグループのハッシュで、<tt>HELLO</tt>、<tt>JOIN</tt>、<tt>LEAVE</tt> コマンドからの情報で更新されます；
* 各グループのピアのハッシュで、同じ3つのコマンドで更新されます。

この段階で、文字列や整数だけでなくリストや辞書も扱えるバイナリー・シリアライズ（[第7章 ZeroMQを使った高度なアーキテクチャ](chapter7#advanced-architecture)のコーデック生成器）にかなり満足し始めているところです。

このバージョンはリポジトリにv0.2.0とタグ付けされており、この段階でどのようなコードになっているかを確認したい場合は、[tarballをダウンロード](https://github.com/zeromq/zyre/tags)してください。

## テストとシミュレーション {#Testing-and-Simulation}

Zyreのような分散型フレームワークも含めて、製品を断片的に構築する場合、それが実際に正しく動作することを知る唯一の方法は、それぞれの断片で実際の活動をシミュレートすることです。

### アサーションについて {#On-Assertions}

アサーションの適切な使用は、プロのプログラマーの特徴の1つです。

クリエイターとしての確証バイアスは、自分の作品を適切にテストすることを難しくしています。私たちは、コードが動作しないことを証明しようとするのではなく、コードが動作することを証明するためにテストを書きがちです。これには多くの理由があります。私たちは自分自身にも他人にも、完璧である（かもしれない）ように装っていますが、実際には常に間違いを犯しているのです。コードのバグは「不可避」ではなく「悪」とみなされるため、心理的に、より多くのバグを発見するのではなく、より少ないバグを発見したいと思うのです。「彼は完璧なコードを書く」というのは、「彼はリスクを取らないので、彼のコードは冷たいスパゲッティのように退屈で多用されている」という意味の婉曲表現ではなく、褒め言葉なのです。

文化によっては、教育や仕事において完璧を求め、間違いを罰するよう教えているところもあり、このような態度をより悪化させます。自分が誤りやすいことを受け入れ、それを恥ではなく利益に変える方法を学ぶことは、あらゆる職業において最も難しい知的訓練の一つです。私たちは、他の人と一緒に仕事をしたり、自分の仕事に早く挑戦したりすることで、自分の誤りを活用することができます。

それを容易にする一つのコツは、アサーションを使うことです。アサーションは、エラー処理の一形態ではありません。アサーションは、実行可能な事実の理論です。コードは、「この時点で、このようなことが真でなければならない」と主張し、もし主張が失敗すれば、コードは自滅する。

コードが正しくないと証明できればできるほど、より速く、より正確に修正することができます。コードが動くと信じて、それが期待通りに動くことを証明するのは、科学というより魔法のような思考です。<tt>libzmq</tt>には500個のアサーションがあり、私のあらゆる努力にもかかわらず、そのうちの1つも失敗しなかった」と言える方がはるかに良いのです。

そのため、Zyreのコードベースにはアサーションが散りばめられており、特にピアの状態を扱うコードには2つほど含まれています。ピアがお互いを追跡し、正確に状態を交換しなければ、物事は動かなくなります。アルゴリズムは、非同期メッセージが飛び交うことに依存しており、最初の設計に欠陥があったことは間違いありません。いつもそうなんです。

そして、<tt>zre_ping</tt>のインスタンスを手で起動したり停止したりして、オリジナルのZyreコードをテストすると、しばしばアサーションに失敗することがあります。手で動かしても再現しないことが多いので、ちゃんとしたテスターツールを作ろう。

### オンアップフロントテスト {#On-Up-Front-Testing}

実験室で個々の部品の実際の挙動を十分にテストできると、プロジェクトのコストに10倍、100倍の差が出ることがあります。エンジニアが自分の仕事に対して持つ確証バイアスは、アップフロントテストを信じられないほど収益性の高いものにし、レイトステージテストを信じられないほど高価なものにします。

1990年代後半に私たちが取り組んだプロジェクトについて、短いエピソードをお話ししましょう。ある工場の自動化プロジェクトで、私たちがソフトウェアを、他のチームがハードウェアを提供しました。3、4チームが専門家を現場に連れてきたのですが、そこは辺鄙な工場でした（汚染をもたらす工場がいつも辺鄙な国境地帯にあるのはおかしな話です）。

そのうちの1チーム、産業オートメーションに特化した会社は、チケットマシン：キオスクと、その上で動作するソフトウェアを作りました。バッジをスワイプし、オプションを選択し、チケットを受け取るというものだ。彼らはこのキオスクを2台、現地で組み立て、毎週、いくつかの部品を運んできた。チケットプリンター、モニター画面、イスラエル製の特殊なキーパッド。キオスク端末は屋外に置かれるため、埃に強いものでなければならない。しかし、何一つうまくいかない。スクリーンは太陽の光で読めなくなる。チケットプリンターは常にジャムり、ミスプリントし続けた。キオスクの内部は木製の棚に置かれているだけでした。キオスクのソフトは定期的にクラッシュした。しかし、このプロジェクトは本当に、本当に、本当に、うまくいかなければならなかったので、私たちは何週間も、そして何カ月も現場で他のチームのデバッグを手伝い、うまくいくようにしました。

1年後、2つ目の工場があり、同じようなことがありました。このころには、クライアントも焦っていました。そこで、1年後、3番目の大きな工場に来たとき、私たちは飛び上がって、「キオスクやソフトウェアなど、すべてを私たちに作らせてください」と言いました。

ソフトとハードの詳細設計をし、すべてのパーツの仕入先を探しました。インターネットで部品を探すのに3カ月かかり（当時はもっと遅かった）、さらに2カ月かけて、重さ約20キロのステンレス製のレンガに組み上げた。このレンガは2フィート四方、奥行き8インチで、割れないガラスの向こうに大きなフラットスクリーン・パネルがあり、電源用とイーサネット用の2つのコネクターがありました。電源とイーサネットの2つのコネクターがあり、紙箱に6ヶ月分の電力を入れてから筐体にねじ込むと、自動的に起動してDNSサーバーを見つけ、Linux OSとアプリケーションソフトをロードした。実際のサーバーに接続すると、メインメニューが表示される。設定画面へは、特別なバッジをスワイプしてコードを入力することでアクセスできる。

ソフトウエアはポータブルなので、書きながらテストすることができました。また、サプライヤーから部品を集める際に、分解して遊べるキオスクを1台ずつ確保しました。完成したキオスク端末は、どれもすぐに動きました。クライアントは筐体に接続して電源を入れ、業務を開始しました。私たちは現場で1週間ほど過ごしましたが、10年間でキオスクが壊れたのは1台だけでした（スクリーンが壊れて交換しました）。

教訓は、前もってテストしておくことで、製品を接続したときに、それがどのように動作するかを正確に把握することができるということです。もし、前もってテストしていなければ、現場で何週間も何ヶ月もかけて、あるはずのない問題を解決することになります。

### ザイルテスター {#The-Zyre-Tester}

手動テスト中に、まれにアサーションがヒットすることがありました。そして、それは消えてしまった。私は魔法を信じないので、それはコードがまだどこかで間違っていることを意味することが分かっています。そこで、次のステップとして、Zyre v0.2.0のコードを徹底的にテストして、アサーションを解除し、フィールドでどのように動作するかの良いアイデアを得ようとしました。

私たちは、ディスカバリーとメッセージング機能を、メインプログラムが作成し、操作し、破棄する*インターフェース*オブジェクトとしてパッケージ化しました。グローバル変数は使いません。このため、1つのプロセスで大量のインターフェイスを簡単に起動し、実際の活動をシミュレートすることができます。そして、たくさんの例を書いてわかったことがあるとすれば、ZeroMQの1つのプロセスで複数のスレッドをオーケストレーションする機能は、複数のプロセスよりも*ずっと*扱いやすいということです。

テスターの最初のバージョンは、メインスレッドで構成され、それぞれが1つのインターフェースを実行し、ROUTER、DEALER、UDPソケット（図ではR、D、U）を持つ子スレッドのセットを開始および停止します。

{{< textdiagram name="fig68.png" figno="68" title="Zyre Tester Tool" >}}
                        #----------#
                        |   Main   |
                        |  thread  |
                        #-----+----#
                              |
                              |
      .---------------+-------+-------+---------------.
      |               |               |               |
      v               v               v               v
#-----------#   #-----------#   #-----------#   #-----------#
|  Child    |   |  Child    |   |  Child    |   |  Child    |
|  thread   |   |  thread   |   |  thread   |   |  thread   |
#-----+-----#   #-----+-----#   #-----+-----#   #-----+-----#
      |               |               |               |
      v               v               v               v
#-----------#   #-----------#   #-----------#   #-----------#
| Interface |   | Interface |   | Interface |   | Interface |
+---+---+---+   +---+---+---+   +---+---+---+   +---+---+---+
| R | D | U |   | R | D | U |   | R | D | U |   | R | D | U |
#---+---+---#   #---+---+---#   #---+---+---#   #---+---+---#
{{< /textdiagram >}}

素晴らしいのは、私がWiFiアクセスポイントに接続しているとき、すべてのZyreトラフィック（同じプロセス内の2つのインターフェース間でも）はAPを通過することです。つまり、部屋の中で数台のPCを動かすだけで、あらゆるWiFiインフラを完全にストレステストすることができるのです。もしZyreをAndroid専用のサービスとして構築していたら、大規模なテストを行うためには、文字通り何十台ものAndroidタブレットや携帯電話が必要になっていたことでしょう。キオスクのようなものです。

今は、現在のコードを壊して、その間違いを証明することにフォーカスしています。この段階では、動作の良し悪しや速さ、メモリの使用量などをテストすることに意味はないのですが、それ以外のことをテストしていきます。個々の機能を壊してみる（そして失敗する）ところまでやりますが、まずは、私がコードに入れたコアなアサーションをいくつか壊してみます。

以下はその例です：

* どのノードもピアから受け取る最初のコマンドは <tt>HELLO</tt> でなければなりません。言い換えれば、ピアツーピアの接続プロセス中にメッセージが失われることはありません。

* 各ノードがピアのために計算する状態は、各ピアが自身のために計算する状態と一致します。言い換えれば、やはり、ネットワーク上でメッセージが失われることはない。

* 私のアプリケーションがピアにメッセージを送信するとき、そのピアとの接続があります。言い換えれば、アプリケーションは、私たちがピアとのZeroMQ接続を確立した後にのみ、そのピアを「見る」のです。

ZeroMQでは、メッセージが失われる可能性があるケースがいくつかあります。1つは、「レイトジョイナー」症候群です。2つ目は、すべてを送信せずにソケットをクローズした場合です。3つ目は、ROUTERやPUBのソケットでハイウォーターマークをオーバーフローしてしまった場合です。4つ目は、ROUTERソケットで未知のアドレスを使用する場合です。

さて、Harmonyはこれらの潜在的なケースをすべて回避することができると思います。しかし、私たちはミックスにUDPを追加しています。そこで、テスターの最初のバージョンは、ノードがランダムに出入りする不安定で動的なネットワークをシミュレートします。ここで、物事が壊れてしまうのです。

このテスターのメインスレッドは、100個のスレッドのプールを管理し、それぞれをランダムに開始・停止します。750ミリ秒ごとにランダムなスレッドを1つ起動したり停止したりします。スレッドがすべて同期しないように、タイミングをランダムにしています。数分後、平均50個のスレッドが、地下鉄江南駅の韓国のティーンエイジャーのように楽しくおしゃべりをしています：

{{< fragment name="zyre-tester-main" >}}
int main (int argc, char *argv [])
{
    //  Initialize context for talking to tasks
    zctx_t *ctx = zctx_new ();
    zctx_set_linger (ctx, 100);

    //  Get number of interfaces to simulate, default 100
    int max_interface = 100;
    int nbr_interfaces = 0;
    if (argc > 1)
        max_interface = atoi (argv [1]);

    //  We address interfaces as an array of pipes
    void **pipes = zmalloc (sizeof (void *) * max_interface);

    //  We will randomly start and stop interface threads
    while (!zctx_interrupted) {
        uint index = randof (max_interface);
        //  Toggle interface thread
        if (pipes [index]) {
            zstr_send (pipes [index], "STOP");
            zsocket_destroy (ctx, pipes [index]);
            pipes [index] = NULL;
            zclock_log ("I: Stopped interface (%d running)",
                --nbr_interfaces);
        }
        else {
            pipes [index] = zthread_fork (ctx, interface_task, NULL);
            zclock_log ("I: Started interface (%d running)",
                ++nbr_interfaces);
        }
        //  Sleep ~750 msecs randomly so we smooth out activity
        zclock_sleep (randof (500) + 500);
    }
    zctx_destroy (&ctx);
    return 0;
}
{{< /fragment >}}

各子スレッドへの*パイプ*を維持していることに注意してください（<tt>zthread_fork</tt>メソッドを使用すると、CZMQは自動的にパイプを作成します）。このパイプを介して、子スレッドに退出するときに停止するように指示します。子スレッドは以下のような処理を行います（わかりやすくするために擬似コードに切り替えています）：

```
create an interface
while true:
    poll on pipe to parent, and on interface
    if parent sent us a message:
        break
    if interface sent us a message:
        if message is ENTER:
            send a WHISPER to the new peer
        if message is EXIT:
            send a WHISPER to the departed peer
        if message is WHISPER:
            send back a WHISPER 1/2 of the time
        if message is SHOUT:
            send back a WHISPER 1/3 of the time
            send back a SHOUT 1/3 of the time
    once per second:
        join or leave one of 10 random groups
destroy interface
```

### テスト結果 {#Test-Results}

そうです、私たちはコードを壊しました。実際、何度もだ。これは満足のいくものでした。私たちが発見したさまざまな事柄について説明します。

ノードが一貫したグループ・ステータスに同意することが最も困難でした。グループメッセージング」で説明したように、各ノードはネットワーク全体のグループメンバーシップを追跡する必要があります。グループ メッセージングは、pub-subパターンです。<tt>JOIN</tt>と<tt>LEAVE</tt>は、購読と購読解除のメッセージに類似しています。これらのどれもが紛失しないことが重要で、さもなければ、グループからランダムに脱落するノードを見つけることになります。

そのため、各ノードはこれまでに行った <tt>JOIN</tt> と <tt>LEAVE</tt> の総数をカウントし、UDP ビーコンでこのステータス (1 バイトのローリング カウンター) をブロードキャストしています。他のノードはこのステータスを受け取り、自分たちの計算と比較し、違いがあればコードが主張します。

最初の問題は、UDPビーコンがランダムに遅延するため、ステータスを伝えるのに役に立たないということでした。ビーコンが遅れて到着すると、ステータスが不正確になり、*偽陰性*が発生します。これを修正するために、ステータス情報を <tt>JOIN</tt> コマンドと <tt>LEAVE</tt> コマンドに移動しました。また、<tt>HELLO</tt>コマンドにもそれを追加しました。すると、ロジックは次のようになります：

* ピアの <tt>HELLO</tt> コマンドからピアの初期ステータスを取得します。
* ピアから <tt>JOIN</tt> または <tt>LEAVE</tt> を取得すると、ステータス カウンターをインクリメントします。
* 新しいステータスカウンタが<tt>JOIN</tt>または<tt>LEAVE</tt>コマンドの値と一致するか確認する。
* もしそうでなければ、アサートする。

次の問題は、新しい接続でメッセージが予期せず到着することでした。Harmony パターンは接続し、最初のコマンドとして <tt>HELLO</tt> を送信します。これは、受信側のピアは、新しいピアからの最初のコマンドとして常に<tt>HELLO</tt>を受け取るべきであることを意味します。私たちは、<tt>PING</tt>、<tt>JOIN</tt>、およびその他のコマンドの到着を確認していました。

これは、CZMQ のエフェメラル ポート ロジックが原因であることが判明しました。エフェメラル ポートとは、サービスが固定ポート番号を要求するのではなく、動的に割り当てられるポートに過ぎません。POSIX システムでは、通常 0xC000 から 0xFFFF の範囲でエフェメラルポートが割り当てられます。CZMQのロジックは、この範囲で空いているポートを探し、そこにバインドして、ポート番号を呼び出し元に返すというものです。

しかし、あるノードが停止し、別のノードが開始したときに、新しいノードが古いノードのポート番号を取得するという事態が発生します。ZeroMQは壊れた接続を再確立しようとすることを忘れないでください。そのため、最初のノードが停止すると、そのピアが接続を再試行します。新しいノードが同じポートに現れると、突然すべてのピアがそれに接続し、古い仲間のようにチャットを始める。

これは、大規模な動的ZeroMQアプリケーションに影響する一般的な問題です。もっともらしい答えがいくつもあります。1つは、エフェメラルポートを再利用しないことですが、1つのシステムで複数のプロセスがある場合は、言うは易く行うは難しです。もう1つの解決策は、毎回ランダムなポートを選択することで、少なくとも解放されたばかりのポートにぶつかるリスクを減らすことができます。これによって、ゴミ接続のリスクはおそらく1/1000に減りますが、それでもまだあります。おそらく最良の解決策は、このようなことが起こりうることを受け入れ、原因を理解し、アプリケーションレベルで対処することでしょう。

私たちには、常に <tt>HELLO</tt> コマンドで始まるステートフル プロトコルがあります。私たちは、ピアが私たちに接続し、私たちが離れて戻ってきた既存のノードであると考え、私たちに他のコマンドを送信することが可能であることを理解しています。ステップ 1 は、新しいピアを発見したときに、同じエンドポイントに接続されている既存のピアを破棄することです。これは完全な回答ではありませんが、少なくとも礼儀正しいものです。ステップ 2 は、新しいピアから入ってくるものは、そのピアが <tt>HELLO</tt> と言うまで無視することです。

ZeroMQ接続の仕組み上、*正常な*ピアから予期せぬコマンドを受け取ることがあり、エラーコードを返すか、そうでなければそのピアに接続をリセットするように指示する方法がありません。したがって、ピアは <tt>HELLO</tt> を受け取るまで、ピアからのコマンドを破棄しなければなりません。

実際、これを紙に描いてよく考えてみると、このような接続から<tt>HELLO</tt>を受け取ることはないことがわかると思います。ピアは <tt>PING</tt> と <tt>JOIN</tt> と <tt>LEAVE</tt> を送信し、やがてタイムアウトして閉じます。

また、DEALERソケットの1つのストリームに2つのピアからのコマンドが混在することがなく、混乱の危険性がないこともおわかりいただけるでしょう。

これが動作することに満足したら、次に進む準備ができました。このバージョンはv0.3.0としてリポジトリにタグ付けされており、この段階でコードがどのように見えたかを確認したい場合は、[tarballをダウンロード](https://github.com/zeromq/zyre/tags)してください。

たくさんのノードの重いシミュレーションを行うと、おそらくプロセスがファイルハンドルを使い果たし、<tt>libzmq</tt>でアサーションに失敗することに注意してください。私は、(私のLinuxボックスで)実行することによって、プロセスあたりの制限を30,000に引き上げました：

```
ulimit -n 30000
```

### トレースアクティビティ {#Tracing-Activity}

ここで見たような問題をデバッグするためには、大規模なロギングが必要です。並行して多くのことが起こっていますが、すべての問題は2つのノード間の特定のやりとりにまで遡ることができ、厳密に順番に起こる一連のイベントから構成されています。非常に洗練されたロギングの作り方は知っていますが、いつものように、必要なものだけを作り、それ以上は作らないほうが賢明です。私たちは、以下のものを取得しなければなりません：

* 各イベントの時間と日付。
* どのノードでイベントが発生したか。
* ピアノードがあれば、そのノード。
* イベントが何であったか（例えば、どのコマンドが到着したか）。
* イベントデータ（もしあれば）。

最も単純な方法は、必要な情報をタイムスタンプ付きでコンソールに出力することです。私が使ったのはこの方法です。そうすれば、障害によって影響を受けたノードを見つけ、そのノードを参照するメッセージだけをログファイルにフィルタリングして、何が起こったかを正確に確認することが簡単にできます。

### ブロックされたピアの処理 {#Dealing-with-Blocked-Peers}

パフォーマンスを重視するZeroMQアーキテクチャでは、フロー制御の問題を解決する必要があります。ソケットに無制限にメッセージを送信して、ベストを尽くすことはできません。極端な話、メモリを使い果たす可能性があります。これはメッセージブローカーの典型的な失敗パターンです。ある遅いクライアントがメッセージを受け取らなくなり、ブローカーはそれをキューに入れ始め、最終的にメモリを使い果たし、プロセス全体が死んでしまう。もう一方の極端な例では、高水準に達したときにソケットがメッセージをドロップしたり、ブロックしたりします。

Zyreでは、ピアの集合にメッセージを配信したいのですが、これを公平に行いたいのです。出力に単一のROUTERソケットを使用すると、1つのブロックされたピアがすべてのピアへの送信トラフィックをブロックしてしまうため、問題が発生します。TCPには、ネットワーク容量を一連の接続に分散させるための優れたアルゴリズムがあります。そして、私たちは各ピアと話すために別々のDEALERソケットを使用しているので、理論的には、各DEALERソケットはバックグラウンドでキューに入ったメッセージを合理的に公平に送信することができます。

高水準に達したDEALERソケットの通常の動作は、ブロックすることです。これは通常理想的ですが、私たちにとっては問題です。現在のインターフェース設計では、すべてのピアにメッセージを配信するスレッドを1つ使用しています。もしこれらの送信呼び出しの1つがブロックされた場合、すべての出力がブロックされることになります。

ブロッキングを回避するためのオプションはいくつかあります。一つは、<tt>[zmq_poll()](http://api.zeromq.org/master:zmq_poll)</tt>をDEALERソケットの全セットに使用し、準備ができたソケットにのみ書き込むことです。私はいくつかの理由から、この方法は好きではありません。第一に、DEALERソケットはpeerクラスの中に隠されており、各クラスが不透明な形でこれを処理するほうがすっきりします。第二に、まだDEALERソケットに配信できないメッセージはどうすればいいのか？どこにキューに入れるのでしょうか？第三に、この問題は横道にそれているように思えます。もしピアが本当に忙しくてメッセージを読めないのであれば、何かが間違っている。おそらく、死んでいるのでしょう。

だから、出力のためのポーリングはしない。2つ目の選択肢は、ピアごとに1つのスレッドを使用することです。ZeroMQのデザインパターンである「1つのスレッドで1つのことを行う」に合致しているので、このアイデアは非常に気に入っています。しかし、この場合、シミュレーションに大量のスレッド（開始するノードの数の2乗）が発生し、すでにファイルハンドルが不足しています。

第3の選択肢は、ノンブロッキング送信を使用することです。これはより良い方法であり、私が選択したソリューションです。各ピアに妥当な送信キュー（HWM）を用意し、それがいっぱいになったら、そのピアで致命的なエラーとして扱うことができます。これは小さなメッセージには有効です。大きな塊（例えばコンテンツ配信など）を送る場合は、その上にクレジットベースのフロー制御が必要です。

したがって、最初のステップは、通常のブロッキングDEALERソケットをノンブロッキングソケットに変えることができることを証明することです。この例では、通常のDEALERソケットを作成し、あるエンドポイントに接続し（発信パイプがあり、ソケットがメッセージを受け取れるようにする）、高水準を4とし、送信タイムアウトを0に設定しています：

{{< examples name="eagain" title="Checking EAGAIN on DEALER socket" >}}。

これを実行すると、4つのメッセージが正常に送信され(これらはどこにも行かず、ソケットはそれらをキューに入れるだけです)、その後、見事な<tt>EAGAIN</tt>エラーが表示されます：

```
Sending message 0
Sending message 1
Sending message 2
Sending message 3
Sending message 4
Resource temporarily unavailable
```

次のステップは、ピアにとって妥当な高水準がどの程度になるかを決めることです。Zyreは人間同士のやり取りを想定しています。つまり、2つのゲームや共有の描画プログラムのような、低い頻度でチャットするアプリケーションです。1秒間に100通のメッセージはかなり多いと予想されます。私たちの「ピアは本当に死んでいる」タイムアウトは10秒です。ですから、高水準の1,000というのは公平だと思います。

固定したHWMを設定したり、デフォルト（ランダムに1,000になる）を使用するのではなく、100 * タイムアウトとして計算することにしました。以下は、ピアに新しいDEALERソケットを設定する方法です：

{{< fragment name="zyre-peer-new-socket" >}}
//  Create new outgoing socket (drop any messages in transit)
self->mailbox = zsocket_new (self->ctx, ZMQ_DEALER);

//  Set our caller "From" identity so that receiving node knows
//  who each message came from.
zsocket_set_identity (self->mailbox, reply_to);

//  Set a high-water mark that allows for reasonable activity
zsocket_set_sndhwm (self->mailbox, PEER_EXPIRED * 100);

//  Send messages immediately or return EAGAIN
zsocket_set_sndtimeo (self->mailbox, 0);

//  Connect through to peer node
zsocket_connect (self->mailbox, "tcp://%s", endpoint);
{{< /fragment >}}

最後に、ピアで<tt>EAGAIN</tt>が表示されたときはどうすればいいのでしょうか。有効期限内にピアからメッセージが届かなければ、インターフェイスが自動的にこれを行うので、ピアを破壊するためのすべての作業を行う必要はない。最後のメッセージをドロップするだけでは、受信側のピアに隙を与えてしまうので、非常に弱いように思えます。

私は、もっと残酷な対応を望みます。残酷なのは、「うまくいくはずだが、正直なところエッジケースが多いので後で考えよう」という曖昧な判断ではなく、「良い」か「悪い」かの判断を設計に強いることができるからです。ソケットを破棄し、ピアを切断し、何も送信しないようにします。ピアはいずれ再接続し、あらゆる状態を再初期化する必要があります。1秒間に100メッセージもあれば、誰でも十分だという主張のようなものです。そこで、<tt>zre_peer_send</tt>メソッドでは、次のようにしています：

{{< fragment name="zyre-peer-send" >}}
int
zre_peer_send (zre_peer_t *self, zre_msg_t **msg_p)
{
    assert (self);
    if (self->connected) {
        if (zre_msg_send (msg_p, self->mailbox) && errno == EAGAIN) {
            zre_peer_disconnect (self);
            return -1;
        }
    }
    return 0;
}
{{< /fragment >}}

disconnectメソッドがこんな感じになっているところ：

{{< fragment name="zyre-peer-disconnect" >}}
void
zre_peer_disconnect (zre_peer_t *self)
{
    //  If connected, destroy socket and drop all pending messages
    assert (self);
    if (self->connected) {
        zsocket_destroy (self->ctx, self->mailbox);
        free (self->endpoint);
        self->endpoint = NULL;
        self->connected = false;
    }
}
{{< /fragment >}}

## 分散ロギングとモニタリング {#Distributed-Logging-and-Monitoring}

ロギングとモニタリングについて見ていきましょう。実際のサーバー（Webサーバーなど）を管理したことがある人なら、何が起こっているのかを把握することがいかに重要かを知っているはずです。理由はたくさんありますが、特に以下のようなものがあります：

* システムのパフォーマンスを長期的に測定する。
* パフォーマンスを最適化するために、どのような作業が最も多く行われるかを確認する。
* エラーとその発生頻度を追跡するため。
* 失敗の検死をするため。
* 紛争時の監査証跡を提供する。

私たちが解決しなければならないと考えている問題の観点から、この範囲を広げてみましょう：

* 重要なイベント（ノードのネットワーク離脱や再参加など）を追跡したい。
* 各イベントについて、日付/時間、イベントを観察したノード、イベントを作成したピア、イベント自体のタイプ、その他のイベントデータなど、一貫したデータのセットを追跡したい。
* ロギングのオンとオフをいつでも切り替えることができるようにしたい。
* ログデータが膨大になるため、機械的に処理できるようにしたい。
* 稼働中のシステムを監視し、リアルタイムにログを収集し、分析できるようにしたい。
* ログのトラフィックがネットワークに与える影響を最小限にしたい。
* ネットワーク上の一点でログデータを収集できるようにしたい。

どのような設計でもそうですが、これらの要件の中には、互いに敵対するものがあります。例えば、リアルタイムでログデータを収集するということは、ネットワーク上でログデータを送信するということであり、ネットワークトラフィックにある程度の影響を与えることになります。しかし、どのような設計でもそうですが、これらの要件も実行するコードができるまでは仮定の話なので、あまり深刻に考える必要はありません。私たちは、「もっともらしい十分な性能」を目指し、時間をかけて改善していくことにします。

### もっともらしい最小限の実装 {#A-Plausible-Minimal-Implementation}

おそらく、ログデータをディスクにダンプすることは1つの解決策であり、ほとんどのモバイルアプリケーションがそうしています（「デバッグログ」を使用）。しかし、ほとんどの障害では、2つのノードからのイベントの相関が必要です。そのため、多くのデバッグログを手作業で検索して、重要なものを見つける必要があります。これはあまり賢いやり方ではありません。

私たちは、ログデータをどこか中心的な場所に、即座に、あるいは日和見的に（つまり、保存と転送）送りたいのです。今のところ、即時のログ収集に焦点を当てましょう。データの送信に関しては、私の最初のアイデアは、これにZyreを使用することです。LOG」というグループにログデータを送り、誰かがそれを収集してくれることを祈るだけです。

しかし、Zyreを使ってZyre自体のログを取るというのは、Catch-22です。誰がロガーにログを残すのか？送信されるすべてのメッセージの冗長なログが欲しい場合はどうすればいいのか？その中にロギングメッセージを含めるのか、含めないのか？すぐに面倒なことになる。ZyreのメインZREプロトコルから独立したロギングプロトコルが必要です。最もシンプルなアプローチは、PUB-SUBプロトコルです。すべてのノードがPUBソケットでログデータを公開し、コレクターがSUBソケットでそれを拾います。

{{< textdiagram name="fig69.png" figno="69" title="Distributed Log Collection" >}}
#--------#      #--------#      #--------#
|  Node  |      |  Node  |      |  Node  |
+--------+      +--------+      +--------+
|  PUB   |      |  PUB   |      |  PUB   |
'---+----'      '---+----'      '---+----'
    |               |               |
    '---------------+---------------'
                    |
                    v
              .-----------.
              |    SUB    |
              +-----------+
              | Collector |
              #-----------#
{{< /textdiagram >}}

コレクターはもちろん、どのノードでも実行できます。このため、さまざまな使用例があります：

* これは、数週間または数ヶ月のログデータのために十分なハードディスクスペースを持つPCになります。

* ログデータをデータベースに保存し、他のアプリケーションでリアルタイムに使用することができるコレクタです。これは、小さなワークグループには過剰かもしれませんが、大きなグループのパフォーマンスを追跡するためには素晴らしいものです。コレクターはWiFiでログデータを収集し、それをイーサネットでどこかのデータベースに転送することができます。

* Zyreネットワークに参加し、ノードからログデータを収集し、イベントと統計をリアルタイムで表示するライブメーターアプリケーション。

次の問題は、ノードとコレクタをどのように相互接続するかです。どちらが結合し、どちらが接続するのか？ここではどちらの方法も有効ですが、PUBソケットがSUBソケットに接続する方が僅かながら有利です。思い起こせば、ZeroMQの内部バッファは、接続があるときだけ存在するようにポップします。つまり、ノードがコレクターに接続するとすぐに、損失なくログデータの送信を開始することができます。

ノードにどのエンドポイントに接続するか、どのように伝えるか？ネットワーク上にいくつものコレクターがあり、任意のネットワークアドレスとポートを使用する可能性があります。ある種のサービスアナウンス機構が必要ですが、ここではZyreを使用してその作業を行うことができます。グループメッセージングを使うこともできますが、ZREプロトコル自体にサービスディスカバリを組み込んだ方が良さそうです。ノードがサービス X を提供する場合、<tt>HELLO</tt> コマンドを送信すると、他のノードにそのことを伝えることができます。

ここでは、<tt>HELLO</tt>コマンドを拡張し、名前=値のペアのセットを保持する*headers*フィールドを持つことにします。ヘッダー <tt>X-ZRELOG</tt> がコレクターのエンドポイント (SUB ソケット) を指定することを定義しましょう。コレクターとして動作するノードは、次のようなヘッダーを追加することができます（例：）：

```
X-ZRELOG=tcp://192.168.1.122:9992
```

他のノードがこのヘッダを見ると、そのエンドポイントにPUBソケットを接続するだけです。これで、ログデータはネットワーク上のすべてのコレクター（0個以上）に配信されるようになりました。

この最初のバージョンを作るのはとても簡単で、半日かかりました。以下は、私たちが作ったり変更したりしなければならなかった部分です：

* ログデータを受け取り、もしあればコレクターへの接続を管理する新しいクラス <tt>zre_log</tt> を作りました。
<tt>HELLO</tt> コマンドから取得した、ピアヘッダーの基本的な管理方法を追加しました。
* ピアに <tt>X-ZRELOG</tt> ヘッダがある場合、それが指定するエンドポイントに接続します。
* 標準出力にロギングしていたところを、<tt>zre_log</tt>クラス経由のロギングに切り替えました。
* アプリケーションにヘッダーを設定させるメソッドでインターフェースAPIを拡張しました。
* SUBソケットを管理し、<tt>X-ZRELOG</tt>ヘッダを設定する簡単なロガーアプリケーションを作成しました。
* <tt>HELLO</tt> コマンドを送信する際に、独自のヘッダを送信しています。

このバージョンはZyreリポジトリでv0.4.0としてタグ付けされており、この段階のコードがどのようなものか見たい場合は[tarballをダウンロード](https://github.com/zeromq/zyre/tags)してください。

この段階では、ログメッセージはただの文字列です。もう少ししたら、もっと専門的に構造化されたログデータを作ることになるでしょう。

まず、ダイナミック・ポートについてのメモです。私たちがテストに使っている <tt>zre_tester</tt> アプリでは、積極的にインターフェースを作成したり破棄したりしています。その結果、新しいインターフェースは、他のアプリケーションによって解放されたポートを簡単に再利用できるようになりました。このポートに接続しようとするZeroMQソケットがどこかにある場合、結果はおかしなことになる可能性があります。

私が経験したシナリオは次のとおりで、数分間の混乱を引き起こしました。ロガーは動的ポートで実行されていました：

* ロガー・アプリケーションの開始
* テスター・アプリケーションの開始
* ロガーを停止する
* テスターは無効なメッセージを受け取る（そして設計通りにアサートする）。

テスターが新しいインターフェースを作成すると、ロガー（ちょうど停止した）により解放されたダイナミックポートを再利用し、突然インターフェースがそのメールボックス上のノードからログデータを受信し始めた。以前にも同じような状況で、新しいインターフェイスが古いインターフェイスによって解放されたポートを再利用し、古いデータを取得し始めることがありました。

教訓は、動的ポートを使用する場合、再接続している不勉強なアプリケーションからランダムなデータを受信する覚悟が必要だということです。静的ポートに切り替えることで、挙動不審な接続を止めることができました。しかし、それは完全な解決策ではありません。あと2つ弱点があります：

* これを書いている時点で、<tt>libzmq</tt>は接続時にソケットタイプをチェックしません。ZMTP/2.0 プロトコル](http://rfc.zeromq.org/spec:15) は、各ピアのソケットタイプをアナウンスするので、このチェックは可能です。

* ZREプロトコルはフェイルファスト(アサーション)機構を持たないので、無効であることを認識する前にメッセージ全体を読み、解析する必要があります。

2つ目の問題に取り組みましょう。ソケットペアの検証は、いずれにせよ、この問題を完全に解決することはできない。

### プロトコルアサーション {#Protocol-Assertions}

Wikipediaによると、「フェイルファストシステムは通常、欠陥のある可能性のあるプロセスを継続しようとするのではなく、通常の動作を停止するように設計されている」そうです。HTTPのようなプロトコルは、クライアントがHTTPサーバーに送る最初の4バイトが「HTTP」でなければならないというフェイルファスト機構を備えています。もしそうでなければ、サーバーはそれ以上何も読まずに接続を閉じることができます。

ROUTERソケットはコネクション指向ではないので、悪い受信メッセージを受け取ったときに「コネクションを閉じる」方法はありません。しかし、有効でないメッセージはすべて捨てることができます。この問題は、エフェメラルポートを使用する場合に悪化しますが、すべてのプロトコルに広く適用されます。

そこで、*プロトコルアサーション*を、各メッセージの先頭に置く、意図したプロトコルを識別する一意の署名と定義することにする。メッセージを読むとき、署名をチェックし、期待するものと違う場合は、メッセージを黙って破棄する。良い署名は、通常のデータと混同しにくく、多くのプロトコルのための十分なスペースを与えるものでなければなりません。

ここでは、12ビットのパターンと4ビットのプロトコルIDからなる16ビットの署名を使用することにします。パターン %xAAA は、メッセージの先頭で見られると思われる値から離れることを意図しています： x00、%xFF、および印刷可能な文字です。

{{< textdiagram name="fig70.png" figno="70" title="Protocol Signature" >}}
#---+---+---+---+---+---+---+---#  #---+---+---+---+---------------#
| 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 |  | 1 | 0 | 1 | 0 |   Signature   |
#---+---+---+---+---+---+---+---#  #---+---+---+---+---------------#

             Byte 0                             Byte 1
{{< /textdiagram >}}

私たちのプロトコルコーデックは生成されるため、このアサーションを追加するのは比較的簡単です。ロジックは次の通りです：

* メッセージの最初のフレームを取得する。
* 最初の2バイトが%xAAAで、期待される4ビット署名があるかどうかをチェックする。
* もしそうなら、メッセージの残りの部分を解析し続ける。
* もしそうでなければ、すべての「more」フレームをスキップして、最初のフレームを取得し、繰り返します。

これをテストするために、ロガーをエフェメラルポートの使用に戻しました。インターフェイスは、有効なシグネチャーを持たないメッセージを適切に検出し、破棄するようになりました。メッセージに有効な署名があるにもかかわらず、*まだ*間違っている場合、それは適切なバグである。

### バイナリロギングプロトコル {#Binary-Logging-Protocol}

さて、ロギングフレームワークが正しく動作するようになったので、プロトコル自体を見てみましょう。ネットワーク上で文字列を送信するのは簡単ですが、WiFiに関しては、帯域幅を無駄にするわけにはいきません。効率的なバイナリプロトコルを扱うためのツールはあるので、ロギング用のものを設計してみましょう。

これはpub-subプロトコルで、ZeroMQ v3.xではパブリッシャーサイドフィルタリングを行う予定です。つまり、メッセージの最初にロギングレベルを設定すれば、マルチレベルのロギング（エラー、警告、情報）を行うことができます。つまり、メッセージはプロトコル署名（2バイト）、ロギングレベル（1バイト）、イベントタイプ（1バイト）で始まります。

最初のバージョンでは、各ノードを識別するためにUUID文字列を送信します。テキストとして、これらはそれぞれ32文字である。バイナリUUIDを送信することもできますが、それでも冗長で無駄があります。私たちは、ログファイル内のノード識別子を気にしていません。必要なのは、イベントを相関させる何らかの方法だけです。では、ログに記録するのに十分なユニークさを持つ、最も短い識別子は何でしょうか。十分ユニーク」というのは、ライブコードではUUIDが重複する可能性をゼロにしたいが、ログファイルではそれほど重要ではないからだ。

最も単純でもっともらしい答えは、IPアドレスとポートを2バイトの値にハッシュ化することです。衝突は起こるかもしれませんが、それはまれなことです。どのように珍しいのか？簡単なチェックとして、アドレスを大量に生成して16ビット値にハッシュ化し、衝突を探す小さなプログラムを書いてみました。念のため、少数のIPアドレスで1万個のアドレスを生成し（シミュレーションの設定と一致）、さらに多数のアドレスで生成する（現実の設定と一致）。ハッシュアルゴリズムは、*modified Bernstein*です：

{{< fragment name="endpoint-hashing" >}}
uint16_t hash = 0;
while (*endpoint)
    hash = 33 * hash ^ *endpoint++;
{{< /fragment >}}

何度か実行しても衝突しないので、これはログデータの識別子として機能します。これにより、4バイトが追加されます（イベントを記録するノードに対して2バイト、ピアから来たイベントの場合はそのピアに対して2バイト）。

次に、イベントの日付と時刻を保存することにします。POSIX の <tt>time_t</tt> 型は以前は32ビットでしたが、2038年にオーバーフローするため、64ビット値になりました。ログファイルではミリ秒の分解能は必要ありません。イベントは連続したものであり、時計はそれほど厳密に同期されることはなく、ネットワークの遅延は正確な時間がそれほど意味をなさないことを意味します。

16バイトまでなら問題ないでしょう。最後に、イベントの種類に応じたテキスト形式の追加データを許可したいと思います。これをまとめると、次のようなメッセージ仕様になります：

```
<class
    name = "zre_log_msg"
    script = "codec_c.gsl"
    signature = "2"
>
This is the ZRE logging protocol - raw version.
<include filename = "license.xml" />

<!-- Protocol constants -->
<define name = "VERSION" value = "1" />

<define name = "LEVEL_ERROR" value = "1" />
<define name = "LEVEL_WARNING" value = "2" />
<define name = "LEVEL_INFO" value = "3" />

<define name = "EVENT_JOIN" value = "1" />
<define name = "EVENT_LEAVE" value = "2" />
<define name = "EVENT_ENTER" value = "3" />
<define name = "EVENT_EXIT" value = "4" />

<message name = "LOG" id = "1">
    <field name = "level" type = "number" size = "1" />
    <field name = "event" type = "number" size = "1" />
    <field name = "node" type = "number" size = "2" />
    <field name = "peer" type = "number" size = "2" />
    <field name = "time" type = "number" size = "8" />
    <field name = "data" type = "string" />
Log an event
</message>

</class>
```

これは、800行の完全なバイナリコーデック（<tt>zre_log_msg</tt>クラス）を生成します。このコーデックは、メインのZREプロトコルが行うのと同じように、プロトコルのアサーションを行います。コード生成はかなり急なスタートカーブですが、あなたのデザインを「アマチュア」から「プロ」へと押し上げるのがとても簡単になります。

## コンテンツ配信 {#Content-Distribution}

ノードのグループを作成し、互いにチャットさせ、結果として生じるネットワークを監視するための強固なフレームワークを手に入れました。次のステップは、ノードがコンテンツをファイルとして配布できるようにすることです。

いつものように、最も単純でもっともらしい解決策を目指し、それを段階的に改善していくことにします。最低限、次のようなことが必要です：

* アプリケーションは、Zyre APIに "Publish this file "と伝え、ファイルシステムのどこかに存在するファイルへのパスを提供することができます。
* Zyreは、そのファイルを、その時点でネットワーク上にいるピアと、後から到着したピアの両方に配布します。
* インターフェイスがファイルを受信するたびに、そのアプリケーションに「このファイルです」と伝えます。

いずれは、特定のグループへの公開など、より多くの差別化が必要になるかもしれません。必要であれば、後でそれを追加することができます。第7章 ZeroMQを使った高度なアーキテクチャ](chapter7#advanced-architecture)では、ZeroMQアプリケーションにプラグインできるように設計されたファイル配布システム(FileMQ)を開発しています。では、それを使ってみましょう。

各ノードは、ファイルパブリッシャーとファイルサブスクライバーになる予定です。パブリッシャーをエフェメラルなポートにバインドし（標準のFileMQポート5670を使用すると、1つのボックスで複数のインターフェースを実行できません）、ログコレクターで行ったように、<tt>HELLO</tt>メッセージでパブリッシャーのエンドポイントを放送します。これにより、すべてのノードが相互接続され、すべてのサブスクライバーがすべてのパブリッシャーと話すことができるようになります。

各ノードがファイルを送受信するための独自のディレクトリ（outboxとinbox）を持っていることを確認する必要があります。これも、1つのボックスで複数のノードを実行するためです。すでにノードごとにユニークなIDを持っているので、それをディレクトリ名に使用するだけです。

新しいインターフェイスを作成するときのFileMQ APIの設定方法は次のとおりです：

{{< fragment name="filemq-outbox" >}}
sprintf (self->fmq_outbox, ".outbox/%s", self->identity);
mkdir (self->fmq_outbox, 0775);

sprintf (self->fmq_inbox, ".inbox/%s", self->identity);
mkdir (self->fmq_inbox, 0775);

self->fmq_server = fmq_server_new ();
self->fmq_service = fmq_server_bind (self->fmq_server, "tcp://*:*");
fmq_server_publish (self->fmq_server, self->fmq_outbox, "/");
fmq_server_set_anonymous (self->fmq_server, true);
char publisher [32];
sprintf (publisher, "tcp://%s:%d", self->host, self->fmq_service);
zhash_update (self->headers, "X-FILEMQ", strdup (publisher));

//  Client will connect as it discovers new nodes
self->fmq_client = fmq_client_new ();
fmq_client_set_inbox (self->fmq_client, self->fmq_inbox);
fmq_client_set_resync (self->fmq_client, true);
fmq_client_subscribe (self->fmq_client, "/");
{{< /fragment >}}

また、<tt>HELLO</tt>コマンドを処理する際に、<tt>X-FILEMQ</tt>ヘッダーフィールドがあるかどうかをチェックします：

{{< fragment name="filemq-connect" >}}
//  If peer is a FileMQ publisher, connect to it
char *publisher = zre_msg_headers_string (msg, "X-FILEMQ", NULL);
if (publisher)
    fmq_client_connect (self->fmq_client, publisher);
{{< /fragment >}}

最後に、Zyre APIでコンテンツ配信を公開することです。2つのことが必要です：

* アプリケーションが "このファイルを発行してください "と言う方法です。
* インターフェイスがアプリケーションに "We received this file "と伝える方法。

理論的には、アプリケーションはoutboxディレクトリにシンボリックリンクを作成するだけでファイルを公開することができますが、私たちはhidden outboxを使用しているので、これは少し難しいです。そこで、APIメソッド<tt>publish</tt>を追加します：

{{< fragment name="publish-file" >}}
//  Publish file into virtual space
void
zre_interface_publish (zre_interface_t *self,
                       char *filename, char *external)
{
    zstr_sendm (self->pipe, "PUBLISH");
    zstr_sendm (self->pipe, filename);  //  Real file name
    zstr_send  (self->pipe, external);  //  Location in virtual space
}
{{< /fragment >}}

APIはこれをインターフェイススレッドに渡し、FileMQサーバーがこれを拾ってブロードキャストするようにoutboxディレクトリにファイルを作成する。このディレクトリに文字通りファイルデータをコピーすることもできますが、FileMQはシンボリックリンクをサポートしているので、代わりにそれを使っています。ファイルの拡張子は「.ln」、行数は1行で、実際のパス名が入っています。

最後に、ファイルが到着したことをどのように受信者に通知するのでしょうか。FileMQ <tt>fmq_client</tt> API には、このためのメッセージ "DELIVER" があるので、<tt>zre_interface</tt> で行うことは、<tt>fmq_client</tt> API からこのメッセージを取得し、独自の API に渡すだけです：

{{< fragment name="forward-deliver" >}}
zmsg_t *msg = fmq_client_recv (fmq_client_handle (self->fmq_client));
zmsg_send (&msg, self->pipe);
{{< /fragment >}}

これは、一度に多くのことを行う複雑なコードです。しかし、FileMQとZyreを合わせても10K行程度のコードに過ぎません。最も複雑なZyreのクラスである<tt>zre_interface</tt>は、800行のコードです。これはコンパクトです。メッセージベースのアプリケーションは、きちんと整理することに気をつければ、その形を保つことができるのです。

## アンプロトコルを書く {#Writing-the-Unprotocol}

正式なプロトコル仕様のためのすべてのピースが揃ったので、いよいよプロトコルを紙に書き出すことにします。これには2つの理由がある。第一に、他の実装がお互いに正しく会話できるようにするためです。2つ目は、UDPディスカバリープロトコルの公式ポートを取得したいからで、これは書類作成を意味します。

この本で開発した他のすべての非プロトコルと同様に、プロトコルは[ZeroMQ RFCサイト](http://rfc.zeromq.org/spec:20)に存在します。プロトコル仕様の中核は、コマンドとフィールドのABNF文法です：

```
zre-protocol    = greeting *traffic

greeting        = S:HELLO
traffic         = S:WHISPER
                / S:SHOUT
                / S:JOIN
                / S:LEAVE
                / S:PING R:PING-OK

;   Greet a peer so it can connect back to us
S:HELLO         = header %x01 ipaddress mailbox groups status headers
header          = signature sequence
signature       = %xAA %xA1
sequence        = 2OCTET        ; Incremental sequence number
ipaddress       = string        ; Sender IP address
string          = size *VCHAR
size            = OCTET
mailbox         = 2OCTET        ; Sender mailbox port number
groups          = strings       ; List of groups sender is in
strings         = size *string
status          = OCTET         ; Sender group status sequence
headers         = dictionary    ; Sender header properties
dictionary      = size *key-value
key-value       = string        ; Formatted as name=value

; Send a message to a peer
S:WHISPER       = header %x02 content
content         = FRAME         ; Message content as ZeroMQ frame

; Send a message to a group
S:SHOUT         = header %x03 group content
group           = string        ; Name of group
content         = FRAME         ; Message content as ZeroMQ frame

; Join a group
S:JOIN          = header %x04 group status
status          = OCTET         ; Sender group status sequence

; Leave a group
S:LEAVE         = header %x05 group status

; Ping a peer that has gone silent
S:PING          = header %06

; Reply to a peer's ping
R:PING-OK       = header %07
```

## Example Zyre Application {#Example-Zyre-Application}

それでは、Zyreを使ってファイルを分散ネットワークに流すための最小限の例を作ってみましょう。この例は2つのプログラムで構成されています：

* Zyreのネットワークに参加し、ファイルを受信するたびに報告する*リスナー*。
Zyreネットワークに参加し、ファイルを受信するたびに報告する*リスナー* * Zyreネットワークに参加し、正確に1つのファイルをブロードキャストする*センダー*。

リスナーは非常に短いです：

{{< fragment name="zyre-listener" >}}
#include <zre.h>

int main (int argc, char *argv [])
{
    zre_interface_t *interface = zre_interface_new ();
    while (true) {
        zmsg_t *incoming = zre_interface_recv (interface);
        if (!incoming)
            break;
        zmsg_dump (incoming);
        zmsg_destroy (&incoming);
    }
    zre_interface_destroy (&interface);
    return 0;
}
{{< /fragment >}}

そして、センダーもそれほど長くはない：

{{< fragment name="zyre-sender" >}}
#include <zre.h>

int main (int argc, char *argv [])
{
    if (argc < 2) {
        puts ("Syntax: sender filename virtualname");
        return 0;
    }
    printf ("Publishing %s as %s\n", argv [argv [2](1],));
    zre_interface_t *interface = zre_interface_new ();
    zre_interface_publish (interface, argv [argv [2](1],));
    while (true) {
        zmsg_t *incoming = zre_interface_recv (interface);
        if (!incoming)
            break;
        zmsg_dump (incoming);
        zmsg_destroy (&incoming);
    }
    zre_interface_destroy (&interface);
    return 0;
}
{{< /fragment >}}

## 結論 {#Conclusions}

不安定な分散型ネットワーク用のアプリケーションを構築することは、ZeroMQのエンドゲームの1つです。コンピューティングのコストが年々低下しているため、家電製品やクラウド上の仮想ボックスなど、このようなネットワークはますます一般的になってきています。この章では、本書で紹介したテクニックの多くを結集して、ローカルネットワーク上での近接コンピューティングのためのフレームワークであるZyreを構築しました。Zyreは特別なものではなく、この分野をアプリケーションに開放しようとする試みは数多くありますし、これまでもありました： ZeroConf、SLP、SSDP、UPnP、DDSなどです。しかし、これらはすべて、アプリケーション開発者が構築するには複雑すぎるか、そうでなければ難しすぎるという結果に終わっているようです。

Zyreはまだ完成していません。本書の多くのプロジェクトと同様に、他の人のためのアイスブレーカーなのです。いくつかの主要な未完成の領域があり、それらは本書の後の版やソフトウェアのバージョンで扱うかもしれません。

* Zyreが現在提供しているメッセージベースのAPIは、使い勝手は良いのですが、一般的な開発者にとっては、まだかなり複雑です。もし私たちが絶対に外せないターゲットがあるとすれば、それは生の*シンプルさ*です。つまり、メッセージングをすべて隠蔽し、開始、グループへの参加/離脱、メッセージの取得、ファイルの公開、停止といったシンプルなメソッドに集約された高レベルのAPIを、多くの言語で構築する必要があります。

* セキュリティ：完全に分散化されたセキュリティシステムを構築するにはどうすればいいのか？公開鍵基盤を活用できるかもしれませんが、そのためにはノードが独自のインターネットアクセスを持つ必要があり、それは保証されたものではありません。答えは、既存の安全なピアツーピアリンク（TLS、BlueTooth、おそらくNFC）を使ってセッションキーを交換し、対称型暗号を使用することだそうです。対称型暗号には利点と欠点があります。

* ノマドコンテンツ：ユーザーとして、複数のデバイスにまたがるコンテンツをどのように管理すればいいのか？ZyreとFileMQの組み合わせは、ローカルネットワークでの使用には役立つかもしれませんが、インターネット上でもできるようにしたいです。クラウドサービスを利用できないか？ZeroMQを使って何か作れるものはないでしょうか？

* フェデレーション：ローカルに分散したアプリケーションを世界中に広げるにはどうしたらいいか？もっともらしい答えのひとつは、フェデレーション、つまりクラスタのクラスタを作るということです。100のノードが一緒になってローカルクラスタを作ることができるなら、100のクラスタが一緒になって広域クラスタを作ることができるかもしれません。ディスカバリー、プレゼンス、グループメッセージングなど、課題は非常に似ています。

